---
source: tests/integration/languages/extractor.rs
expression: "serde_json::to_string_pretty(&snapshot_data).unwrap()"
---
{
  "chunks": [
    {
      "chunk_type": "File",
      "comment_ranges": [
        [
          468,
          520
        ],
        [
          698,
          749
        ],
        [
          1445,
          1488
        ]
      ],
      "content": "\n#[derive(Debug, Clone)]\npub struct DataCache<T> {\n    cache: HashMap<String, T>,\n    max_size: usize,\n    access_count: HashMap<String, usize>,\n}\n\nimpl<T: Clone> DataCache<T> {\n    pub fn new(max_size: usize) -> Self {\n        Self {\n            cache: HashMap::new(),\n            max_size,\n            access_count: HashMap::new(),\n        }\n    }\n\n    pub fn get_or_insert<F>(&mut self, key: &str, compute: F) -> T\n    where\n        F: FnOnce() -> T,\n    {\n        // Cache management logic - extractable middle chunk\n        if let Some(value) = self.cache.get(key) {\n            *self.access_count.entry(key.to_string()).or_insert(0) += 1;\n            return value.clone();\n        }\n\n        // Check if cache is full and evict least used item\n        if self.cache.len() >= self.max_size {\n            if let Some(lru_key) = self.find_least_used_key() {\n                self.cache.remove(&lru_key);\n                self.access_count.remove(&lru_key);\n            }\n        }\n\n        let computed_value = compute();\n        self.cache.insert(key.to_string(), computed_value.clone());\n        self.access_count.insert(key.to_string(), 1);\n        computed_value\n    }\n\n    fn find_least_used_key(&self) -> Option<String> {\n        self.access_count\n            .iter()\n            .min_by_key(|(_, &count)| count)\n            .map(|(key, _)| key.clone())\n    }\n\n    pub fn clear_stale_entries(&mut self, max_access_count: usize) {\n        // Cleanup logic - extractable middle chunk\n        let stale_keys: Vec<String> = self\n            .access_count\n            .iter()\n            .filter(|(_, &count)| count > max_access_count)\n            .map(|(key, _)| key.clone())\n            .collect();\n\n        for key in stale_keys {\n            self.cache.remove(&key);\n            self.access_count.remove(&key);\n        }\n    }\n}\n",
      "end_line": 63,
      "language": "rust",
      "name": "entire_file",
      "original_indentation": 0,
      "start_line": 1
    },
    {
      "chunk_type": "Struct",
      "comment_ranges": [],
      "content": "pub struct DataCache<T> {\n    cache: HashMap<String, T>,\n    max_size: usize,\n    access_count: HashMap<String, usize>,\n}",
      "end_line": 7,
      "language": "rust",
      "name": "DataCache",
      "original_indentation": 0,
      "start_line": 3
    },
    {
      "chunk_type": "Function",
      "comment_ranges": [],
      "content": "    pub fn new(max_size: usize) -> Self {\n        Self {\n            cache: HashMap::new(),\n            max_size,\n            access_count: HashMap::new(),\n        }\n    }",
      "end_line": 16,
      "language": "rust",
      "name": "new",
      "original_indentation": 4,
      "start_line": 10
    },
    {
      "chunk_type": "Function",
      "comment_ranges": [
        [
          117,
          169
        ],
        [
          347,
          398
        ]
      ],
      "content": "    pub fn get_or_insert<F>(&mut self, key: &str, compute: F) -> T\n    where\n        F: FnOnce() -> T,\n    {\n        // Cache management logic - extractable middle chunk\n        if let Some(value) = self.cache.get(key) {\n            *self.access_count.entry(key.to_string()).or_insert(0) += 1;\n            return value.clone();\n        }\n\n        // Check if cache is full and evict least used item\n        if self.cache.len() >= self.max_size {\n            if let Some(lru_key) = self.find_least_used_key() {\n                self.cache.remove(&lru_key);\n                self.access_count.remove(&lru_key);\n            }\n        }\n\n        let computed_value = compute();\n        self.cache.insert(key.to_string(), computed_value.clone());\n        self.access_count.insert(key.to_string(), 1);\n        computed_value\n    }",
      "end_line": 40,
      "language": "rust",
      "name": "get_or_insert",
      "original_indentation": 4,
      "start_line": 18
    },
    {
      "chunk_type": "CodeBlock",
      "comment_ranges": [
        [
          14,
          66
        ],
        [
          244,
          295
        ]
      ],
      "content": "    {\n        // Cache management logic - extractable middle chunk\n        if let Some(value) = self.cache.get(key) {\n            *self.access_count.entry(key.to_string()).or_insert(0) += 1;\n            return value.clone();\n        }\n\n        // Check if cache is full and evict least used item\n        if self.cache.len() >= self.max_size {\n            if let Some(lru_key) = self.find_least_used_key() {\n                self.cache.remove(&lru_key);\n                self.access_count.remove(&lru_key);\n            }\n        }\n\n        let computed_value = compute();\n        self.cache.insert(key.to_string(), computed_value.clone());\n        self.access_count.insert(key.to_string(), 1);\n        computed_value\n    }",
      "end_line": 40,
      "language": "rust",
      "name": "code_block",
      "original_indentation": 4,
      "start_line": 21
    },
    {
      "chunk_type": "Conditional",
      "comment_ranges": [],
      "content": "        if let Some(value) = self.cache.get(key) {\n            *self.access_count.entry(key.to_string()).or_insert(0) += 1;\n            return value.clone();\n        }",
      "end_line": 26,
      "language": "rust",
      "name": "if_block",
      "original_indentation": 8,
      "start_line": 23
    },
    {
      "chunk_type": "Conditional",
      "comment_ranges": [],
      "content": "        if self.cache.len() >= self.max_size {\n            if let Some(lru_key) = self.find_least_used_key() {\n                self.cache.remove(&lru_key);\n                self.access_count.remove(&lru_key);\n            }\n        }",
      "end_line": 34,
      "language": "rust",
      "name": "if_block",
      "original_indentation": 8,
      "start_line": 29
    },
    {
      "chunk_type": "Conditional",
      "comment_ranges": [],
      "content": "            if let Some(lru_key) = self.find_least_used_key() {\n                self.cache.remove(&lru_key);\n                self.access_count.remove(&lru_key);\n            }",
      "end_line": 33,
      "language": "rust",
      "name": "if_block",
      "original_indentation": 12,
      "start_line": 30
    },
    {
      "chunk_type": "Function",
      "comment_ranges": [],
      "content": "    fn find_least_used_key(&self) -> Option<String> {\n        self.access_count\n            .iter()\n            .min_by_key(|(_, &count)| count)\n            .map(|(key, _)| key.clone())\n    }",
      "end_line": 47,
      "language": "rust",
      "name": "find_least_used_key",
      "original_indentation": 4,
      "start_line": 42
    },
    {
      "chunk_type": "FunctionCall",
      "comment_ranges": [],
      "content": "        self.access_count\n            .iter()",
      "end_line": 44,
      "language": "rust",
      "name": "function_call",
      "original_indentation": 8,
      "start_line": 43
    },
    {
      "chunk_type": "FunctionCall",
      "comment_ranges": [],
      "content": "        self.access_count\n            .iter()\n            .min_by_key(|(_, &count)| count)",
      "end_line": 45,
      "language": "rust",
      "name": "function_call",
      "original_indentation": 8,
      "start_line": 43
    },
    {
      "chunk_type": "FunctionCall",
      "comment_ranges": [],
      "content": "        self.access_count\n            .iter()\n            .min_by_key(|(_, &count)| count)\n            .map(|(key, _)| key.clone())",
      "end_line": 46,
      "language": "rust",
      "name": "function_call",
      "original_indentation": 8,
      "start_line": 43
    },
    {
      "chunk_type": "Function",
      "comment_ranges": [
        [
          77,
          120
        ]
      ],
      "content": "    pub fn clear_stale_entries(&mut self, max_access_count: usize) {\n        // Cleanup logic - extractable middle chunk\n        let stale_keys: Vec<String> = self\n            .access_count\n            .iter()\n            .filter(|(_, &count)| count > max_access_count)\n            .map(|(key, _)| key.clone())\n            .collect();\n\n        for key in stale_keys {\n            self.cache.remove(&key);\n            self.access_count.remove(&key);\n        }\n    }",
      "end_line": 62,
      "language": "rust",
      "name": "clear_stale_entries",
      "original_indentation": 4,
      "start_line": 49
    },
    {
      "chunk_type": "FunctionCall",
      "comment_ranges": [],
      "content": "        let stale_keys: Vec<String> = self\n            .access_count\n            .iter()",
      "end_line": 53,
      "language": "rust",
      "name": "function_call",
      "original_indentation": 38,
      "start_line": 51
    },
    {
      "chunk_type": "FunctionCall",
      "comment_ranges": [],
      "content": "        let stale_keys: Vec<String> = self\n            .access_count\n            .iter()\n            .filter(|(_, &count)| count > max_access_count)",
      "end_line": 54,
      "language": "rust",
      "name": "function_call",
      "original_indentation": 38,
      "start_line": 51
    },
    {
      "chunk_type": "FunctionCall",
      "comment_ranges": [],
      "content": "        let stale_keys: Vec<String> = self\n            .access_count\n            .iter()\n            .filter(|(_, &count)| count > max_access_count)\n            .map(|(key, _)| key.clone())",
      "end_line": 55,
      "language": "rust",
      "name": "function_call",
      "original_indentation": 38,
      "start_line": 51
    },
    {
      "chunk_type": "FunctionCall",
      "comment_ranges": [],
      "content": "        let stale_keys: Vec<String> = self\n            .access_count\n            .iter()\n            .filter(|(_, &count)| count > max_access_count)\n            .map(|(key, _)| key.clone())\n            .collect()",
      "end_line": 56,
      "language": "rust",
      "name": "function_call",
      "original_indentation": 38,
      "start_line": 51
    },
    {
      "chunk_type": "Loop",
      "comment_ranges": [],
      "content": "        for key in stale_keys {\n            self.cache.remove(&key);\n            self.access_count.remove(&key);\n        }",
      "end_line": 61,
      "language": "rust",
      "name": "for_loop",
      "original_indentation": 8,
      "start_line": 58
    }
  ],
  "source_code": "\n#[derive(Debug, Clone)]\npub struct DataCache<T> {\n    cache: HashMap<String, T>,\n    max_size: usize,\n    access_count: HashMap<String, usize>,\n}\n\nimpl<T: Clone> DataCache<T> {\n    pub fn new(max_size: usize) -> Self {\n        Self {\n            cache: HashMap::new(),\n            max_size,\n            access_count: HashMap::new(),\n        }\n    }\n\n    pub fn get_or_insert<F>(&mut self, key: &str, compute: F) -> T\n    where\n        F: FnOnce() -> T,\n    {\n        // Cache management logic - extractable middle chunk\n        if let Some(value) = self.cache.get(key) {\n            *self.access_count.entry(key.to_string()).or_insert(0) += 1;\n            return value.clone();\n        }\n\n        // Check if cache is full and evict least used item\n        if self.cache.len() >= self.max_size {\n            if let Some(lru_key) = self.find_least_used_key() {\n                self.cache.remove(&lru_key);\n                self.access_count.remove(&lru_key);\n            }\n        }\n\n        let computed_value = compute();\n        self.cache.insert(key.to_string(), computed_value.clone());\n        self.access_count.insert(key.to_string(), 1);\n        computed_value\n    }\n\n    fn find_least_used_key(&self) -> Option<String> {\n        self.access_count\n            .iter()\n            .min_by_key(|(_, &count)| count)\n            .map(|(key, _)| key.clone())\n    }\n\n    pub fn clear_stale_entries(&mut self, max_access_count: usize) {\n        // Cleanup logic - extractable middle chunk\n        let stale_keys: Vec<String> = self\n            .access_count\n            .iter()\n            .filter(|(_, &count)| count > max_access_count)\n            .map(|(key, _)| key.clone())\n            .collect();\n\n        for key in stale_keys {\n            self.cache.remove(&key);\n            self.access_count.remove(&key);\n        }\n    }\n}\n",
  "test_name": "test_rust_struct_with_complex_impl",
  "total_chunks": 18
}
