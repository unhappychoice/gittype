---
source: tests/integration/languages/extractor.rs
expression: "serde_json::to_string_pretty(&snapshot_data).unwrap()"
---
{
  "chunks": [
    {
      "chunk_type": "File",
      "comment_ranges": [
        [
          621,
          676
        ],
        [
          2044,
          2067
        ],
        [
          2294,
          2315
        ],
        [
          2494,
          2522
        ],
        [
          2761,
          2813
        ],
        [
          3242,
          3264
        ],
        [
          3753,
          3775
        ],
        [
          4144,
          4186
        ],
        [
          4297,
          4353
        ],
        [
          4697,
          4744
        ],
        [
          4960,
          4999
        ]
      ],
      "content": "\nimport scala.collection.mutable\nimport scala.util.{Success, Failure, Try}\nimport java.time.Instant\n\ncase class ProcessedItem(\n  id: Int,\n  originalValue: Int,\n  transformedValue: Int,\n  category: String,\n  timestamp: Instant = Instant.now(),\n  metadata: mutable.Map[String, Any] = mutable.Map.empty\n)\n\nclass DataProcessor(threshold: Int) {\n  private val cache = mutable.Map[String, ProcessedItem]()\n  private val processingLog = mutable.ListBuffer[ProcessedItem]()\n\n  def processComplexData(input: List[Int]): List[ProcessedItem] = {\n    val results = mutable.ListBuffer[ProcessedItem]()\n    var processedCount = 0\n\n    // Main processing algorithm - extractable middle chunk\n    input.zipWithIndex.foreach { case (value, index) =>\n      val cacheKey = s\"item_${index}_$value\"\n\n      cache.get(cacheKey) match {\n        case Some(cachedItem) =>\n          results += cachedItem\n        case None =>\n          val processedItem = value match {\n            case v if v > threshold =>\n              val transformedValue = v * 2\n              val category = if (transformedValue > threshold * 3) \"HIGH\" else \"MEDIUM\"\n              val bonusValue = if (transformedValue > 100) transformedValue + 10 else transformedValue\n\n              processedCount += 1\n              ProcessedItem(\n                id = index,\n                originalValue = v,\n                transformedValue = bonusValue,\n                category = category,\n                metadata = mutable.Map(\n                  \"processed\" -> true,\n                  \"multiplier\" -> 2,\n                  \"processor\" -> \"enhanced\"\n                )\n              )\n\n            case v if v > 0 =>\n              ProcessedItem(\n                id = index,\n                originalValue = v,\n                transformedValue = v + threshold,\n                category = \"LOW\",\n                metadata = mutable.Map(\n                  \"processed\" -> true,\n                  \"adjusted\" -> true,\n                  \"processor\" -> \"basic\"\n                )\n              )\n\n            case _ => // skip negative values\n              null\n          }\n\n          if (processedItem != null) {\n            cache(cacheKey) = processedItem\n            processingLog += processedItem\n            results += processedItem\n          }\n      }\n    }\n\n    // Finalization logic\n    if (processedCount > 0) {\n      val average = results.map(_.transformedValue).sum.toDouble / results.size\n      println(f\"Processing complete. Average: $average%.2f\")\n\n      // Add processing statistics\n      results.foreach(_.metadata(\"processing_average\") = average)\n    }\n\n    results.toList\n  }\n\n  def analyzePatterns(items: List[ProcessedItem]): Map[String, Map[String, Any]] = {\n    val categoryGroups = items.groupBy(_.category)\n\n    // Pattern analysis logic - extractable middle chunk\n    val analysis = categoryGroups.map { case (category, categoryItems) =>\n      val values = categoryItems.map(_.transformedValue)\n      val categoryAnalysis = Map(\n        \"count\" -> categoryItems.size,\n        \"percentage\" -> (categoryItems.size.toDouble / items.size * 100),\n        \"avg_value\" -> (values.sum.toDouble / values.size),\n        \"min_value\" -> values.min,\n        \"max_value\" -> values.max\n      ) ++ {\n        // Time-based analysis\n        val currentTime = Instant.now()\n        val recentItems = categoryItems.filter { item =>\n          java.time.Duration.between(item.timestamp, currentTime).getSeconds < 60\n        }\n\n        if (recentItems.nonEmpty) {\n          val recentValues = recentItems.map(_.transformedValue)\n          Map(\n            \"recent_count\" -> recentItems.size,\n            \"recent_avg\" -> (recentValues.sum.toDouble / recentValues.size)\n          )\n        } else Map.empty\n      } ++ {\n        // High-value analysis\n        val highValueItems = categoryItems.filter(_.transformedValue > 1000)\n        if (highValueItems.nonEmpty) {\n          Map(\"high_value_count\" -> highValueItems.size)\n        } else Map.empty\n      }\n\n      category -> categoryAnalysis\n    }\n\n    analysis ++ Map(\n      \"total_items\" -> items.size,\n      \"processing_time\" -> Instant.now().toString\n    )\n  }\n}\n\n// Companion object with utility functions\nobject DataProcessor {\n  def createProcessor(threshold: Int): DataProcessor = new DataProcessor(threshold)\n\n  // Complex transformation function with pattern matching\n  def complexTransform(item: ProcessedItem): ProcessedItem = {\n    val newValue = item.category match {\n      case \"HIGH\" => item.transformedValue * 2\n      case \"MEDIUM\" => item.transformedValue + 50\n      case \"LOW\" => item.transformedValue + 10\n      case _ => item.transformedValue\n    }\n\n    item.copy(transformedValue = newValue)\n  }\n\n  // Functional approach to filtering and sorting\n  def filterAndSort(items: List[ProcessedItem], targetCategory: String): List[ProcessedItem] = {\n    items\n      .filter(_.category == targetCategory)\n      .sortBy(_.transformedValue)(Ordering[Int].reverse)\n  }\n\n  // Batch processing with error handling\n  def batchProcess(batches: List[List[Int]], threshold: Int): List[Try[List[ProcessedItem]]] = {\n    batches.map { batch =>\n      Try {\n        val processor = new DataProcessor(threshold)\n        processor.processComplexData(batch)\n      }\n    }\n  }\n}\n",
      "end_line": 163,
      "language": "scala",
      "name": "entire_file",
      "original_indentation": 0,
      "start_line": 1
    },
    {
      "chunk_type": "Class",
      "comment_ranges": [],
      "content": "case class ProcessedItem(\n  id: Int,\n  originalValue: Int,\n  transformedValue: Int,\n  category: String,\n  timestamp: Instant = Instant.now(),\n  metadata: mutable.Map[String, Any] = mutable.Map.empty\n)",
      "end_line": 13,
      "language": "scala",
      "name": "ProcessedItem",
      "original_indentation": 0,
      "start_line": 6
    },
    {
      "chunk_type": "Class",
      "comment_ranges": [
        [
          318,
          373
        ],
        [
          1741,
          1764
        ],
        [
          1991,
          2012
        ],
        [
          2191,
          2219
        ],
        [
          2458,
          2510
        ],
        [
          2939,
          2961
        ],
        [
          3450,
          3472
        ]
      ],
      "content": "class DataProcessor(threshold: Int) {\n  private val cache = mutable.Map[String, ProcessedItem]()\n  private val processingLog = mutable.ListBuffer[ProcessedItem]()\n\n  def processComplexData(input: List[Int]): List[ProcessedItem] = {\n    val results = mutable.ListBuffer[ProcessedItem]()\n    var processedCount = 0\n\n    // Main processing algorithm - extractable middle chunk\n    input.zipWithIndex.foreach { case (value, index) =>\n      val cacheKey = s\"item_${index}_$value\"\n\n      cache.get(cacheKey) match {\n        case Some(cachedItem) =>\n          results += cachedItem\n        case None =>\n          val processedItem = value match {\n            case v if v > threshold =>\n              val transformedValue = v * 2\n              val category = if (transformedValue > threshold * 3) \"HIGH\" else \"MEDIUM\"\n              val bonusValue = if (transformedValue > 100) transformedValue + 10 else transformedValue\n\n              processedCount += 1\n              ProcessedItem(\n                id = index,\n                originalValue = v,\n                transformedValue = bonusValue,\n                category = category,\n                metadata = mutable.Map(\n                  \"processed\" -> true,\n                  \"multiplier\" -> 2,\n                  \"processor\" -> \"enhanced\"\n                )\n              )\n\n            case v if v > 0 =>\n              ProcessedItem(\n                id = index,\n                originalValue = v,\n                transformedValue = v + threshold,\n                category = \"LOW\",\n                metadata = mutable.Map(\n                  \"processed\" -> true,\n                  \"adjusted\" -> true,\n                  \"processor\" -> \"basic\"\n                )\n              )\n\n            case _ => // skip negative values\n              null\n          }\n\n          if (processedItem != null) {\n            cache(cacheKey) = processedItem\n            processingLog += processedItem\n            results += processedItem\n          }\n      }\n    }\n\n    // Finalization logic\n    if (processedCount > 0) {\n      val average = results.map(_.transformedValue).sum.toDouble / results.size\n      println(f\"Processing complete. Average: $average%.2f\")\n\n      // Add processing statistics\n      results.foreach(_.metadata(\"processing_average\") = average)\n    }\n\n    results.toList\n  }\n\n  def analyzePatterns(items: List[ProcessedItem]): Map[String, Map[String, Any]] = {\n    val categoryGroups = items.groupBy(_.category)\n\n    // Pattern analysis logic - extractable middle chunk\n    val analysis = categoryGroups.map { case (category, categoryItems) =>\n      val values = categoryItems.map(_.transformedValue)\n      val categoryAnalysis = Map(\n        \"count\" -> categoryItems.size,\n        \"percentage\" -> (categoryItems.size.toDouble / items.size * 100),\n        \"avg_value\" -> (values.sum.toDouble / values.size),\n        \"min_value\" -> values.min,\n        \"max_value\" -> values.max\n      ) ++ {\n        // Time-based analysis\n        val currentTime = Instant.now()\n        val recentItems = categoryItems.filter { item =>\n          java.time.Duration.between(item.timestamp, currentTime).getSeconds < 60\n        }\n\n        if (recentItems.nonEmpty) {\n          val recentValues = recentItems.map(_.transformedValue)\n          Map(\n            \"recent_count\" -> recentItems.size,\n            \"recent_avg\" -> (recentValues.sum.toDouble / recentValues.size)\n          )\n        } else Map.empty\n      } ++ {\n        // High-value analysis\n        val highValueItems = categoryItems.filter(_.transformedValue > 1000)\n        if (highValueItems.nonEmpty) {\n          Map(\"high_value_count\" -> highValueItems.size)\n        } else Map.empty\n      }\n\n      category -> categoryAnalysis\n    }\n\n    analysis ++ Map(\n      \"total_items\" -> items.size,\n      \"processing_time\" -> Instant.now().toString\n    )\n  }\n}",
      "end_line": 129,
      "language": "scala",
      "name": "DataProcessor",
      "original_indentation": 0,
      "start_line": 15
    },
    {
      "chunk_type": "Function",
      "comment_ranges": [
        [
          154,
          209
        ],
        [
          1577,
          1600
        ],
        [
          1827,
          1848
        ],
        [
          2027,
          2055
        ]
      ],
      "content": "  def processComplexData(input: List[Int]): List[ProcessedItem] = {\n    val results = mutable.ListBuffer[ProcessedItem]()\n    var processedCount = 0\n\n    // Main processing algorithm - extractable middle chunk\n    input.zipWithIndex.foreach { case (value, index) =>\n      val cacheKey = s\"item_${index}_$value\"\n\n      cache.get(cacheKey) match {\n        case Some(cachedItem) =>\n          results += cachedItem\n        case None =>\n          val processedItem = value match {\n            case v if v > threshold =>\n              val transformedValue = v * 2\n              val category = if (transformedValue > threshold * 3) \"HIGH\" else \"MEDIUM\"\n              val bonusValue = if (transformedValue > 100) transformedValue + 10 else transformedValue\n\n              processedCount += 1\n              ProcessedItem(\n                id = index,\n                originalValue = v,\n                transformedValue = bonusValue,\n                category = category,\n                metadata = mutable.Map(\n                  \"processed\" -> true,\n                  \"multiplier\" -> 2,\n                  \"processor\" -> \"enhanced\"\n                )\n              )\n\n            case v if v > 0 =>\n              ProcessedItem(\n                id = index,\n                originalValue = v,\n                transformedValue = v + threshold,\n                category = \"LOW\",\n                metadata = mutable.Map(\n                  \"processed\" -> true,\n                  \"adjusted\" -> true,\n                  \"processor\" -> \"basic\"\n                )\n              )\n\n            case _ => // skip negative values\n              null\n          }\n\n          if (processedItem != null) {\n            cache(cacheKey) = processedItem\n            processingLog += processedItem\n            results += processedItem\n          }\n      }\n    }\n\n    // Finalization logic\n    if (processedCount > 0) {\n      val average = results.map(_.transformedValue).sum.toDouble / results.size\n      println(f\"Processing complete. Average: $average%.2f\")\n\n      // Add processing statistics\n      results.foreach(_.metadata(\"processing_average\") = average)\n    }\n\n    results.toList\n  }",
      "end_line": 85,
      "language": "scala",
      "name": "processComplexData",
      "original_indentation": 2,
      "start_line": 19
    },
    {
      "chunk_type": "FunctionCall",
      "comment_ranges": [
        [
          1367,
          1390
        ]
      ],
      "content": "    input.zipWithIndex.foreach { case (value, index) =>\n      val cacheKey = s\"item_${index}_$value\"\n\n      cache.get(cacheKey) match {\n        case Some(cachedItem) =>\n          results += cachedItem\n        case None =>\n          val processedItem = value match {\n            case v if v > threshold =>\n              val transformedValue = v * 2\n              val category = if (transformedValue > threshold * 3) \"HIGH\" else \"MEDIUM\"\n              val bonusValue = if (transformedValue > 100) transformedValue + 10 else transformedValue\n\n              processedCount += 1\n              ProcessedItem(\n                id = index,\n                originalValue = v,\n                transformedValue = bonusValue,\n                category = category,\n                metadata = mutable.Map(\n                  \"processed\" -> true,\n                  \"multiplier\" -> 2,\n                  \"processor\" -> \"enhanced\"\n                )\n              )\n\n            case v if v > 0 =>\n              ProcessedItem(\n                id = index,\n                originalValue = v,\n                transformedValue = v + threshold,\n                category = \"LOW\",\n                metadata = mutable.Map(\n                  \"processed\" -> true,\n                  \"adjusted\" -> true,\n                  \"processor\" -> \"basic\"\n                )\n              )\n\n            case _ => // skip negative values\n              null\n          }\n\n          if (processedItem != null) {\n            cache(cacheKey) = processedItem\n            processingLog += processedItem\n            results += processedItem\n          }\n      }\n    }",
      "end_line": 73,
      "language": "scala",
      "name": "function_call",
      "original_indentation": 4,
      "start_line": 24
    },
    {
      "chunk_type": "Conditional",
      "comment_ranges": [
        [
          1265,
          1288
        ]
      ],
      "content": "      cache.get(cacheKey) match {\n        case Some(cachedItem) =>\n          results += cachedItem\n        case None =>\n          val processedItem = value match {\n            case v if v > threshold =>\n              val transformedValue = v * 2\n              val category = if (transformedValue > threshold * 3) \"HIGH\" else \"MEDIUM\"\n              val bonusValue = if (transformedValue > 100) transformedValue + 10 else transformedValue\n\n              processedCount += 1\n              ProcessedItem(\n                id = index,\n                originalValue = v,\n                transformedValue = bonusValue,\n                category = category,\n                metadata = mutable.Map(\n                  \"processed\" -> true,\n                  \"multiplier\" -> 2,\n                  \"processor\" -> \"enhanced\"\n                )\n              )\n\n            case v if v > 0 =>\n              ProcessedItem(\n                id = index,\n                originalValue = v,\n                transformedValue = v + threshold,\n                category = \"LOW\",\n                metadata = mutable.Map(\n                  \"processed\" -> true,\n                  \"adjusted\" -> true,\n                  \"processor\" -> \"basic\"\n                )\n              )\n\n            case _ => // skip negative values\n              null\n          }\n\n          if (processedItem != null) {\n            cache(cacheKey) = processedItem\n            processingLog += processedItem\n            results += processedItem\n          }\n      }",
      "end_line": 72,
      "language": "scala",
      "name": "match_block",
      "original_indentation": 6,
      "start_line": 27
    },
    {
      "chunk_type": "Conditional",
      "comment_ranges": [
        [
          1145,
          1168
        ]
      ],
      "content": "          val processedItem = value match {\n            case v if v > threshold =>\n              val transformedValue = v * 2\n              val category = if (transformedValue > threshold * 3) \"HIGH\" else \"MEDIUM\"\n              val bonusValue = if (transformedValue > 100) transformedValue + 10 else transformedValue\n\n              processedCount += 1\n              ProcessedItem(\n                id = index,\n                originalValue = v,\n                transformedValue = bonusValue,\n                category = category,\n                metadata = mutable.Map(\n                  \"processed\" -> true,\n                  \"multiplier\" -> 2,\n                  \"processor\" -> \"enhanced\"\n                )\n              )\n\n            case v if v > 0 =>\n              ProcessedItem(\n                id = index,\n                originalValue = v,\n                transformedValue = v + threshold,\n                category = \"LOW\",\n                metadata = mutable.Map(\n                  \"processed\" -> true,\n                  \"adjusted\" -> true,\n                  \"processor\" -> \"basic\"\n                )\n              )\n\n            case _ => // skip negative values\n              null\n          }",
      "end_line": 65,
      "language": "scala",
      "name": "match_block",
      "original_indentation": 30,
      "start_line": 31
    },
    {
      "chunk_type": "FunctionCall",
      "comment_ranges": [],
      "content": "              ProcessedItem(\n                id = index,\n                originalValue = v,\n                transformedValue = bonusValue,\n                category = category,\n                metadata = mutable.Map(\n                  \"processed\" -> true,\n                  \"multiplier\" -> 2,\n                  \"processor\" -> \"enhanced\"\n                )\n              )",
      "end_line": 48,
      "language": "scala",
      "name": "function_call",
      "original_indentation": 14,
      "start_line": 38
    },
    {
      "chunk_type": "FunctionCall",
      "comment_ranges": [],
      "content": "                metadata = mutable.Map(\n                  \"processed\" -> true,\n                  \"multiplier\" -> 2,\n                  \"processor\" -> \"enhanced\"\n                )",
      "end_line": 47,
      "language": "scala",
      "name": "function_call",
      "original_indentation": 27,
      "start_line": 43
    },
    {
      "chunk_type": "FunctionCall",
      "comment_ranges": [],
      "content": "              ProcessedItem(\n                id = index,\n                originalValue = v,\n                transformedValue = v + threshold,\n                category = \"LOW\",\n                metadata = mutable.Map(\n                  \"processed\" -> true,\n                  \"adjusted\" -> true,\n                  \"processor\" -> \"basic\"\n                )\n              )",
      "end_line": 61,
      "language": "scala",
      "name": "function_call",
      "original_indentation": 14,
      "start_line": 51
    },
    {
      "chunk_type": "FunctionCall",
      "comment_ranges": [],
      "content": "                metadata = mutable.Map(\n                  \"processed\" -> true,\n                  \"adjusted\" -> true,\n                  \"processor\" -> \"basic\"\n                )",
      "end_line": 60,
      "language": "scala",
      "name": "function_call",
      "original_indentation": 27,
      "start_line": 56
    },
    {
      "chunk_type": "Conditional",
      "comment_ranges": [],
      "content": "          if (processedItem != null) {\n            cache(cacheKey) = processedItem\n            processingLog += processedItem\n            results += processedItem\n          }",
      "end_line": 71,
      "language": "scala",
      "name": "if_block",
      "original_indentation": 10,
      "start_line": 67
    },
    {
      "chunk_type": "Conditional",
      "comment_ranges": [
        [
          178,
          206
        ]
      ],
      "content": "    if (processedCount > 0) {\n      val average = results.map(_.transformedValue).sum.toDouble / results.size\n      println(f\"Processing complete. Average: $average%.2f\")\n\n      // Add processing statistics\n      results.foreach(_.metadata(\"processing_average\") = average)\n    }",
      "end_line": 82,
      "language": "scala",
      "name": "if_block",
      "original_indentation": 4,
      "start_line": 76
    },
    {
      "chunk_type": "Function",
      "comment_ranges": [
        [
          141,
          193
        ],
        [
          622,
          644
        ],
        [
          1133,
          1155
        ]
      ],
      "content": "  def analyzePatterns(items: List[ProcessedItem]): Map[String, Map[String, Any]] = {\n    val categoryGroups = items.groupBy(_.category)\n\n    // Pattern analysis logic - extractable middle chunk\n    val analysis = categoryGroups.map { case (category, categoryItems) =>\n      val values = categoryItems.map(_.transformedValue)\n      val categoryAnalysis = Map(\n        \"count\" -> categoryItems.size,\n        \"percentage\" -> (categoryItems.size.toDouble / items.size * 100),\n        \"avg_value\" -> (values.sum.toDouble / values.size),\n        \"min_value\" -> values.min,\n        \"max_value\" -> values.max\n      ) ++ {\n        // Time-based analysis\n        val currentTime = Instant.now()\n        val recentItems = categoryItems.filter { item =>\n          java.time.Duration.between(item.timestamp, currentTime).getSeconds < 60\n        }\n\n        if (recentItems.nonEmpty) {\n          val recentValues = recentItems.map(_.transformedValue)\n          Map(\n            \"recent_count\" -> recentItems.size,\n            \"recent_avg\" -> (recentValues.sum.toDouble / recentValues.size)\n          )\n        } else Map.empty\n      } ++ {\n        // High-value analysis\n        val highValueItems = categoryItems.filter(_.transformedValue > 1000)\n        if (highValueItems.nonEmpty) {\n          Map(\"high_value_count\" -> highValueItems.size)\n        } else Map.empty\n      }\n\n      category -> categoryAnalysis\n    }\n\n    analysis ++ Map(\n      \"total_items\" -> items.size,\n      \"processing_time\" -> Instant.now().toString\n    )\n  }",
      "end_line": 128,
      "language": "scala",
      "name": "analyzePatterns",
      "original_indentation": 2,
      "start_line": 87
    },
    {
      "chunk_type": "FunctionCall",
      "comment_ranges": [
        [
          428,
          450
        ],
        [
          939,
          961
        ]
      ],
      "content": "    val analysis = categoryGroups.map { case (category, categoryItems) =>\n      val values = categoryItems.map(_.transformedValue)\n      val categoryAnalysis = Map(\n        \"count\" -> categoryItems.size,\n        \"percentage\" -> (categoryItems.size.toDouble / items.size * 100),\n        \"avg_value\" -> (values.sum.toDouble / values.size),\n        \"min_value\" -> values.min,\n        \"max_value\" -> values.max\n      ) ++ {\n        // Time-based analysis\n        val currentTime = Instant.now()\n        val recentItems = categoryItems.filter { item =>\n          java.time.Duration.between(item.timestamp, currentTime).getSeconds < 60\n        }\n\n        if (recentItems.nonEmpty) {\n          val recentValues = recentItems.map(_.transformedValue)\n          Map(\n            \"recent_count\" -> recentItems.size,\n            \"recent_avg\" -> (recentValues.sum.toDouble / recentValues.size)\n          )\n        } else Map.empty\n      } ++ {\n        // High-value analysis\n        val highValueItems = categoryItems.filter(_.transformedValue > 1000)\n        if (highValueItems.nonEmpty) {\n          Map(\"high_value_count\" -> highValueItems.size)\n        } else Map.empty\n      }\n\n      category -> categoryAnalysis\n    }",
      "end_line": 122,
      "language": "scala",
      "name": "function_call",
      "original_indentation": 19,
      "start_line": 91
    },
    {
      "chunk_type": "FunctionCall",
      "comment_ranges": [],
      "content": "      val categoryAnalysis = Map(\n        \"count\" -> categoryItems.size,\n        \"percentage\" -> (categoryItems.size.toDouble / items.size * 100),\n        \"avg_value\" -> (values.sum.toDouble / values.size),\n        \"min_value\" -> values.min,\n        \"max_value\" -> values.max\n      )",
      "end_line": 99,
      "language": "scala",
      "name": "function_call",
      "original_indentation": 29,
      "start_line": 93
    },
    {
      "chunk_type": "CodeBlock",
      "comment_ranges": [
        [
          21,
          43
        ]
      ],
      "content": "      ) ++ {\n        // Time-based analysis\n        val currentTime = Instant.now()\n        val recentItems = categoryItems.filter { item =>\n          java.time.Duration.between(item.timestamp, currentTime).getSeconds < 60\n        }\n\n        if (recentItems.nonEmpty) {\n          val recentValues = recentItems.map(_.transformedValue)\n          Map(\n            \"recent_count\" -> recentItems.size,\n            \"recent_avg\" -> (recentValues.sum.toDouble / recentValues.size)\n          )\n        } else Map.empty\n      }",
      "end_line": 113,
      "language": "scala",
      "name": "code_block",
      "original_indentation": 11,
      "start_line": 99
    },
    {
      "chunk_type": "Lambda",
      "comment_ranges": [],
      "content": "        val recentItems = categoryItems.filter { item =>\n          java.time.Duration.between(item.timestamp, currentTime).getSeconds < 60\n        ",
      "end_line": 104,
      "language": "scala",
      "name": "lambda",
      "original_indentation": 49,
      "start_line": 102
    },
    {
      "chunk_type": "Conditional",
      "comment_ranges": [],
      "content": "        if (recentItems.nonEmpty) {\n          val recentValues = recentItems.map(_.transformedValue)\n          Map(\n            \"recent_count\" -> recentItems.size,\n            \"recent_avg\" -> (recentValues.sum.toDouble / recentValues.size)\n          )\n        } else Map.empty",
      "end_line": 112,
      "language": "scala",
      "name": "if_block",
      "original_indentation": 8,
      "start_line": 106
    },
    {
      "chunk_type": "FunctionCall",
      "comment_ranges": [],
      "content": "          Map(\n            \"recent_count\" -> recentItems.size,\n            \"recent_avg\" -> (recentValues.sum.toDouble / recentValues.size)\n          )",
      "end_line": 111,
      "language": "scala",
      "name": "function_call",
      "original_indentation": 10,
      "start_line": 108
    },
    {
      "chunk_type": "CodeBlock",
      "comment_ranges": [
        [
          21,
          43
        ]
      ],
      "content": "      } ++ {\n        // High-value analysis\n        val highValueItems = categoryItems.filter(_.transformedValue > 1000)\n        if (highValueItems.nonEmpty) {\n          Map(\"high_value_count\" -> highValueItems.size)\n        } else Map.empty\n      }",
      "end_line": 119,
      "language": "scala",
      "name": "code_block",
      "original_indentation": 11,
      "start_line": 113
    },
    {
      "chunk_type": "Conditional",
      "comment_ranges": [],
      "content": "        if (highValueItems.nonEmpty) {\n          Map(\"high_value_count\" -> highValueItems.size)\n        } else Map.empty",
      "end_line": 118,
      "language": "scala",
      "name": "if_block",
      "original_indentation": 8,
      "start_line": 116
    },
    {
      "chunk_type": "FunctionCall",
      "comment_ranges": [],
      "content": "    analysis ++ Map(\n      \"total_items\" -> items.size,\n      \"processing_time\" -> Instant.now().toString\n    )",
      "end_line": 127,
      "language": "scala",
      "name": "function_call",
      "original_indentation": 16,
      "start_line": 124
    },
    {
      "chunk_type": "Class",
      "comment_ranges": [
        [
          110,
          166
        ],
        [
          510,
          557
        ],
        [
          773,
          812
        ]
      ],
      "content": "object DataProcessor {\n  def createProcessor(threshold: Int): DataProcessor = new DataProcessor(threshold)\n\n  // Complex transformation function with pattern matching\n  def complexTransform(item: ProcessedItem): ProcessedItem = {\n    val newValue = item.category match {\n      case \"HIGH\" => item.transformedValue * 2\n      case \"MEDIUM\" => item.transformedValue + 50\n      case \"LOW\" => item.transformedValue + 10\n      case _ => item.transformedValue\n    }\n\n    item.copy(transformedValue = newValue)\n  }\n\n  // Functional approach to filtering and sorting\n  def filterAndSort(items: List[ProcessedItem], targetCategory: String): List[ProcessedItem] = {\n    items\n      .filter(_.category == targetCategory)\n      .sortBy(_.transformedValue)(Ordering[Int].reverse)\n  }\n\n  // Batch processing with error handling\n  def batchProcess(batches: List[List[Int]], threshold: Int): List[Try[List[ProcessedItem]]] = {\n    batches.map { batch =>\n      Try {\n        val processor = new DataProcessor(threshold)\n        processor.processComplexData(batch)\n      }\n    }\n  }\n}",
      "end_line": 163,
      "language": "scala",
      "name": "DataProcessor",
      "original_indentation": 0,
      "start_line": 132
    },
    {
      "chunk_type": "Function",
      "comment_ranges": [],
      "content": "  def createProcessor(threshold: Int): DataProcessor = new DataProcessor(threshold)",
      "end_line": 133,
      "language": "scala",
      "name": "createProcessor",
      "original_indentation": 2,
      "start_line": 133
    },
    {
      "chunk_type": "Function",
      "comment_ranges": [],
      "content": "  def complexTransform(item: ProcessedItem): ProcessedItem = {\n    val newValue = item.category match {\n      case \"HIGH\" => item.transformedValue * 2\n      case \"MEDIUM\" => item.transformedValue + 50\n      case \"LOW\" => item.transformedValue + 10\n      case _ => item.transformedValue\n    }\n\n    item.copy(transformedValue = newValue)\n  }",
      "end_line": 145,
      "language": "scala",
      "name": "complexTransform",
      "original_indentation": 2,
      "start_line": 136
    },
    {
      "chunk_type": "Conditional",
      "comment_ranges": [],
      "content": "    val newValue = item.category match {\n      case \"HIGH\" => item.transformedValue * 2\n      case \"MEDIUM\" => item.transformedValue + 50\n      case \"LOW\" => item.transformedValue + 10\n      case _ => item.transformedValue\n    }",
      "end_line": 142,
      "language": "scala",
      "name": "match_block",
      "original_indentation": 19,
      "start_line": 137
    },
    {
      "chunk_type": "Function",
      "comment_ranges": [],
      "content": "  def filterAndSort(items: List[ProcessedItem], targetCategory: String): List[ProcessedItem] = {\n    items\n      .filter(_.category == targetCategory)\n      .sortBy(_.transformedValue)(Ordering[Int].reverse)\n  }",
      "end_line": 152,
      "language": "scala",
      "name": "filterAndSort",
      "original_indentation": 2,
      "start_line": 148
    },
    {
      "chunk_type": "FunctionCall",
      "comment_ranges": [],
      "content": "    items\n      .filter(_.category == targetCategory)",
      "end_line": 150,
      "language": "scala",
      "name": "function_call",
      "original_indentation": 4,
      "start_line": 149
    },
    {
      "chunk_type": "FunctionCall",
      "comment_ranges": [],
      "content": "    items\n      .filter(_.category == targetCategory)\n      .sortBy(_.transformedValue)",
      "end_line": 151,
      "language": "scala",
      "name": "function_call",
      "original_indentation": 4,
      "start_line": 149
    },
    {
      "chunk_type": "Function",
      "comment_ranges": [],
      "content": "  def batchProcess(batches: List[List[Int]], threshold: Int): List[Try[List[ProcessedItem]]] = {\n    batches.map { batch =>\n      Try {\n        val processor = new DataProcessor(threshold)\n        processor.processComplexData(batch)\n      }\n    }\n  }",
      "end_line": 162,
      "language": "scala",
      "name": "batchProcess",
      "original_indentation": 2,
      "start_line": 155
    },
    {
      "chunk_type": "Lambda",
      "comment_ranges": [],
      "content": "    batches.map { batch =>\n      Try {\n        val processor = new DataProcessor(threshold)\n        processor.processComplexData(batch)\n      }\n    ",
      "end_line": 161,
      "language": "scala",
      "name": "lambda",
      "original_indentation": 18,
      "start_line": 156
    },
    {
      "chunk_type": "FunctionCall",
      "comment_ranges": [],
      "content": "      Try {\n        val processor = new DataProcessor(threshold)\n        processor.processComplexData(batch)\n      }",
      "end_line": 160,
      "language": "scala",
      "name": "function_call",
      "original_indentation": 6,
      "start_line": 157
    }
  ],
  "source_code": "\nimport scala.collection.mutable\nimport scala.util.{Success, Failure, Try}\nimport java.time.Instant\n\ncase class ProcessedItem(\n  id: Int,\n  originalValue: Int,\n  transformedValue: Int,\n  category: String,\n  timestamp: Instant = Instant.now(),\n  metadata: mutable.Map[String, Any] = mutable.Map.empty\n)\n\nclass DataProcessor(threshold: Int) {\n  private val cache = mutable.Map[String, ProcessedItem]()\n  private val processingLog = mutable.ListBuffer[ProcessedItem]()\n\n  def processComplexData(input: List[Int]): List[ProcessedItem] = {\n    val results = mutable.ListBuffer[ProcessedItem]()\n    var processedCount = 0\n\n    // Main processing algorithm - extractable middle chunk\n    input.zipWithIndex.foreach { case (value, index) =>\n      val cacheKey = s\"item_${index}_$value\"\n\n      cache.get(cacheKey) match {\n        case Some(cachedItem) =>\n          results += cachedItem\n        case None =>\n          val processedItem = value match {\n            case v if v > threshold =>\n              val transformedValue = v * 2\n              val category = if (transformedValue > threshold * 3) \"HIGH\" else \"MEDIUM\"\n              val bonusValue = if (transformedValue > 100) transformedValue + 10 else transformedValue\n\n              processedCount += 1\n              ProcessedItem(\n                id = index,\n                originalValue = v,\n                transformedValue = bonusValue,\n                category = category,\n                metadata = mutable.Map(\n                  \"processed\" -> true,\n                  \"multiplier\" -> 2,\n                  \"processor\" -> \"enhanced\"\n                )\n              )\n\n            case v if v > 0 =>\n              ProcessedItem(\n                id = index,\n                originalValue = v,\n                transformedValue = v + threshold,\n                category = \"LOW\",\n                metadata = mutable.Map(\n                  \"processed\" -> true,\n                  \"adjusted\" -> true,\n                  \"processor\" -> \"basic\"\n                )\n              )\n\n            case _ => // skip negative values\n              null\n          }\n\n          if (processedItem != null) {\n            cache(cacheKey) = processedItem\n            processingLog += processedItem\n            results += processedItem\n          }\n      }\n    }\n\n    // Finalization logic\n    if (processedCount > 0) {\n      val average = results.map(_.transformedValue).sum.toDouble / results.size\n      println(f\"Processing complete. Average: $average%.2f\")\n\n      // Add processing statistics\n      results.foreach(_.metadata(\"processing_average\") = average)\n    }\n\n    results.toList\n  }\n\n  def analyzePatterns(items: List[ProcessedItem]): Map[String, Map[String, Any]] = {\n    val categoryGroups = items.groupBy(_.category)\n\n    // Pattern analysis logic - extractable middle chunk\n    val analysis = categoryGroups.map { case (category, categoryItems) =>\n      val values = categoryItems.map(_.transformedValue)\n      val categoryAnalysis = Map(\n        \"count\" -> categoryItems.size,\n        \"percentage\" -> (categoryItems.size.toDouble / items.size * 100),\n        \"avg_value\" -> (values.sum.toDouble / values.size),\n        \"min_value\" -> values.min,\n        \"max_value\" -> values.max\n      ) ++ {\n        // Time-based analysis\n        val currentTime = Instant.now()\n        val recentItems = categoryItems.filter { item =>\n          java.time.Duration.between(item.timestamp, currentTime).getSeconds < 60\n        }\n\n        if (recentItems.nonEmpty) {\n          val recentValues = recentItems.map(_.transformedValue)\n          Map(\n            \"recent_count\" -> recentItems.size,\n            \"recent_avg\" -> (recentValues.sum.toDouble / recentValues.size)\n          )\n        } else Map.empty\n      } ++ {\n        // High-value analysis\n        val highValueItems = categoryItems.filter(_.transformedValue > 1000)\n        if (highValueItems.nonEmpty) {\n          Map(\"high_value_count\" -> highValueItems.size)\n        } else Map.empty\n      }\n\n      category -> categoryAnalysis\n    }\n\n    analysis ++ Map(\n      \"total_items\" -> items.size,\n      \"processing_time\" -> Instant.now().toString\n    )\n  }\n}\n\n// Companion object with utility functions\nobject DataProcessor {\n  def createProcessor(threshold: Int): DataProcessor = new DataProcessor(threshold)\n\n  // Complex transformation function with pattern matching\n  def complexTransform(item: ProcessedItem): ProcessedItem = {\n    val newValue = item.category match {\n      case \"HIGH\" => item.transformedValue * 2\n      case \"MEDIUM\" => item.transformedValue + 50\n      case \"LOW\" => item.transformedValue + 10\n      case _ => item.transformedValue\n    }\n\n    item.copy(transformedValue = newValue)\n  }\n\n  // Functional approach to filtering and sorting\n  def filterAndSort(items: List[ProcessedItem], targetCategory: String): List[ProcessedItem] = {\n    items\n      .filter(_.category == targetCategory)\n      .sortBy(_.transformedValue)(Ordering[Int].reverse)\n  }\n\n  // Batch processing with error handling\n  def batchProcess(batches: List[List[Int]], threshold: Int): List[Try[List[ProcessedItem]]] = {\n    batches.map { batch =>\n      Try {\n        val processor = new DataProcessor(threshold)\n        processor.processComplexData(batch)\n      }\n    }\n  }\n}\n",
  "test_name": "test_scala_complex_algorithm_extraction",
  "total_chunks": 33
}
