---
source: tests/unit/domain/services/challenge_generator/challenge_generator_tests.rs
expression: json_string
---
{
  "challenges": [
    {
      "code_content": "/*\n * Complex Rust file with various comment patterns\n * This file tests comment range detection and code parsing\n * It includes multiple comment styles and edge cases\n */\n\n/// This is a documentation comment for the module\n/// It spans multiple lines and contains examples:\n///\n/// ```rust\n/// let example = ComplexStruct::new();\n/// example.process_data(&data);\n/// ```\n///\n/// # Safety\n///\n/// This module contains unsafe code blocks for performance reasons.\n/// Users should be careful when calling these functions.\n\nuse std::collections::{HashMap, BTreeMap}; // Standard collections\nuse std::sync::{Arc, Mutex}; /* Thread-safe primitives */\nuse std::time::{Duration, Instant}; // Time utilities\n/* Multi-line import comment\n   with detailed explanations */\nuse std::thread;",
      "comment_ranges": [
        [
          0,
          171
        ],
        [
          173,
          224
        ],
        [
          224,
          275
        ],
        [
          275,
          279
        ],
        [
          279,
          291
        ],
        [
          291,
          331
        ],
        [
          331,
          364
        ],
        [
          364,
          372
        ],
        [
          372,
          376
        ],
        [
          376,
          389
        ],
        [
          389,
          393
        ],
        [
          393,
          462
        ],
        [
          462,
          520
        ],
        [
          564,
          587
        ],
        [
          617,
          645
        ],
        [
          682,
          699
        ],
        [
          700,
          761
        ]
      ],
      "content_length": 778,
      "difficulty": "Some(Normal)",
      "end_line": 26,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 1
    },
    {
      "code_content": "/*\n * Complex Rust file with various comment patterns\n * This file tests comment range detection and code parsing\n * It includes multiple comment styles and edge cases\n */\n\n/// This is a documentation comment for the module\n/// It spans multiple lines and contains examples:\n///\n/// ```rust\n/// let example = ComplexStruct::new();\n/// example.process_data(&data);\n/// ```\n///\n/// # Safety\n///\n/// This module contains unsafe code blocks for performance reasons.\n/// Users should be careful when calling these functions.\n\nuse std::collections::{HashMap, BTreeMap}; // Standard collections\nuse std::sync::{Arc, Mutex}; /* Thread-safe primitives */\nuse std::time::{Duration, Instant}; // Time utilities\n/* Multi-line import comment\n   with detailed explanations */\nuse std::thread;\n\n// Constants with inline comments\nconst MAX_BUFFER_SIZE: usize = 1024 * 1024; // 1MB buffer\nconst DEFAULT_TIMEOUT: u64 = 30; /* 30 seconds default timeout\n                                    can be overridden by configuration */\nconst VERSION: &str = \"1.0.0\"; // Application version\n\n/// Configuration structure with extensive documentation\n///\n/// This struct holds all configuration parameters for the application.\n/// Each field has specific constraints and default values.\n///\n/// # Examples\n///\n/// ```rust\n/// let config = Config {\n///     max_connections: 100,\n///     timeout: Duration::from_secs(30),\n///     ..Default::default()\n/// };\n/// ```\n#[derive(Debug, Clone)]\npub struct Config {\n    /// Maximum number of concurrent connections\n    /// Must be between 1 and 10000\n    pub max_connections: usize,\n\n    /* Timeout for network operations\n       Set to 0 for no timeout */\n    pub timeout: Duration,\n\n    // Enable debug logging\n    pub debug_mode: bool, /* This affects performance\n                             only enable for development */\n\n    /// Custom headers for HTTP requests\n    pub headers: HashMap<String, String>, // Key-value pairs\n}\n\nimpl Default for Config {\n    /// Creates a default configuration\n    ///\n    /// All values are set to safe defaults that work\n    /// in most environments.\n    fn default() -> Self {\n        Self {\n            max_connections: 10, // Conservative default\n            timeout: Duration::from_secs(DEFAULT_TIMEOUT),\n            debug_mode: false, /* Disabled by default for performance */\n            headers: HashMap::new(), // Empty headers\n        }\n    }\n}",
      "comment_ranges": [
        [
          0,
          171
        ],
        [
          173,
          224
        ],
        [
          224,
          275
        ],
        [
          275,
          279
        ],
        [
          279,
          291
        ],
        [
          291,
          331
        ],
        [
          331,
          364
        ],
        [
          364,
          372
        ],
        [
          372,
          376
        ],
        [
          376,
          389
        ],
        [
          389,
          393
        ],
        [
          393,
          462
        ],
        [
          462,
          520
        ],
        [
          564,
          587
        ],
        [
          617,
          645
        ],
        [
          682,
          699
        ],
        [
          700,
          761
        ],
        [
          780,
          813
        ],
        [
          858,
          871
        ],
        [
          905,
          1008
        ],
        [
          1040,
          1062
        ],
        [
          1064,
          1121
        ],
        [
          1121,
          1125
        ],
        [
          1125,
          1197
        ],
        [
          1197,
          1257
        ],
        [
          1257,
          1261
        ],
        [
          1261,
          1276
        ],
        [
          1276,
          1280
        ],
        [
          1280,
          1292
        ],
        [
          1292,
          1318
        ],
        [
          1318,
          1348
        ],
        [
          1348,
          1390
        ],
        [
          1390,
          1419
        ],
        [
          1419,
          1426
        ],
        [
          1426,
          1434
        ],
        [
          1482,
          1527
        ],
        [
          1531,
          1563
        ],
        [
          1600,
          1667
        ],
        [
          1700,
          1723
        ],
        [
          1750,
          1837
        ],
        [
          1843,
          1880
        ],
        [
          1922,
          1940
        ],
        [
          1974,
          2010
        ],
        [
          2014,
          2018
        ],
        [
          2022,
          2072
        ],
        [
          2076,
          2102
        ],
        [
          2177,
          2200
        ],
        [
          2291,
          2332
        ],
        [
          2370,
          2386
        ]
      ],
      "content_length": 2404,
      "difficulty": "Some(Hard)",
      "end_line": 79,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 1
    },
    {
      "code_content": "/*\n * Complex Rust file with various comment patterns\n * This file tests comment range detection and code parsing\n * It includes multiple comment styles and edge cases\n */\n\n/// This is a documentation comment for the module\n/// It spans multiple lines and contains examples:\n///\n/// ```rust\n/// let example = ComplexStruct::new();\n/// example.process_data(&data);\n/// ```\n///\n/// # Safety\n///\n/// This module contains unsafe code blocks for performance reasons.\n/// Users should be careful when calling these functions.\n\nuse std::collections::{HashMap, BTreeMap}; // Standard collections\nuse std::sync::{Arc, Mutex}; /* Thread-safe primitives */\nuse std::time::{Duration, Instant}; // Time utilities\n/* Multi-line import comment\n   with detailed explanations */\nuse std::thread;\n\n// Constants with inline comments\nconst MAX_BUFFER_SIZE: usize = 1024 * 1024; // 1MB buffer\nconst DEFAULT_TIMEOUT: u64 = 30; /* 30 seconds default timeout\n                                    can be overridden by configuration */\nconst VERSION: &str = \"1.0.0\"; // Application version\n\n/// Configuration structure with extensive documentation\n///\n/// This struct holds all configuration parameters for the application.\n/// Each field has specific constraints and default values.\n///\n/// # Examples\n///\n/// ```rust\n/// let config = Config {\n///     max_connections: 100,\n///     timeout: Duration::from_secs(30),\n///     ..Default::default()\n/// };\n/// ```\n#[derive(Debug, Clone)]\npub struct Config {\n    /// Maximum number of concurrent connections\n    /// Must be between 1 and 10000\n    pub max_connections: usize,\n\n    /* Timeout for network operations\n       Set to 0 for no timeout */\n    pub timeout: Duration,\n\n    // Enable debug logging\n    pub debug_mode: bool, /* This affects performance\n                             only enable for development */\n\n    /// Custom headers for HTTP requests\n    pub headers: HashMap<String, String>, // Key-value pairs\n}\n\nimpl Default for Config {\n    /// Creates a default configuration\n    ///\n    /// All values are set to safe defaults that work\n    /// in most environments.\n    fn default() -> Self {\n        Self {\n            max_connections: 10, // Conservative default\n            timeout: Duration::from_secs(DEFAULT_TIMEOUT),\n            debug_mode: false, /* Disabled by default for performance */\n            headers: HashMap::new(), // Empty headers\n        }\n    }\n}\n\n/**\n * Error enumeration with various patterns\n *\n * This enum covers all possible error conditions\n * that can occur in the application.\n */\n#[derive(Debug, Clone, PartialEq)]\npub enum AppError {\n    /// Network connectivity issues\n    NetworkError {\n        code: u16,              // HTTP status code\n        message: String,        /* Error message from server */\n        retry_after: Option<u64>, // Seconds to wait before retry\n    },\n\n    /* Configuration validation errors */\n    ConfigError(String), // Error message\n\n    // Timeout occurred during operation\n    TimeoutError, /* No additional data needed */\n\n    /// Parse errors with location information\n    ParseError {\n        line: usize,    // Line number where error occurred\n        column: usize,  /* Column position */\n        details: String, // Detailed error description\n    },\n}\n\nimpl std::fmt::Display for AppError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            // Simple error formatting\n            AppError::NetworkError { code, message, .. } => {\n                write!(f, \"Network error {}: {}\", code, message)\n            },\n            AppError::ConfigError(msg) => write!(f, \"Config error: {}\", msg),\n            AppError::TimeoutError => write!(f, \"Operation timed out\"),\n            /* Complex error with location info */\n            AppError::ParseError { line, column, details } => {\n                write!(f, \"Parse error at {}:{}: {}\", line, column, details)\n            },\n        }\n    }\n}\n\n/* Implementation of std::error::Error trait\n   Required for proper error handling */\nimpl std::error::Error for AppError {}\n\n/// Data processing pipeline with complex logic\n///\n/// This struct implements a multi-stage data processing pipeline\n/// with support for parallel execution and error recovery.\n///\n/// # Type Parameters\n///\n/// * `T` - The input data type\n/// * `R` - The output result type\n///\n/// # Examples\n///\n/// ```rust\n/// let mut pipeline = ProcessingPipeline::new();\n/// pipeline.add_stage(Box::new(|data| data.to_uppercase()));\n/// let result = pipeline.process(\"hello world\").await?;\n/// assert_eq!(result, \"HELLO WORLD\");\n/// ```\npub struct ProcessingPipeline<T, R> {\n    // Vector of processing stages\n    stages: Vec<Box<dyn Fn(T) -> Result<T, AppError> + Send + Sync>>,\n\n    /// Maximum number of concurrent operations\n    max_concurrency: usize, /* Limited to prevent resource exhaustion */\n\n    // Statistics and metrics\n    metrics: Arc<Mutex<PipelineMetrics>>, /* Thread-safe metrics collection */\n\n    /// Configuration for the pipeline\n    config: Config, // Reuse the config struct\n}\n\n/// Metrics collected during pipeline execution\n///\n/// These metrics help monitor performance and identify bottlenecks.\n#[derive(Debug, Default, Clone)]\npub struct PipelineMetrics {\n    /// Total number of items processed\n    total_processed: u64, // Counter\n\n    /* Number of failed operations */\n    total_failed: u64,\n\n    // Average processing time per item\n    avg_processing_time: Duration, /* Calculated automatically */\n\n    /// Peak memory usage during processing\n    peak_memory_usage: usize, // Bytes\n}\n\nimpl<T, R> ProcessingPipeline<T, R>\nwhere\n    T: Send + Sync + Clone + 'static,\n    R: Send + Sync + 'static,\n{\n    /// Creates a new processing pipeline\n    ///\n    /// # Arguments\n    ///\n    /// * `max_concurrency` - Maximum parallel operations\n    ///\n    /// # Returns\n    ///\n    /// A new pipeline instance ready for configuration\n    pub fn new(max_concurrency: usize) -> Self {\n        Self {\n            stages: Vec::new(), // Empty initially\n            max_concurrency, /* Store the limit */\n            metrics: Arc::new(Mutex::new(PipelineMetrics::default())),\n            config: Config::default(), // Use default configuration\n        }\n    }\n\n    /// Adds a processing stage to the pipeline\n    ///\n    /// Stages are executed in the order they are added.\n    /// Each stage receives the output of the previous stage.\n    ///\n    /// # Arguments\n    ///\n    /// * `stage` - A function that processes data\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// pipeline.add_stage(Box::new(|data: String| {\n    ///     Ok(data.trim().to_string())\n    /// }));\n    /// ```\n    pub fn add_stage<F>(&mut self, stage: F)\n    where\n        F: Fn(T) -> Result<T, AppError> + Send + Sync + 'static\n    {\n        self.stages.push(Box::new(stage)); // Box the closure\n    }\n\n    /**\n     * Processes data through all stages\n     *\n     * This method executes all configured stages in sequence,\n     * passing the output of each stage to the next.\n     *\n     * @param data The input data to process\n     * @return The processed result or an error\n     */\n    pub async fn process(&self, mut data: T) -> Result<T, AppError> {\n        let start_time = Instant::now(); // Track processing time\n\n        // Process through each stage\n        for (index, stage) in self.stages.iter().enumerate() {\n            match stage(data.clone()) {\n                Ok(result) => {\n                    data = result; // Update for next stage\n                },\n                Err(e) => {\n                    /* Log the error with stage information */\n                    eprintln!(\"Stage {} failed: {}\", index, e);\n\n                    // Update failure metrics\n                    if let Ok(mut metrics) = self.metrics.lock() {\n                        metrics.total_failed += 1;\n                    }\n\n                    return Err(e); // Propagate the error\n                },\n            }\n        }\n\n        // Update success metrics\n        let processing_time = start_time.elapsed();\n        if let Ok(mut metrics) = self.metrics.lock() {\n            metrics.total_processed += 1; /* Increment counter */\n\n            // Update average processing time\n            let total_items = metrics.total_processed + metrics.total_failed;\n            if total_items > 0 {\n                let total_time = metrics.avg_processing_time * (total_items - 1) as u32\n                    + processing_time;\n                metrics.avg_processing_time = total_time / total_items as u32;\n            }\n        }\n\n        Ok(data) // Return processed result\n    }\n\n    /// Processes multiple items in parallel\n    ///\n    /// This method takes advantage of multiple CPU cores\n    /// to process data items concurrently.\n    ///\n    /// # Arguments\n    ///\n    /// * `items` - Vector of items to process\n    ///\n    /// # Returns\n    ///\n    /// Vector of results in the same order as input\n    ///\n    /// # Performance Notes\n    ///\n    /// The actual concurrency is limited by `max_concurrency`\n    /// to prevent resource exhaustion.\n    pub async fn process_batch(&self, items: Vec<T>) -> Vec<Result<T, AppError>> {\n        use std::sync::atomic::{AtomicUsize, Ordering};\n\n        let results = Arc::new(Mutex::new(Vec::with_capacity(items.len())));\n        let completed = Arc::new(AtomicUsize::new(0));\n        let total_items = items.len();\n\n        /* Process items in chunks to limit concurrency */\n        let chunk_size = (total_items / self.max_concurrency).max(1);\n        let chunks: Vec<_> = items.chunks(chunk_size).collect();\n\n        // Spawn tasks for each chunk\n        let mut handles = Vec::new();\n\n        for (chunk_index, chunk) in chunks.into_iter().enumerate() {\n            let chunk_data = chunk.to_vec(); // Clone the chunk\n            let pipeline_stages = self.stages.clone(); /* Can't clone directly */\n            let results_ref = Arc::clone(&results);\n            let completed_ref = Arc::clone(&completed);\n\n            let handle = tokio::spawn(async move {\n                let mut chunk_results = Vec::new();\n\n                // Process each item in the chunk\n                for item in chunk_data {\n                    let mut current_data = item;\n                    let mut success = true;\n\n                    /* Execute all stages for this item */\n                    for (stage_index, _stage) in pipeline_stages.iter().enumerate() {\n                        // Note: Can't actually call the stage here due to borrow checker\n                        // This is a simplified example\n\n                        /* Simulate stage processing\n                           In real implementation, we'd need a different approach */\n                        if stage_index % 7 == 0 && chunk_index % 3 == 0 {\n                            // Simulate occasional failures\n                            chunk_results.push(Err(AppError::TimeoutError));\n                            success = false;\n                            break;\n                        }\n                    }\n\n                    if success {\n                        chunk_results.push(Ok(current_data)); // Success case\n                    }\n                }\n\n                // Store results\n                {\n                    let mut results_guard = results_ref.lock().unwrap();\n                    results_guard.extend(chunk_results);\n                }\n\n                // Update completion counter\n                completed_ref.fetch_add(chunk_data.len(), Ordering::Relaxed);\n            });\n\n            handles.push(handle);\n        }\n\n        // Wait for all chunks to complete\n        for handle in handles {\n            let _ = handle.await; /* Ignore join errors for simplicity */\n        }\n\n        // Extract and return results\n        let results_guard = results.lock().unwrap();\n        results_guard.clone() // Return the collected results\n    }\n\n    /// Gets current pipeline metrics\n    ///\n    /// Returns a snapshot of the current performance metrics.\n    /// This data can be used for monitoring and optimization.\n    pub fn get_metrics(&self) -> PipelineMetrics {\n        self.metrics.lock().unwrap().clone() // Return a copy\n    }\n\n    /**\n     * Resets all metrics to their initial state\n     *\n     * This is useful for starting fresh measurements\n     * or clearing historical data.\n     */\n    pub fn reset_metrics(&self) {\n        let mut metrics = self.metrics.lock().unwrap();\n        *metrics = PipelineMetrics::default(); /* Reset to defaults */\n    }\n}\n\n/// Unsafe operations for performance-critical code\n///\n/// This module contains unsafe operations that bypass\n/// Rust's safety checks for maximum performance.\n///\n/// # Safety\n///\n/// All functions in this module require careful review\n/// and should only be used when performance is critical.\npub mod unsafe_operations {\n    use super::*;\n\n    /// Raw memory manipulation for zero-copy operations\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure that:\n    /// - The pointer is valid and properly aligned\n    /// - The data lives at least as long as the operation\n    /// - No other code modifies the memory concurrently\n    ///\n    /// # Arguments\n    ///\n    /// * `ptr` - Raw pointer to data\n    /// * `len` - Length of data in bytes\n    ///\n    /// # Returns\n    ///\n    /// Checksum of the data\n    pub unsafe fn fast_checksum(ptr: *const u8, len: usize) -> u32 {\n        let mut checksum = 0u32; // Initialize accumulator\n        let mut i = 0;\n\n        /* Process 4 bytes at a time for efficiency */\n        while i + 4 <= len {\n            let chunk = ptr.add(i) as *const u32;\n            checksum = checksum.wrapping_add(*chunk); // Add without overflow check\n            i += 4; // Move to next chunk\n        }\n\n        // Handle remaining bytes\n        while i < len {\n            let byte = *ptr.add(i); /* Read single byte */\n            checksum = checksum.wrapping_add(byte as u32);\n            i += 1; // Next byte\n        }\n\n        checksum // Return final result\n    }\n\n    /// Direct memory copy without bounds checking\n    ///\n    /// This function performs a raw memory copy operation\n    /// without any safety checks for maximum speed.\n    ///\n    /// # Safety\n    ///\n    /// Extremely dangerous! The caller must guarantee:\n    /// - Both pointers are valid and non-null\n    /// - Source and destination don't overlap\n    /// - Both regions have at least `len` bytes\n    /// - Proper alignment for the data type\n    ///\n    /// # Performance\n    ///\n    /// This is faster than `std::ptr::copy` because it\n    /// skips all safety checks and uses optimized assembly.\n    pub unsafe fn raw_copy(src: *const u8, dst: *mut u8, len: usize) {\n        // Use platform-specific optimized copy\n        #[cfg(target_arch = \"x86_64\")]\n        {\n            /* x86_64 optimized version using SIMD instructions */\n            let mut i = 0;\n\n            // Process 32 bytes at a time with AVX if available\n            while i + 32 <= len {\n                let src_chunk = src.add(i) as *const [u8; 32];\n                let dst_chunk = dst.add(i) as *mut [u8; 32];\n                *dst_chunk = *src_chunk; // Bulk copy\n                i += 32;\n            }\n\n            // Handle remaining bytes\n            while i < len {\n                *dst.add(i) = *src.add(i); /* Byte-by-byte copy */\n                i += 1;\n            }\n        }\n\n        #[cfg(not(target_arch = \"x86_64\"))]\n        {\n            // Generic fallback for other architectures\n            std::ptr::copy_nonoverlapping(src, dst, len);\n        }\n    }\n\n    /**\n     * Lock-free atomic operations for high-performance counters\n     *\n     * This structure provides thread-safe counters without\n     * the overhead of mutex locking.\n     */\n    pub struct LockFreeCounter {\n        value: std::sync::atomic::AtomicU64, // Atomic counter\n    }\n\n    impl LockFreeCounter {\n        /// Creates a new counter starting at zero\n        pub fn new() -> Self {\n            Self {\n                value: std::sync::atomic::AtomicU64::new(0),\n            }\n        }\n\n        /// Increments the counter and returns the previous value\n        ///\n        /// This operation is atomic and lock-free.\n        pub fn increment(&self) -> u64 {\n            self.value.fetch_add(1, std::sync::atomic::Ordering::Relaxed)\n        }\n\n        /* Gets the current counter value */\n        pub fn get(&self) -> u64 {\n            self.value.load(std::sync::atomic::Ordering::Relaxed)\n        }\n\n        /// Resets the counter to zero\n        pub fn reset(&self) -> u64 {\n            self.value.swap(0, std::sync::atomic::Ordering::Relaxed) /* Return old value */\n        }\n    }\n}\n\n/// Complex macro definitions for code generation\n///\n/// These macros generate repetitive code patterns\n/// and provide convenient APIs for common operations.\n\n/// Generates a builder pattern for any struct\n///\n/// # Example\n///\n/// ```rust\n/// generate_builder!(MyStruct {\n///     field1: String,\n///     field2: u32,\n/// });\n/// ```\n#[macro_export]\nmacro_rules! generate_builder {\n    ($struct_name:ident { $($field:ident: $field_type:ty),* $(,)? }) => {\n        paste::paste! {\n            /// Builder for $struct_name\n            #[derive(Default)]\n            pub struct [<$struct_name Builder>] {\n                $(\n                    $field: Option<$field_type>, // Optional field\n                )*\n            }\n\n            impl [<$struct_name Builder>] {\n                /// Creates a new builder instance\n                pub fn new() -> Self {\n                    Self::default()\n                }\n\n                $(\n                    /// Sets the $field field\n                    pub fn $field(mut self, value: $field_type) -> Self {\n                        self.$field = Some(value); /* Store the value */\n                        self // Return self for chaining\n                    }\n                )*\n\n                /// Builds the final struct\n                ///\n                /// # Panics\n                ///\n                /// Panics if any required field is not set.\n                pub fn build(self) -> $struct_name {\n                    $struct_name {\n                        $(\n                            $field: self.$field.expect(\n                                concat!(\"Field '\", stringify!($field), \"' is required\")\n                            ),\n                        )*\n                    }\n                }\n            }\n\n            impl $struct_name {\n                /// Creates a new builder for this struct\n                pub fn builder() -> [<$struct_name Builder>] {\n                    [<$struct_name Builder>]::new()\n                }\n            }\n        }\n    };\n}\n\n/// Generates error handling boilerplate\n///\n/// This macro creates From implementations for converting\n/// between different error types.\nmacro_rules! impl_error_conversions {\n    ($error_type:ty, { $($from_type:ty => $variant:path),* $(,)? }) => {\n        $(\n            impl From<$from_type> for $error_type {\n                fn from(err: $from_type) -> Self {\n                    $variant(err.to_string()) /* Convert to string */\n                }\n            }\n        )*\n    };\n}\n\n// Apply the error conversion macro\nimpl_error_conversions!(AppError, {\n    std::io::Error => AppError::ConfigError,\n    std::num::ParseIntError => AppError::ParseError {\n        line: 0,\n        column: 0,\n        details: \"Parse error\".to_string()\n    },\n});\n\n/// Test module with comprehensive test cases\n///\n/// This module contains unit tests and integration tests\n/// for all the functionality defined above.\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    /// Test the basic configuration functionality\n    #[test]\n    fn test_config_defaults() {\n        let config = Config::default();\n        assert_eq!(config.max_connections, 10); // Check default value\n        assert_eq!(config.timeout.as_secs(), DEFAULT_TIMEOUT);\n        assert!(!config.debug_mode); /* Should be false by default */\n        assert!(config.headers.is_empty()); // No headers by default\n    }\n\n    /* Test error formatting and display */\n    #[test]\n    fn test_error_display() {\n        let network_error = AppError::NetworkError {\n            code: 404,\n            message: \"Not Found\".to_string(),\n            retry_after: Some(60),\n        };\n\n        let error_string = network_error.to_string();\n        assert!(error_string.contains(\"404\")); // Should contain status code\n        assert!(error_string.contains(\"Not Found\")); /* Should contain message */\n    }\n\n    /// Test the processing pipeline with simple operations\n    #[tokio::test]\n    async fn test_pipeline_basic() {\n        let mut pipeline = ProcessingPipeline::<String, String>::new(2);\n\n        // Add stages that transform the data\n        pipeline.add_stage(Box::new(|data: String| {\n            Ok(data.to_uppercase()) /* Convert to uppercase */\n        }));\n\n        pipeline.add_stage(Box::new(|data: String| {\n            Ok(format!(\"Processed: {}\", data)) // Add prefix\n        }));\n\n        let result = pipeline.process(\"hello world\".to_string()).await;\n        assert!(result.is_ok());\n\n        let processed = result.unwrap();\n        assert_eq!(processed, \"Processed: HELLO WORLD\"); /* Expected result */\n    }\n\n    /**\n     * Test pipeline error handling\n     *\n     * This test verifies that errors in pipeline stages\n     * are properly propagated and handled.\n     */\n    #[tokio::test]\n    async fn test_pipeline_error_handling() {\n        let mut pipeline = ProcessingPipeline::<String, String>::new(1);\n\n        // Add a stage that always fails\n        pipeline.add_stage(Box::new(|_data: String| {\n            Err(AppError::TimeoutError) /* Simulate failure */\n        }));\n\n        let result = pipeline.process(\"test\".to_string()).await;\n        assert!(result.is_err()); // Should fail\n\n        let error = result.unwrap_err();\n        matches!(error, AppError::TimeoutError); /* Should be timeout error */\n    }\n\n    /// Test unsafe operations (with careful safety considerations)\n    #[test]\n    fn test_unsafe_checksum() {\n        let data = b\"Hello, world!\"; // Test data\n        let checksum = unsafe {\n            unsafe_operations::fast_checksum(\n                data.as_ptr(),\n                data.len()\n            )\n        };\n\n        // Verify checksum is calculated correctly\n        assert_ne!(checksum, 0); /* Should not be zero for this data */\n\n        // Test with empty data\n        let empty_checksum = unsafe {\n            unsafe_operations::fast_checksum(\n                std::ptr::null(), /* Null pointer */\n                0 /* Zero length */\n            )\n        };\n        assert_eq!(empty_checksum, 0); // Should be zero for empty data\n    }\n\n    /* Test lock-free counter operations */\n    #[test]\n    fn test_lock_free_counter() {\n        let counter = unsafe_operations::LockFreeCounter::new();\n\n        assert_eq!(counter.get(), 0); // Should start at zero\n\n        let old_value = counter.increment();\n        assert_eq!(old_value, 0); /* Previous value should be 0 */\n        assert_eq!(counter.get(), 1); // New value should be 1\n\n        let reset_value = counter.reset();\n        assert_eq!(reset_value, 1); // Should return the previous value\n        assert_eq!(counter.get(), 0); /* Should be back to zero */\n    }\n\n    /// Benchmark test for performance measurement\n    #[test]\n    fn test_performance_benchmark() {\n        let iterations = 1_000_000;\n        let start = Instant::now();\n\n        // Simulate some work\n        let mut sum = 0u64;\n        for i in 0..iterations {\n            sum = sum.wrapping_add(i); /* Prevent overflow */\n        }\n\n        let duration = start.elapsed();\n        println!(\"Benchmark completed in {:?}\", duration);\n\n        // Verify the computation was not optimized away\n        assert_ne!(sum, 0); // Sum should not be zero\n    }\n\n    /**\n     * Integration test that combines multiple components\n     *\n     * This test verifies that different parts of the system\n     * work together correctly.\n     */\n    #[tokio::test]\n    async fn test_integration() {\n        // Create a complex pipeline\n        let mut pipeline = ProcessingPipeline::<String, String>::new(4);\n\n        // Add multiple processing stages\n        pipeline.add_stage(Box::new(|data: String| {\n            if data.is_empty() {\n                Err(AppError::ConfigError(\"Empty input\".to_string()))\n            } else {\n                Ok(data.trim().to_string()) /* Remove whitespace */\n            }\n        }));\n\n        pipeline.add_stage(Box::new(|data: String| {\n            Ok(data.replace(\" \", \"_\")) // Replace spaces with underscores\n        }));\n\n        pipeline.add_stage(Box::new(|data: String| {\n            Ok(format!(\"final_{}\", data.to_lowercase())) /* Add prefix and lowercase */\n        }));\n\n        // Test with valid input\n        let result = pipeline.process(\"  Hello World  \".to_string()).await;\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"final_hello_world\");\n\n        // Test with invalid input\n        let error_result = pipeline.process(\"\".to_string()).await;\n        assert!(error_result.is_err()); /* Should fail for empty input */\n\n        // Check metrics\n        let metrics = pipeline.get_metrics();\n        assert_eq!(metrics.total_processed, 1); // One successful operation\n        assert_eq!(metrics.total_failed, 1); /* One failed operation */\n    }\n}",
      "comment_ranges": [
        [
          0,
          171
        ],
        [
          173,
          224
        ],
        [
          224,
          275
        ],
        [
          275,
          279
        ],
        [
          279,
          291
        ],
        [
          291,
          331
        ],
        [
          331,
          364
        ],
        [
          364,
          372
        ],
        [
          372,
          376
        ],
        [
          376,
          389
        ],
        [
          389,
          393
        ],
        [
          393,
          462
        ],
        [
          462,
          520
        ],
        [
          564,
          587
        ],
        [
          617,
          645
        ],
        [
          682,
          699
        ],
        [
          700,
          761
        ],
        [
          780,
          813
        ],
        [
          858,
          871
        ],
        [
          905,
          1008
        ],
        [
          1040,
          1062
        ],
        [
          1064,
          1121
        ],
        [
          1121,
          1125
        ],
        [
          1125,
          1197
        ],
        [
          1197,
          1257
        ],
        [
          1257,
          1261
        ],
        [
          1261,
          1276
        ],
        [
          1276,
          1280
        ],
        [
          1280,
          1292
        ],
        [
          1292,
          1318
        ],
        [
          1318,
          1348
        ],
        [
          1348,
          1390
        ],
        [
          1390,
          1419
        ],
        [
          1419,
          1426
        ],
        [
          1426,
          1434
        ],
        [
          1482,
          1527
        ],
        [
          1531,
          1563
        ],
        [
          1600,
          1667
        ],
        [
          1700,
          1723
        ],
        [
          1750,
          1837
        ],
        [
          1843,
          1880
        ],
        [
          1922,
          1940
        ],
        [
          1974,
          2010
        ],
        [
          2014,
          2018
        ],
        [
          2022,
          2072
        ],
        [
          2076,
          2102
        ],
        [
          2177,
          2200
        ],
        [
          2291,
          2332
        ],
        [
          2370,
          2386
        ],
        [
          2406,
          2547
        ],
        [
          2607,
          2639
        ],
        [
          2690,
          2709
        ],
        [
          2742,
          2773
        ],
        [
          2808,
          2839
        ],
        [
          2852,
          2889
        ],
        [
          2915,
          2931
        ],
        [
          2937,
          2973
        ],
        [
          2992,
          3023
        ],
        [
          3029,
          3072
        ],
        [
          3113,
          3148
        ],
        [
          3173,
          3194
        ],
        [
          3220,
          3249
        ],
        [
          3404,
          3430
        ],
        [
          3735,
          3773
        ],
        [
          3949,
          4034
        ],
        [
          4075,
          4123
        ],
        [
          4123,
          4127
        ],
        [
          4127,
          4193
        ],
        [
          4193,
          4253
        ],
        [
          4253,
          4257
        ],
        [
          4257,
          4279
        ],
        [
          4279,
          4283
        ],
        [
          4283,
          4315
        ],
        [
          4315,
          4350
        ],
        [
          4350,
          4354
        ],
        [
          4354,
          4369
        ],
        [
          4369,
          4373
        ],
        [
          4373,
          4385
        ],
        [
          4385,
          4435
        ],
        [
          4435,
          4497
        ],
        [
          4497,
          4554
        ],
        [
          4554,
          4593
        ],
        [
          4593,
          4601
        ],
        [
          4643,
          4673
        ],
        [
          4749,
          4793
        ],
        [
          4821,
          4865
        ],
        [
          4871,
          4896
        ],
        [
          4939,
          4975
        ],
        [
          4981,
          5016
        ],
        [
          5036,
          5062
        ],
        [
          5066,
          5114
        ],
        [
          5114,
          5118
        ],
        [
          5118,
          5187
        ],
        [
          5253,
          5289
        ],
        [
          5315,
          5325
        ],
        [
          5331,
          5364
        ],
        [
          5393,
          5428
        ],
        [
          5464,
          5494
        ],
        [
          5500,
          5540
        ],
        [
          5570,
          5578
        ],
        [
          5698,
          5736
        ],
        [
          5740,
          5744
        ],
        [
          5748,
          5764
        ],
        [
          5768,
          5772
        ],
        [
          5776,
          5830
        ],
        [
          5834,
          5838
        ],
        [
          5842,
          5856
        ],
        [
          5860,
          5864
        ],
        [
          5868,
          5920
        ],
        [
          6016,
          6034
        ],
        [
          6064,
          6085
        ],
        [
          6196,
          6224
        ],
        [
          6246,
          6290
        ],
        [
          6294,
          6298
        ],
        [
          6302,
          6355
        ],
        [
          6359,
          6417
        ],
        [
          6421,
          6425
        ],
        [
          6429,
          6445
        ],
        [
          6449,
          6453
        ],
        [
          6457,
          6504
        ],
        [
          6508,
          6512
        ],
        [
          6516,
          6531
        ],
        [
          6535,
          6539
        ],
        [
          6543,
          6555
        ],
        [
          6559,
          6608
        ],
        [
          6612,
          6648
        ],
        [
          6652,
          6661
        ],
        [
          6665,
          6673
        ],
        [
          6841,
          6859
        ],
        [
          6871,
          7146
        ],
        [
          7258,
          7282
        ],
        [
          7292,
          7321
        ],
        [
          7492,
          7516
        ],
        [
          7584,
          7626
        ],
        [
          7712,
          7737
        ],
        [
          7914,
          7936
        ],
        [
          7989,
          8014
        ],
        [
          8164,
          8187
        ],
        [
          8201,
          8234
        ],
        [
          8594,
          8620
        ],
        [
          8632,
          8673
        ],
        [
          8677,
          8681
        ],
        [
          8685,
          8739
        ],
        [
          8743,
          8783
        ],
        [
          8787,
          8791
        ],
        [
          8795,
          8811
        ],
        [
          8815,
          8819
        ],
        [
          8823,
          8866
        ],
        [
          8870,
          8874
        ],
        [
          8878,
          8892
        ],
        [
          8896,
          8900
        ],
        [
          8904,
          8953
        ],
        [
          8957,
          8961
        ],
        [
          8965,
          8989
        ],
        [
          8993,
          8997
        ],
        [
          9001,
          9060
        ],
        [
          9064,
          9100
        ],
        [
          9420,
          9470
        ],
        [
          9615,
          9644
        ],
        [
          9798,
          9816
        ],
        [
          9872,
          9898
        ],
        [
          10128,
          10161
        ],
        [
          10317,
          10355
        ],
        [
          10466,
          10531
        ],
        [
          10556,
          10587
        ],
        [
          10613,
          10726
        ],
        [
          10829,
          10860
        ],
        [
          11162,
          11177
        ],
        [
          11235,
          11251
        ],
        [
          11435,
          11463
        ],
        [
          11612,
          11646
        ],
        [
          11713,
          11752
        ],
        [
          11772,
          11801
        ],
        [
          11885,
          11916
        ],
        [
          11928,
          11962
        ],
        [
          11966,
          11970
        ],
        [
          11974,
          12033
        ],
        [
          12037,
          12096
        ],
        [
          12192,
          12208
        ],
        [
          12220,
          12377
        ],
        [
          12515,
          12538
        ],
        [
          12548,
          12600
        ],
        [
          12600,
          12604
        ],
        [
          12604,
          12659
        ],
        [
          12659,
          12709
        ],
        [
          12709,
          12713
        ],
        [
          12713,
          12726
        ],
        [
          12726,
          12730
        ],
        [
          12730,
          12786
        ],
        [
          12786,
          12844
        ],
        [
          12895,
          12948
        ],
        [
          12952,
          12956
        ],
        [
          12960,
          12973
        ],
        [
          12977,
          12981
        ],
        [
          12985,
          13018
        ],
        [
          13022,
          13070
        ],
        [
          13074,
          13129
        ],
        [
          13133,
          13186
        ],
        [
          13190,
          13194
        ],
        [
          13198,
          13214
        ],
        [
          13218,
          13222
        ],
        [
          13226,
          13260
        ],
        [
          13264,
          13302
        ],
        [
          13306,
          13310
        ],
        [
          13314,
          13328
        ],
        [
          13332,
          13336
        ],
        [
          13340,
          13365
        ],
        [
          13467,
          13492
        ],
        [
          13525,
          13571
        ],
        [
          13705,
          13734
        ],
        [
          13755,
          13776
        ],
        [
          13796,
          13821
        ],
        [
          13882,
          13904
        ],
        [
          13984,
          13996
        ],
        [
          14025,
          14047
        ],
        [
          14059,
          14106
        ],
        [
          14110,
          14114
        ],
        [
          14118,
          14173
        ],
        [
          14177,
          14226
        ],
        [
          14230,
          14234
        ],
        [
          14238,
          14251
        ],
        [
          14255,
          14259
        ],
        [
          14263,
          14315
        ],
        [
          14319,
          14362
        ],
        [
          14366,
          14409
        ],
        [
          14413,
          14458
        ],
        [
          14462,
          14503
        ],
        [
          14507,
          14511
        ],
        [
          14515,
          14533
        ],
        [
          14537,
          14541
        ],
        [
          14545,
          14597
        ],
        [
          14601,
          14658
        ],
        [
          14737,
          14776
        ],
        [
          14838,
          14892
        ],
        [
          14933,
          14984
        ],
        [
          15184,
          15196
        ],
        [
          15249,
          15274
        ],
        [
          15346,
          15369
        ],
        [
          15485,
          15528
        ],
        [
          15608,
          15789
        ],
        [
          15868,
          15885
        ],
        [
          15928,
          15971
        ],
        [
          16115,
          16173
        ],
        [
          16181,
          16185
        ],
        [
          16193,
          16237
        ],
        [
          16371,
          16407
        ],
        [
          16528,
          16559
        ],
        [
          16665,
          16687
        ],
        [
          16707,
          16757
        ],
        [
          16757,
          16761
        ],
        [
          16761,
          16812
        ],
        [
          16812,
          16867
        ],
        [
          16868,
          16915
        ],
        [
          16915,
          16919
        ],
        [
          16919,
          16933
        ],
        [
          16933,
          16937
        ],
        [
          16937,
          16949
        ],
        [
          16949,
          16982
        ],
        [
          16982,
          17006
        ],
        [
          17006,
          17027
        ],
        [
          17027,
          17035
        ],
        [
          17035,
          17043
        ],
        [
          17201,
          17230
        ],
        [
          17379,
          17396
        ],
        [
          17491,
          17526
        ],
        [
          17659,
          17685
        ],
        [
          17810,
          17831
        ],
        [
          17861,
          17888
        ],
        [
          17947,
          17975
        ],
        [
          17991,
          17995
        ],
        [
          18011,
          18024
        ],
        [
          18040,
          18044
        ],
        [
          18060,
          18105
        ],
        [
          18525,
          18567
        ],
        [
          18734,
          18775
        ],
        [
          18775,
          18779
        ],
        [
          18779,
          18838
        ],
        [
          18838,
          18873
        ],
        [
          19144,
          19167
        ],
        [
          19221,
          19256
        ],
        [
          19483,
          19529
        ],
        [
          19529,
          19533
        ],
        [
          19533,
          19591
        ],
        [
          19591,
          19636
        ],
        [
          19684,
          19731
        ],
        [
          19863,
          19885
        ],
        [
          19986,
          20018
        ],
        [
          20063,
          20087
        ],
        [
          20099,
          20138
        ],
        [
          20451,
          20480
        ],
        [
          20534,
          20562
        ],
        [
          20574,
          20630
        ],
        [
          20768,
          20805
        ],
        [
          20895,
          20921
        ],
        [
          21036,
          21049
        ],
        [
          21268,
          21289
        ],
        [
          21301,
          21456
        ],
        [
          21604,
          21636
        ],
        [
          21731,
          21753
        ],
        [
          21867,
          21881
        ],
        [
          21973,
          22002
        ],
        [
          22014,
          22078
        ],
        [
          22159,
          22171
        ],
        [
          22342,
          22384
        ],
        [
          22418,
          22456
        ],
        [
          22466,
          22489
        ],
        [
          22608,
          22626
        ],
        [
          22645,
          22662
        ],
        [
          22727,
          22759
        ],
        [
          22771,
          22810
        ],
        [
          22961,
          22984
        ],
        [
          23065,
          23097
        ],
        [
          23136,
          23160
        ],
        [
          23241,
          23276
        ],
        [
          23315,
          23343
        ],
        [
          23355,
          23402
        ],
        [
          23533,
          23554
        ],
        [
          23655,
          23677
        ],
        [
          23797,
          23845
        ],
        [
          23874,
          23899
        ],
        [
          23911,
          24080
        ],
        [
          24142,
          24170
        ],
        [
          24253,
          24286
        ],
        [
          24508,
          24531
        ],
        [
          24652,
          24686
        ],
        [
          24811,
          24841
        ],
        [
          24864,
          24888
        ],
        [
          25065,
          25091
        ],
        [
          25199,
          25232
        ],
        [
          25242,
          25258
        ],
        [
          25353,
          25380
        ],
        [
          25426,
          25452
        ]
      ],
      "content_length": 25460,
      "difficulty": "Some(Wild)",
      "end_line": 785,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 1
    },
    {
      "code_content": "/*\n * Complex Rust file with various comment patterns\n * This file tests comment range detection and code parsing\n * It includes multiple comment styles and edge cases\n */\n\n/// This is a documentation comment for the module\n/// It spans multiple lines and contains examples:\n///\n/// ```rust\n/// let example = ComplexStruct::new();\n/// example.process_data(&data);\n/// ```\n///\n/// # Safety\n///\n/// This module contains unsafe code blocks for performance reasons.\n/// Users should be careful when calling these functions.\n\nuse std::collections::{HashMap, BTreeMap}; // Standard collections\nuse std::sync::{Arc, Mutex}; /* Thread-safe primitives */\nuse std::time::{Duration, Instant}; // Time utilities\n/* Multi-line import comment\n   with detailed explanations */\nuse std::thread;\n\n// Constants with inline comments\nconst MAX_BUFFER_SIZE: usize = 1024 * 1024; // 1MB buffer\nconst DEFAULT_TIMEOUT: u64 = 30; /* 30 seconds default timeout\n                                    can be overridden by configuration */\nconst VERSION: &str = \"1.0.0\"; // Application version\n\n/// Configuration structure with extensive documentation\n///\n/// This struct holds all configuration parameters for the application.\n/// Each field has specific constraints and default values.\n///\n/// # Examples\n///\n/// ```rust\n/// let config = Config {\n///     max_connections: 100,\n///     timeout: Duration::from_secs(30),\n///     ..Default::default()\n/// };\n/// ```\n#[derive(Debug, Clone)]\npub struct Config {\n    /// Maximum number of concurrent connections\n    /// Must be between 1 and 10000\n    pub max_connections: usize,\n\n    /* Timeout for network operations\n       Set to 0 for no timeout */\n    pub timeout: Duration,\n\n    // Enable debug logging\n    pub debug_mode: bool, /* This affects performance\n                             only enable for development */\n\n    /// Custom headers for HTTP requests\n    pub headers: HashMap<String, String>, // Key-value pairs\n}\n\nimpl Default for Config {\n    /// Creates a default configuration\n    ///\n    /// All values are set to safe defaults that work\n    /// in most environments.\n    fn default() -> Self {\n        Self {\n            max_connections: 10, // Conservative default\n            timeout: Duration::from_secs(DEFAULT_TIMEOUT),\n            debug_mode: false, /* Disabled by default for performance */\n            headers: HashMap::new(), // Empty headers\n        }\n    }\n}\n\n/**\n * Error enumeration with various patterns\n *\n * This enum covers all possible error conditions\n * that can occur in the application.\n */\n#[derive(Debug, Clone, PartialEq)]\npub enum AppError {\n    /// Network connectivity issues\n    NetworkError {\n        code: u16,              // HTTP status code\n        message: String,        /* Error message from server */\n        retry_after: Option<u64>, // Seconds to wait before retry\n    },\n\n    /* Configuration validation errors */\n    ConfigError(String), // Error message\n\n    // Timeout occurred during operation\n    TimeoutError, /* No additional data needed */\n\n    /// Parse errors with location information\n    ParseError {\n        line: usize,    // Line number where error occurred\n        column: usize,  /* Column position */\n        details: String, // Detailed error description\n    },\n}\n\nimpl std::fmt::Display for AppError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            // Simple error formatting\n            AppError::NetworkError { code, message, .. } => {\n                write!(f, \"Network error {}: {}\", code, message)\n            },\n            AppError::ConfigError(msg) => write!(f, \"Config error: {}\", msg),\n            AppError::TimeoutError => write!(f, \"Operation timed out\"),\n            /* Complex error with location info */\n            AppError::ParseError { line, column, details } => {\n                write!(f, \"Parse error at {}:{}: {}\", line, column, details)\n            },\n        }\n    }\n}\n\n/* Implementation of std::error::Error trait\n   Required for proper error handling */\nimpl std::error::Error for AppError {}\n\n/// Data processing pipeline with complex logic\n///\n/// This struct implements a multi-stage data processing pipeline\n/// with support for parallel execution and error recovery.\n///\n/// # Type Parameters\n///\n/// * `T` - The input data type\n/// * `R` - The output result type\n///\n/// # Examples\n///\n/// ```rust\n/// let mut pipeline = ProcessingPipeline::new();\n/// pipeline.add_stage(Box::new(|data| data.to_uppercase()));\n/// let result = pipeline.process(\"hello world\").await?;\n/// assert_eq!(result, \"HELLO WORLD\");\n/// ```\npub struct ProcessingPipeline<T, R> {\n    // Vector of processing stages\n    stages: Vec<Box<dyn Fn(T) -> Result<T, AppError> + Send + Sync>>,\n\n    /// Maximum number of concurrent operations\n    max_concurrency: usize, /* Limited to prevent resource exhaustion */\n\n    // Statistics and metrics\n    metrics: Arc<Mutex<PipelineMetrics>>, /* Thread-safe metrics collection */\n\n    /// Configuration for the pipeline\n    config: Config, // Reuse the config struct\n}\n\n/// Metrics collected during pipeline execution\n///\n/// These metrics help monitor performance and identify bottlenecks.\n#[derive(Debug, Default, Clone)]\npub struct PipelineMetrics {\n    /// Total number of items processed\n    total_processed: u64, // Counter\n\n    /* Number of failed operations */\n    total_failed: u64,\n\n    // Average processing time per item\n    avg_processing_time: Duration, /* Calculated automatically */\n\n    /// Peak memory usage during processing\n    peak_memory_usage: usize, // Bytes\n}\n\nimpl<T, R> ProcessingPipeline<T, R>\nwhere\n    T: Send + Sync + Clone + 'static,\n    R: Send + Sync + 'static,\n{\n    /// Creates a new processing pipeline\n    ///\n    /// # Arguments\n    ///\n    /// * `max_concurrency` - Maximum parallel operations\n    ///\n    /// # Returns\n    ///\n    /// A new pipeline instance ready for configuration\n    pub fn new(max_concurrency: usize) -> Self {\n        Self {\n            stages: Vec::new(), // Empty initially\n            max_concurrency, /* Store the limit */\n            metrics: Arc::new(Mutex::new(PipelineMetrics::default())),\n            config: Config::default(), // Use default configuration\n        }\n    }\n\n    /// Adds a processing stage to the pipeline\n    ///\n    /// Stages are executed in the order they are added.\n    /// Each stage receives the output of the previous stage.\n    ///\n    /// # Arguments\n    ///\n    /// * `stage` - A function that processes data\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// pipeline.add_stage(Box::new(|data: String| {\n    ///     Ok(data.trim().to_string())\n    /// }));\n    /// ```\n    pub fn add_stage<F>(&mut self, stage: F)\n    where\n        F: Fn(T) -> Result<T, AppError> + Send + Sync + 'static\n    {\n        self.stages.push(Box::new(stage)); // Box the closure\n    }\n\n    /**\n     * Processes data through all stages\n     *\n     * This method executes all configured stages in sequence,\n     * passing the output of each stage to the next.\n     *\n     * @param data The input data to process\n     * @return The processed result or an error\n     */\n    pub async fn process(&self, mut data: T) -> Result<T, AppError> {\n        let start_time = Instant::now(); // Track processing time\n\n        // Process through each stage\n        for (index, stage) in self.stages.iter().enumerate() {\n            match stage(data.clone()) {\n                Ok(result) => {\n                    data = result; // Update for next stage\n                },\n                Err(e) => {\n                    /* Log the error with stage information */\n                    eprintln!(\"Stage {} failed: {}\", index, e);\n\n                    // Update failure metrics\n                    if let Ok(mut metrics) = self.metrics.lock() {\n                        metrics.total_failed += 1;\n                    }\n\n                    return Err(e); // Propagate the error\n                },\n            }\n        }\n\n        // Update success metrics\n        let processing_time = start_time.elapsed();\n        if let Ok(mut metrics) = self.metrics.lock() {\n            metrics.total_processed += 1; /* Increment counter */\n\n            // Update average processing time\n            let total_items = metrics.total_processed + metrics.total_failed;\n            if total_items > 0 {\n                let total_time = metrics.avg_processing_time * (total_items - 1) as u32\n                    + processing_time;\n                metrics.avg_processing_time = total_time / total_items as u32;\n            }\n        }\n\n        Ok(data) // Return processed result\n    }\n\n    /// Processes multiple items in parallel\n    ///\n    /// This method takes advantage of multiple CPU cores\n    /// to process data items concurrently.\n    ///\n    /// # Arguments\n    ///\n    /// * `items` - Vector of items to process\n    ///\n    /// # Returns\n    ///\n    /// Vector of results in the same order as input\n    ///\n    /// # Performance Notes\n    ///\n    /// The actual concurrency is limited by `max_concurrency`\n    /// to prevent resource exhaustion.\n    pub async fn process_batch(&self, items: Vec<T>) -> Vec<Result<T, AppError>> {\n        use std::sync::atomic::{AtomicUsize, Ordering};\n\n        let results = Arc::new(Mutex::new(Vec::with_capacity(items.len())));\n        let completed = Arc::new(AtomicUsize::new(0));\n        let total_items = items.len();\n\n        /* Process items in chunks to limit concurrency */\n        let chunk_size = (total_items / self.max_concurrency).max(1);\n        let chunks: Vec<_> = items.chunks(chunk_size).collect();\n\n        // Spawn tasks for each chunk\n        let mut handles = Vec::new();\n\n        for (chunk_index, chunk) in chunks.into_iter().enumerate() {\n            let chunk_data = chunk.to_vec(); // Clone the chunk\n            let pipeline_stages = self.stages.clone(); /* Can't clone directly */\n            let results_ref = Arc::clone(&results);\n            let completed_ref = Arc::clone(&completed);\n\n            let handle = tokio::spawn(async move {\n                let mut chunk_results = Vec::new();\n\n                // Process each item in the chunk\n                for item in chunk_data {\n                    let mut current_data = item;\n                    let mut success = true;\n\n                    /* Execute all stages for this item */\n                    for (stage_index, _stage) in pipeline_stages.iter().enumerate() {\n                        // Note: Can't actually call the stage here due to borrow checker\n                        // This is a simplified example\n\n                        /* Simulate stage processing\n                           In real implementation, we'd need a different approach */\n                        if stage_index % 7 == 0 && chunk_index % 3 == 0 {\n                            // Simulate occasional failures\n                            chunk_results.push(Err(AppError::TimeoutError));\n                            success = false;\n                            break;\n                        }\n                    }\n\n                    if success {\n                        chunk_results.push(Ok(current_data)); // Success case\n                    }\n                }\n\n                // Store results\n                {\n                    let mut results_guard = results_ref.lock().unwrap();\n                    results_guard.extend(chunk_results);\n                }\n\n                // Update completion counter\n                completed_ref.fetch_add(chunk_data.len(), Ordering::Relaxed);\n            });\n\n            handles.push(handle);\n        }\n\n        // Wait for all chunks to complete\n        for handle in handles {\n            let _ = handle.await; /* Ignore join errors for simplicity */\n        }\n\n        // Extract and return results\n        let results_guard = results.lock().unwrap();\n        results_guard.clone() // Return the collected results\n    }\n\n    /// Gets current pipeline metrics\n    ///\n    /// Returns a snapshot of the current performance metrics.\n    /// This data can be used for monitoring and optimization.\n    pub fn get_metrics(&self) -> PipelineMetrics {\n        self.metrics.lock().unwrap().clone() // Return a copy\n    }\n\n    /**\n     * Resets all metrics to their initial state\n     *\n     * This is useful for starting fresh measurements\n     * or clearing historical data.\n     */\n    pub fn reset_metrics(&self) {\n        let mut metrics = self.metrics.lock().unwrap();\n        *metrics = PipelineMetrics::default(); /* Reset to defaults */\n    }\n}\n\n/// Unsafe operations for performance-critical code\n///\n/// This module contains unsafe operations that bypass\n/// Rust's safety checks for maximum performance.\n///\n/// # Safety\n///\n/// All functions in this module require careful review\n/// and should only be used when performance is critical.\npub mod unsafe_operations {\n    use super::*;\n\n    /// Raw memory manipulation for zero-copy operations\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure that:\n    /// - The pointer is valid and properly aligned\n    /// - The data lives at least as long as the operation\n    /// - No other code modifies the memory concurrently\n    ///\n    /// # Arguments\n    ///\n    /// * `ptr` - Raw pointer to data\n    /// * `len` - Length of data in bytes\n    ///\n    /// # Returns\n    ///\n    /// Checksum of the data\n    pub unsafe fn fast_checksum(ptr: *const u8, len: usize) -> u32 {\n        let mut checksum = 0u32; // Initialize accumulator\n        let mut i = 0;\n\n        /* Process 4 bytes at a time for efficiency */\n        while i + 4 <= len {\n            let chunk = ptr.add(i) as *const u32;\n            checksum = checksum.wrapping_add(*chunk); // Add without overflow check\n            i += 4; // Move to next chunk\n        }\n\n        // Handle remaining bytes\n        while i < len {\n            let byte = *ptr.add(i); /* Read single byte */\n            checksum = checksum.wrapping_add(byte as u32);\n            i += 1; // Next byte\n        }\n\n        checksum // Return final result\n    }\n\n    /// Direct memory copy without bounds checking\n    ///\n    /// This function performs a raw memory copy operation\n    /// without any safety checks for maximum speed.\n    ///\n    /// # Safety\n    ///\n    /// Extremely dangerous! The caller must guarantee:\n    /// - Both pointers are valid and non-null\n    /// - Source and destination don't overlap\n    /// - Both regions have at least `len` bytes\n    /// - Proper alignment for the data type\n    ///\n    /// # Performance\n    ///\n    /// This is faster than `std::ptr::copy` because it\n    /// skips all safety checks and uses optimized assembly.\n    pub unsafe fn raw_copy(src: *const u8, dst: *mut u8, len: usize) {\n        // Use platform-specific optimized copy\n        #[cfg(target_arch = \"x86_64\")]\n        {\n            /* x86_64 optimized version using SIMD instructions */\n            let mut i = 0;\n\n            // Process 32 bytes at a time with AVX if available\n            while i + 32 <= len {\n                let src_chunk = src.add(i) as *const [u8; 32];\n                let dst_chunk = dst.add(i) as *mut [u8; 32];\n                *dst_chunk = *src_chunk; // Bulk copy\n                i += 32;\n            }\n\n            // Handle remaining bytes\n            while i < len {\n                *dst.add(i) = *src.add(i); /* Byte-by-byte copy */\n                i += 1;\n            }\n        }\n\n        #[cfg(not(target_arch = \"x86_64\"))]\n        {\n            // Generic fallback for other architectures\n            std::ptr::copy_nonoverlapping(src, dst, len);\n        }\n    }\n\n    /**\n     * Lock-free atomic operations for high-performance counters\n     *\n     * This structure provides thread-safe counters without\n     * the overhead of mutex locking.\n     */\n    pub struct LockFreeCounter {\n        value: std::sync::atomic::AtomicU64, // Atomic counter\n    }\n\n    impl LockFreeCounter {\n        /// Creates a new counter starting at zero\n        pub fn new() -> Self {\n            Self {\n                value: std::sync::atomic::AtomicU64::new(0),\n            }\n        }\n\n        /// Increments the counter and returns the previous value\n        ///\n        /// This operation is atomic and lock-free.\n        pub fn increment(&self) -> u64 {\n            self.value.fetch_add(1, std::sync::atomic::Ordering::Relaxed)\n        }\n\n        /* Gets the current counter value */\n        pub fn get(&self) -> u64 {\n            self.value.load(std::sync::atomic::Ordering::Relaxed)\n        }\n\n        /// Resets the counter to zero\n        pub fn reset(&self) -> u64 {\n            self.value.swap(0, std::sync::atomic::Ordering::Relaxed) /* Return old value */\n        }\n    }\n}\n\n/// Complex macro definitions for code generation\n///\n/// These macros generate repetitive code patterns\n/// and provide convenient APIs for common operations.\n\n/// Generates a builder pattern for any struct\n///\n/// # Example\n///\n/// ```rust\n/// generate_builder!(MyStruct {\n///     field1: String,\n///     field2: u32,\n/// });\n/// ```\n#[macro_export]\nmacro_rules! generate_builder {\n    ($struct_name:ident { $($field:ident: $field_type:ty),* $(,)? }) => {\n        paste::paste! {\n            /// Builder for $struct_name\n            #[derive(Default)]\n            pub struct [<$struct_name Builder>] {\n                $(\n                    $field: Option<$field_type>, // Optional field\n                )*\n            }\n\n            impl [<$struct_name Builder>] {\n                /// Creates a new builder instance\n                pub fn new() -> Self {\n                    Self::default()\n                }\n\n                $(\n                    /// Sets the $field field\n                    pub fn $field(mut self, value: $field_type) -> Self {\n                        self.$field = Some(value); /* Store the value */\n                        self // Return self for chaining\n                    }\n                )*\n\n                /// Builds the final struct\n                ///\n                /// # Panics\n                ///\n                /// Panics if any required field is not set.\n                pub fn build(self) -> $struct_name {\n                    $struct_name {\n                        $(\n                            $field: self.$field.expect(\n                                concat!(\"Field '\", stringify!($field), \"' is required\")\n                            ),\n                        )*\n                    }\n                }\n            }\n\n            impl $struct_name {\n                /// Creates a new builder for this struct\n                pub fn builder() -> [<$struct_name Builder>] {\n                    [<$struct_name Builder>]::new()\n                }\n            }\n        }\n    };\n}\n\n/// Generates error handling boilerplate\n///\n/// This macro creates From implementations for converting\n/// between different error types.\nmacro_rules! impl_error_conversions {\n    ($error_type:ty, { $($from_type:ty => $variant:path),* $(,)? }) => {\n        $(\n            impl From<$from_type> for $error_type {\n                fn from(err: $from_type) -> Self {\n                    $variant(err.to_string()) /* Convert to string */\n                }\n            }\n        )*\n    };\n}\n\n// Apply the error conversion macro\nimpl_error_conversions!(AppError, {\n    std::io::Error => AppError::ConfigError,\n    std::num::ParseIntError => AppError::ParseError {\n        line: 0,\n        column: 0,\n        details: \"Parse error\".to_string()\n    },\n});\n\n/// Test module with comprehensive test cases\n///\n/// This module contains unit tests and integration tests\n/// for all the functionality defined above.\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    /// Test the basic configuration functionality\n    #[test]\n    fn test_config_defaults() {\n        let config = Config::default();\n        assert_eq!(config.max_connections, 10); // Check default value\n        assert_eq!(config.timeout.as_secs(), DEFAULT_TIMEOUT);\n        assert!(!config.debug_mode); /* Should be false by default */\n        assert!(config.headers.is_empty()); // No headers by default\n    }\n\n    /* Test error formatting and display */\n    #[test]\n    fn test_error_display() {\n        let network_error = AppError::NetworkError {\n            code: 404,\n            message: \"Not Found\".to_string(),\n            retry_after: Some(60),\n        };\n\n        let error_string = network_error.to_string();\n        assert!(error_string.contains(\"404\")); // Should contain status code\n        assert!(error_string.contains(\"Not Found\")); /* Should contain message */\n    }\n\n    /// Test the processing pipeline with simple operations\n    #[tokio::test]\n    async fn test_pipeline_basic() {\n        let mut pipeline = ProcessingPipeline::<String, String>::new(2);\n\n        // Add stages that transform the data\n        pipeline.add_stage(Box::new(|data: String| {\n            Ok(data.to_uppercase()) /* Convert to uppercase */\n        }));\n\n        pipeline.add_stage(Box::new(|data: String| {\n            Ok(format!(\"Processed: {}\", data)) // Add prefix\n        }));\n\n        let result = pipeline.process(\"hello world\".to_string()).await;\n        assert!(result.is_ok());\n\n        let processed = result.unwrap();\n        assert_eq!(processed, \"Processed: HELLO WORLD\"); /* Expected result */\n    }\n\n    /**\n     * Test pipeline error handling\n     *\n     * This test verifies that errors in pipeline stages\n     * are properly propagated and handled.\n     */\n    #[tokio::test]\n    async fn test_pipeline_error_handling() {\n        let mut pipeline = ProcessingPipeline::<String, String>::new(1);\n\n        // Add a stage that always fails\n        pipeline.add_stage(Box::new(|_data: String| {\n            Err(AppError::TimeoutError) /* Simulate failure */\n        }));\n\n        let result = pipeline.process(\"test\".to_string()).await;\n        assert!(result.is_err()); // Should fail\n\n        let error = result.unwrap_err();\n        matches!(error, AppError::TimeoutError); /* Should be timeout error */\n    }\n\n    /// Test unsafe operations (with careful safety considerations)\n    #[test]\n    fn test_unsafe_checksum() {\n        let data = b\"Hello, world!\"; // Test data\n        let checksum = unsafe {\n            unsafe_operations::fast_checksum(\n                data.as_ptr(),\n                data.len()\n            )\n        };\n\n        // Verify checksum is calculated correctly\n        assert_ne!(checksum, 0); /* Should not be zero for this data */\n\n        // Test with empty data\n        let empty_checksum = unsafe {\n            unsafe_operations::fast_checksum(\n                std::ptr::null(), /* Null pointer */\n                0 /* Zero length */\n            )\n        };\n        assert_eq!(empty_checksum, 0); // Should be zero for empty data\n    }\n\n    /* Test lock-free counter operations */\n    #[test]\n    fn test_lock_free_counter() {\n        let counter = unsafe_operations::LockFreeCounter::new();\n\n        assert_eq!(counter.get(), 0); // Should start at zero\n\n        let old_value = counter.increment();\n        assert_eq!(old_value, 0); /* Previous value should be 0 */\n        assert_eq!(counter.get(), 1); // New value should be 1\n\n        let reset_value = counter.reset();\n        assert_eq!(reset_value, 1); // Should return the previous value\n        assert_eq!(counter.get(), 0); /* Should be back to zero */\n    }\n\n    /// Benchmark test for performance measurement\n    #[test]\n    fn test_performance_benchmark() {\n        let iterations = 1_000_000;\n        let start = Instant::now();\n\n        // Simulate some work\n        let mut sum = 0u64;\n        for i in 0..iterations {\n            sum = sum.wrapping_add(i); /* Prevent overflow */\n        }\n\n        let duration = start.elapsed();\n        println!(\"Benchmark completed in {:?}\", duration);\n\n        // Verify the computation was not optimized away\n        assert_ne!(sum, 0); // Sum should not be zero\n    }\n\n    /**\n     * Integration test that combines multiple components\n     *\n     * This test verifies that different parts of the system\n     * work together correctly.\n     */\n    #[tokio::test]\n    async fn test_integration() {\n        // Create a complex pipeline\n        let mut pipeline = ProcessingPipeline::<String, String>::new(4);\n\n        // Add multiple processing stages\n        pipeline.add_stage(Box::new(|data: String| {\n            if data.is_empty() {\n                Err(AppError::ConfigError(\"Empty input\".to_string()))\n            } else {\n                Ok(data.trim().to_string()) /* Remove whitespace */\n            }\n        }));\n\n        pipeline.add_stage(Box::new(|data: String| {\n            Ok(data.replace(\" \", \"_\")) // Replace spaces with underscores\n        }));\n\n        pipeline.add_stage(Box::new(|data: String| {\n            Ok(format!(\"final_{}\", data.to_lowercase())) /* Add prefix and lowercase */\n        }));\n\n        // Test with valid input\n        let result = pipeline.process(\"  Hello World  \".to_string()).await;\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"final_hello_world\");\n\n        // Test with invalid input\n        let error_result = pipeline.process(\"\".to_string()).await;\n        assert!(error_result.is_err()); /* Should fail for empty input */\n\n        // Check metrics\n        let metrics = pipeline.get_metrics();\n        assert_eq!(metrics.total_processed, 1); // One successful operation\n        assert_eq!(metrics.total_failed, 1); /* One failed operation */\n    }\n}",
      "comment_ranges": [
        [
          0,
          171
        ],
        [
          173,
          224
        ],
        [
          224,
          275
        ],
        [
          275,
          279
        ],
        [
          279,
          291
        ],
        [
          291,
          331
        ],
        [
          331,
          364
        ],
        [
          364,
          372
        ],
        [
          372,
          376
        ],
        [
          376,
          389
        ],
        [
          389,
          393
        ],
        [
          393,
          462
        ],
        [
          462,
          520
        ],
        [
          564,
          587
        ],
        [
          617,
          645
        ],
        [
          682,
          699
        ],
        [
          700,
          761
        ],
        [
          780,
          813
        ],
        [
          858,
          871
        ],
        [
          905,
          1008
        ],
        [
          1040,
          1062
        ],
        [
          1064,
          1121
        ],
        [
          1121,
          1125
        ],
        [
          1125,
          1197
        ],
        [
          1197,
          1257
        ],
        [
          1257,
          1261
        ],
        [
          1261,
          1276
        ],
        [
          1276,
          1280
        ],
        [
          1280,
          1292
        ],
        [
          1292,
          1318
        ],
        [
          1318,
          1348
        ],
        [
          1348,
          1390
        ],
        [
          1390,
          1419
        ],
        [
          1419,
          1426
        ],
        [
          1426,
          1434
        ],
        [
          1482,
          1527
        ],
        [
          1531,
          1563
        ],
        [
          1600,
          1667
        ],
        [
          1700,
          1723
        ],
        [
          1750,
          1837
        ],
        [
          1843,
          1880
        ],
        [
          1922,
          1940
        ],
        [
          1974,
          2010
        ],
        [
          2014,
          2018
        ],
        [
          2022,
          2072
        ],
        [
          2076,
          2102
        ],
        [
          2177,
          2200
        ],
        [
          2291,
          2332
        ],
        [
          2370,
          2386
        ],
        [
          2406,
          2547
        ],
        [
          2607,
          2639
        ],
        [
          2690,
          2709
        ],
        [
          2742,
          2773
        ],
        [
          2808,
          2839
        ],
        [
          2852,
          2889
        ],
        [
          2915,
          2931
        ],
        [
          2937,
          2973
        ],
        [
          2992,
          3023
        ],
        [
          3029,
          3072
        ],
        [
          3113,
          3148
        ],
        [
          3173,
          3194
        ],
        [
          3220,
          3249
        ],
        [
          3404,
          3430
        ],
        [
          3735,
          3773
        ],
        [
          3949,
          4034
        ],
        [
          4075,
          4123
        ],
        [
          4123,
          4127
        ],
        [
          4127,
          4193
        ],
        [
          4193,
          4253
        ],
        [
          4253,
          4257
        ],
        [
          4257,
          4279
        ],
        [
          4279,
          4283
        ],
        [
          4283,
          4315
        ],
        [
          4315,
          4350
        ],
        [
          4350,
          4354
        ],
        [
          4354,
          4369
        ],
        [
          4369,
          4373
        ],
        [
          4373,
          4385
        ],
        [
          4385,
          4435
        ],
        [
          4435,
          4497
        ],
        [
          4497,
          4554
        ],
        [
          4554,
          4593
        ],
        [
          4593,
          4601
        ],
        [
          4643,
          4673
        ],
        [
          4749,
          4793
        ],
        [
          4821,
          4865
        ],
        [
          4871,
          4896
        ],
        [
          4939,
          4975
        ],
        [
          4981,
          5016
        ],
        [
          5036,
          5062
        ],
        [
          5066,
          5114
        ],
        [
          5114,
          5118
        ],
        [
          5118,
          5187
        ],
        [
          5253,
          5289
        ],
        [
          5315,
          5325
        ],
        [
          5331,
          5364
        ],
        [
          5393,
          5428
        ],
        [
          5464,
          5494
        ],
        [
          5500,
          5540
        ],
        [
          5570,
          5578
        ],
        [
          5698,
          5736
        ],
        [
          5740,
          5744
        ],
        [
          5748,
          5764
        ],
        [
          5768,
          5772
        ],
        [
          5776,
          5830
        ],
        [
          5834,
          5838
        ],
        [
          5842,
          5856
        ],
        [
          5860,
          5864
        ],
        [
          5868,
          5920
        ],
        [
          6016,
          6034
        ],
        [
          6064,
          6085
        ],
        [
          6196,
          6224
        ],
        [
          6246,
          6290
        ],
        [
          6294,
          6298
        ],
        [
          6302,
          6355
        ],
        [
          6359,
          6417
        ],
        [
          6421,
          6425
        ],
        [
          6429,
          6445
        ],
        [
          6449,
          6453
        ],
        [
          6457,
          6504
        ],
        [
          6508,
          6512
        ],
        [
          6516,
          6531
        ],
        [
          6535,
          6539
        ],
        [
          6543,
          6555
        ],
        [
          6559,
          6608
        ],
        [
          6612,
          6648
        ],
        [
          6652,
          6661
        ],
        [
          6665,
          6673
        ],
        [
          6841,
          6859
        ],
        [
          6871,
          7146
        ],
        [
          7258,
          7282
        ],
        [
          7292,
          7321
        ],
        [
          7492,
          7516
        ],
        [
          7584,
          7626
        ],
        [
          7712,
          7737
        ],
        [
          7914,
          7936
        ],
        [
          7989,
          8014
        ],
        [
          8164,
          8187
        ],
        [
          8201,
          8234
        ],
        [
          8594,
          8620
        ],
        [
          8632,
          8673
        ],
        [
          8677,
          8681
        ],
        [
          8685,
          8739
        ],
        [
          8743,
          8783
        ],
        [
          8787,
          8791
        ],
        [
          8795,
          8811
        ],
        [
          8815,
          8819
        ],
        [
          8823,
          8866
        ],
        [
          8870,
          8874
        ],
        [
          8878,
          8892
        ],
        [
          8896,
          8900
        ],
        [
          8904,
          8953
        ],
        [
          8957,
          8961
        ],
        [
          8965,
          8989
        ],
        [
          8993,
          8997
        ],
        [
          9001,
          9060
        ],
        [
          9064,
          9100
        ],
        [
          9420,
          9470
        ],
        [
          9615,
          9644
        ],
        [
          9798,
          9816
        ],
        [
          9872,
          9898
        ],
        [
          10128,
          10161
        ],
        [
          10317,
          10355
        ],
        [
          10466,
          10531
        ],
        [
          10556,
          10587
        ],
        [
          10613,
          10726
        ],
        [
          10829,
          10860
        ],
        [
          11162,
          11177
        ],
        [
          11235,
          11251
        ],
        [
          11435,
          11463
        ],
        [
          11612,
          11646
        ],
        [
          11713,
          11752
        ],
        [
          11772,
          11801
        ],
        [
          11885,
          11916
        ],
        [
          11928,
          11962
        ],
        [
          11966,
          11970
        ],
        [
          11974,
          12033
        ],
        [
          12037,
          12096
        ],
        [
          12192,
          12208
        ],
        [
          12220,
          12377
        ],
        [
          12515,
          12538
        ],
        [
          12548,
          12600
        ],
        [
          12600,
          12604
        ],
        [
          12604,
          12659
        ],
        [
          12659,
          12709
        ],
        [
          12709,
          12713
        ],
        [
          12713,
          12726
        ],
        [
          12726,
          12730
        ],
        [
          12730,
          12786
        ],
        [
          12786,
          12844
        ],
        [
          12895,
          12948
        ],
        [
          12952,
          12956
        ],
        [
          12960,
          12973
        ],
        [
          12977,
          12981
        ],
        [
          12985,
          13018
        ],
        [
          13022,
          13070
        ],
        [
          13074,
          13129
        ],
        [
          13133,
          13186
        ],
        [
          13190,
          13194
        ],
        [
          13198,
          13214
        ],
        [
          13218,
          13222
        ],
        [
          13226,
          13260
        ],
        [
          13264,
          13302
        ],
        [
          13306,
          13310
        ],
        [
          13314,
          13328
        ],
        [
          13332,
          13336
        ],
        [
          13340,
          13365
        ],
        [
          13467,
          13492
        ],
        [
          13525,
          13571
        ],
        [
          13705,
          13734
        ],
        [
          13755,
          13776
        ],
        [
          13796,
          13821
        ],
        [
          13882,
          13904
        ],
        [
          13984,
          13996
        ],
        [
          14025,
          14047
        ],
        [
          14059,
          14106
        ],
        [
          14110,
          14114
        ],
        [
          14118,
          14173
        ],
        [
          14177,
          14226
        ],
        [
          14230,
          14234
        ],
        [
          14238,
          14251
        ],
        [
          14255,
          14259
        ],
        [
          14263,
          14315
        ],
        [
          14319,
          14362
        ],
        [
          14366,
          14409
        ],
        [
          14413,
          14458
        ],
        [
          14462,
          14503
        ],
        [
          14507,
          14511
        ],
        [
          14515,
          14533
        ],
        [
          14537,
          14541
        ],
        [
          14545,
          14597
        ],
        [
          14601,
          14658
        ],
        [
          14737,
          14776
        ],
        [
          14838,
          14892
        ],
        [
          14933,
          14984
        ],
        [
          15184,
          15196
        ],
        [
          15249,
          15274
        ],
        [
          15346,
          15369
        ],
        [
          15485,
          15528
        ],
        [
          15608,
          15789
        ],
        [
          15868,
          15885
        ],
        [
          15928,
          15971
        ],
        [
          16115,
          16173
        ],
        [
          16181,
          16185
        ],
        [
          16193,
          16237
        ],
        [
          16371,
          16407
        ],
        [
          16528,
          16559
        ],
        [
          16665,
          16687
        ],
        [
          16707,
          16757
        ],
        [
          16757,
          16761
        ],
        [
          16761,
          16812
        ],
        [
          16812,
          16867
        ],
        [
          16868,
          16915
        ],
        [
          16915,
          16919
        ],
        [
          16919,
          16933
        ],
        [
          16933,
          16937
        ],
        [
          16937,
          16949
        ],
        [
          16949,
          16982
        ],
        [
          16982,
          17006
        ],
        [
          17006,
          17027
        ],
        [
          17027,
          17035
        ],
        [
          17035,
          17043
        ],
        [
          17201,
          17230
        ],
        [
          17379,
          17396
        ],
        [
          17491,
          17526
        ],
        [
          17659,
          17685
        ],
        [
          17810,
          17831
        ],
        [
          17861,
          17888
        ],
        [
          17947,
          17975
        ],
        [
          17991,
          17995
        ],
        [
          18011,
          18024
        ],
        [
          18040,
          18044
        ],
        [
          18060,
          18105
        ],
        [
          18525,
          18567
        ],
        [
          18734,
          18775
        ],
        [
          18775,
          18779
        ],
        [
          18779,
          18838
        ],
        [
          18838,
          18873
        ],
        [
          19144,
          19167
        ],
        [
          19221,
          19256
        ],
        [
          19483,
          19529
        ],
        [
          19529,
          19533
        ],
        [
          19533,
          19591
        ],
        [
          19591,
          19636
        ],
        [
          19684,
          19731
        ],
        [
          19863,
          19885
        ],
        [
          19986,
          20018
        ],
        [
          20063,
          20087
        ],
        [
          20099,
          20138
        ],
        [
          20451,
          20480
        ],
        [
          20534,
          20562
        ],
        [
          20574,
          20630
        ],
        [
          20768,
          20805
        ],
        [
          20895,
          20921
        ],
        [
          21036,
          21049
        ],
        [
          21268,
          21289
        ],
        [
          21301,
          21456
        ],
        [
          21604,
          21636
        ],
        [
          21731,
          21753
        ],
        [
          21867,
          21881
        ],
        [
          21973,
          22002
        ],
        [
          22014,
          22078
        ],
        [
          22159,
          22171
        ],
        [
          22342,
          22384
        ],
        [
          22418,
          22456
        ],
        [
          22466,
          22489
        ],
        [
          22608,
          22626
        ],
        [
          22645,
          22662
        ],
        [
          22727,
          22759
        ],
        [
          22771,
          22810
        ],
        [
          22961,
          22984
        ],
        [
          23065,
          23097
        ],
        [
          23136,
          23160
        ],
        [
          23241,
          23276
        ],
        [
          23315,
          23343
        ],
        [
          23355,
          23402
        ],
        [
          23533,
          23554
        ],
        [
          23655,
          23677
        ],
        [
          23797,
          23845
        ],
        [
          23874,
          23899
        ],
        [
          23911,
          24080
        ],
        [
          24142,
          24170
        ],
        [
          24253,
          24286
        ],
        [
          24508,
          24531
        ],
        [
          24652,
          24686
        ],
        [
          24811,
          24841
        ],
        [
          24864,
          24888
        ],
        [
          25065,
          25091
        ],
        [
          25199,
          25232
        ],
        [
          25242,
          25258
        ],
        [
          25353,
          25380
        ],
        [
          25426,
          25452
        ]
      ],
      "content_length": 25460,
      "difficulty": "Some(Zen)",
      "end_line": 785,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 1
    },
    {
      "code_content": "mod tests {\n    use super::*;\n\n    /// Test the basic configuration functionality\n    #[test]\n    fn test_config_defaults() {\n        let config = Config::default();",
      "comment_ranges": [
        [
          35,
          82
        ]
      ],
      "content_length": 165,
      "difficulty": "Some(Easy)",
      "end_line": 620,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 614
    },
    {
      "code_content": "mod tests {\n    use super::*;\n\n    /// Test the basic configuration functionality\n    #[test]\n    fn test_config_defaults() {\n        let config = Config::default();\n        assert_eq!(config.max_connections, 10); // Check default value\n        assert_eq!(config.timeout.as_secs(), DEFAULT_TIMEOUT);",
      "comment_ranges": [
        [
          35,
          82
        ],
        [
          214,
          236
        ]
      ],
      "content_length": 299,
      "difficulty": "Some(Normal)",
      "end_line": 622,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 614
    },
    {
      "code_content": "mod tests {\n    use super::*;\n\n    /// Test the basic configuration functionality\n    #[test]\n    fn test_config_defaults() {\n        let config = Config::default();\n        assert_eq!(config.max_connections, 10); // Check default value\n        assert_eq!(config.timeout.as_secs(), DEFAULT_TIMEOUT);\n        assert!(!config.debug_mode); /* Should be false by default */\n        assert!(config.headers.is_empty()); // No headers by default\n    }\n\n    /* Test error formatting and display */\n    #[test]\n    fn test_error_display() {\n        let network_error = AppError::NetworkError {\n            code: 404,\n            message: \"Not Found\".to_string(),\n            retry_after: Some(60),\n        };\n\n        let error_string = network_error.to_string();\n        assert!(error_string.contains(\"404\")); // Should contain status code\n        assert!(error_string.contains(\"Not Found\")); /* Should contain message */\n    }",
      "comment_ranges": [
        [
          35,
          82
        ],
        [
          214,
          236
        ],
        [
          337,
          369
        ],
        [
          414,
          438
        ],
        [
          450,
          489
        ],
        [
          802,
          831
        ],
        [
          885,
          913
        ]
      ],
      "content_length": 919,
      "difficulty": "Some(Hard)",
      "end_line": 640,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 614
    },
    {
      "code_content": "mod tests {\n    use super::*;\n\n    /// Test the basic configuration functionality\n    #[test]\n    fn test_config_defaults() {\n        let config = Config::default();\n        assert_eq!(config.max_connections, 10); // Check default value\n        assert_eq!(config.timeout.as_secs(), DEFAULT_TIMEOUT);\n        assert!(!config.debug_mode); /* Should be false by default */\n        assert!(config.headers.is_empty()); // No headers by default\n    }\n\n    /* Test error formatting and display */\n    #[test]\n    fn test_error_display() {\n        let network_error = AppError::NetworkError {\n            code: 404,\n            message: \"Not Found\".to_string(),\n            retry_after: Some(60),\n        };\n\n        let error_string = network_error.to_string();\n        assert!(error_string.contains(\"404\")); // Should contain status code\n        assert!(error_string.contains(\"Not Found\")); /* Should contain message */\n    }\n\n    /// Test the processing pipeline with simple operations\n    #[tokio::test]\n    async fn test_pipeline_basic() {\n        let mut pipeline = ProcessingPipeline::<String, String>::new(2);\n\n        // Add stages that transform the data\n        pipeline.add_stage(Box::new(|data: String| {\n            Ok(data.to_uppercase()) /* Convert to uppercase */\n        }));\n\n        pipeline.add_stage(Box::new(|data: String| {\n            Ok(format!(\"Processed: {}\", data)) // Add prefix\n        }));\n\n        let result = pipeline.process(\"hello world\".to_string()).await;\n        assert!(result.is_ok());\n\n        let processed = result.unwrap();\n        assert_eq!(processed, \"Processed: HELLO WORLD\"); /* Expected result */\n    }\n\n    /**\n     * Test pipeline error handling\n     *\n     * This test verifies that errors in pipeline stages\n     * are properly propagated and handled.\n     */\n    #[tokio::test]\n    async fn test_pipeline_error_handling() {\n        let mut pipeline = ProcessingPipeline::<String, String>::new(1);\n\n        // Add a stage that always fails\n        pipeline.add_stage(Box::new(|_data: String| {\n            Err(AppError::TimeoutError) /* Simulate failure */\n        }));\n\n        let result = pipeline.process(\"test\".to_string()).await;\n        assert!(result.is_err()); // Should fail\n\n        let error = result.unwrap_err();\n        matches!(error, AppError::TimeoutError); /* Should be timeout error */\n    }\n\n    /// Test unsafe operations (with careful safety considerations)\n    #[test]\n    fn test_unsafe_checksum() {\n        let data = b\"Hello, world!\"; // Test data\n        let checksum = unsafe {\n            unsafe_operations::fast_checksum(\n                data.as_ptr(),\n                data.len()\n            )\n        };\n\n        // Verify checksum is calculated correctly\n        assert_ne!(checksum, 0); /* Should not be zero for this data */\n\n        // Test with empty data\n        let empty_checksum = unsafe {\n            unsafe_operations::fast_checksum(\n                std::ptr::null(), /* Null pointer */\n                0 /* Zero length */\n            )\n        };\n        assert_eq!(empty_checksum, 0); // Should be zero for empty data\n    }\n\n    /* Test lock-free counter operations */\n    #[test]\n    fn test_lock_free_counter() {\n        let counter = unsafe_operations::LockFreeCounter::new();\n\n        assert_eq!(counter.get(), 0); // Should start at zero\n\n        let old_value = counter.increment();\n        assert_eq!(old_value, 0); /* Previous value should be 0 */\n        assert_eq!(counter.get(), 1); // New value should be 1\n\n        let reset_value = counter.reset();\n        assert_eq!(reset_value, 1); // Should return the previous value\n        assert_eq!(counter.get(), 0); /* Should be back to zero */\n    }\n\n    /// Benchmark test for performance measurement\n    #[test]\n    fn test_performance_benchmark() {\n        let iterations = 1_000_000;\n        let start = Instant::now();\n\n        // Simulate some work\n        let mut sum = 0u64;\n        for i in 0..iterations {\n            sum = sum.wrapping_add(i); /* Prevent overflow */\n        }\n\n        let duration = start.elapsed();\n        println!(\"Benchmark completed in {:?}\", duration);\n\n        // Verify the computation was not optimized away\n        assert_ne!(sum, 0); // Sum should not be zero\n    }\n\n    /**\n     * Integration test that combines multiple components\n     *\n     * This test verifies that different parts of the system\n     * work together correctly.\n     */\n    #[tokio::test]\n    async fn test_integration() {\n        // Create a complex pipeline\n        let mut pipeline = ProcessingPipeline::<String, String>::new(4);\n\n        // Add multiple processing stages\n        pipeline.add_stage(Box::new(|data: String| {\n            if data.is_empty() {\n                Err(AppError::ConfigError(\"Empty input\".to_string()))\n            } else {\n                Ok(data.trim().to_string()) /* Remove whitespace */\n            }\n        }));\n\n        pipeline.add_stage(Box::new(|data: String| {\n            Ok(data.replace(\" \", \"_\")) // Replace spaces with underscores\n        }));\n\n        pipeline.add_stage(Box::new(|data: String| {\n            Ok(format!(\"final_{}\", data.to_lowercase())) /* Add prefix and lowercase */\n        }));\n\n        // Test with valid input\n        let result = pipeline.process(\"  Hello World  \".to_string()).await;\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"final_hello_world\");\n\n        // Test with invalid input\n        let error_result = pipeline.process(\"\".to_string()).await;\n        assert!(error_result.is_err()); /* Should fail for empty input */\n\n        // Check metrics\n        let metrics = pipeline.get_metrics();\n        assert_eq!(metrics.total_processed, 1); // One successful operation\n        assert_eq!(metrics.total_failed, 1); /* One failed operation */\n    }\n}",
      "comment_ranges": [
        [
          35,
          82
        ],
        [
          214,
          236
        ],
        [
          337,
          369
        ],
        [
          414,
          438
        ],
        [
          450,
          489
        ],
        [
          802,
          831
        ],
        [
          885,
          913
        ],
        [
          925,
          981
        ],
        [
          1119,
          1156
        ],
        [
          1246,
          1272
        ],
        [
          1387,
          1400
        ],
        [
          1619,
          1640
        ],
        [
          1652,
          1807
        ],
        [
          1955,
          1987
        ],
        [
          2082,
          2104
        ],
        [
          2218,
          2232
        ],
        [
          2324,
          2353
        ],
        [
          2365,
          2429
        ],
        [
          2510,
          2522
        ],
        [
          2693,
          2735
        ],
        [
          2769,
          2807
        ],
        [
          2817,
          2840
        ],
        [
          2959,
          2977
        ],
        [
          2996,
          3013
        ],
        [
          3078,
          3110
        ],
        [
          3122,
          3161
        ],
        [
          3312,
          3335
        ],
        [
          3416,
          3448
        ],
        [
          3487,
          3511
        ],
        [
          3592,
          3627
        ],
        [
          3666,
          3694
        ],
        [
          3706,
          3753
        ],
        [
          3884,
          3905
        ],
        [
          4006,
          4028
        ],
        [
          4148,
          4196
        ],
        [
          4225,
          4250
        ],
        [
          4262,
          4431
        ],
        [
          4493,
          4521
        ],
        [
          4604,
          4637
        ],
        [
          4859,
          4882
        ],
        [
          5003,
          5037
        ],
        [
          5162,
          5192
        ],
        [
          5215,
          5239
        ],
        [
          5416,
          5442
        ],
        [
          5550,
          5583
        ],
        [
          5593,
          5609
        ],
        [
          5704,
          5731
        ],
        [
          5777,
          5803
        ]
      ],
      "content_length": 5811,
      "difficulty": "Some(Wild)",
      "end_line": 785,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 614
    },
    {
      "code_content": "pub mod unsafe_operations {\n    use super::*;",
      "comment_ranges": [],
      "content_length": 45,
      "difficulty": "Some(Easy)",
      "end_line": 394,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 392
    },
    {
      "code_content": "pub mod unsafe_operations {\n    use super::*;\n\n    /// Raw memory manipulation for zero-copy operations\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure that:\n    /// - The pointer is valid and properly aligned\n    /// - The data lives at least as long as the operation\n    /// - No other code modifies the memory concurrently\n    ///\n    /// # Arguments\n    ///\n    /// * `ptr` - Raw pointer to data\n    /// * `len` - Length of data in bytes\n    ///\n    /// # Returns\n    ///\n    /// Checksum of the data\n    pub unsafe fn fast_checksum(ptr: *const u8, len: usize) -> u32 {\n        let mut checksum = 0u32; // Initialize accumulator\n        let mut i = 0;\n\n        /* Process 4 bytes at a time for efficiency */\n        while i + 4 <= len {\n            let chunk = ptr.add(i) as *const u32;",
      "comment_ranges": [
        [
          51,
          104
        ],
        [
          108,
          112
        ],
        [
          116,
          129
        ],
        [
          133,
          137
        ],
        [
          141,
          174
        ],
        [
          178,
          226
        ],
        [
          230,
          285
        ],
        [
          289,
          342
        ],
        [
          346,
          350
        ],
        [
          354,
          370
        ],
        [
          374,
          378
        ],
        [
          382,
          416
        ],
        [
          420,
          458
        ],
        [
          462,
          466
        ],
        [
          470,
          484
        ],
        [
          488,
          492
        ],
        [
          496,
          521
        ],
        [
          623,
          648
        ],
        [
          681,
          727
        ]
      ],
      "content_length": 806,
      "difficulty": "Some(Normal)",
      "end_line": 418,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 392
    },
    {
      "code_content": "pub mod unsafe_operations {\n    use super::*;\n\n    /// Raw memory manipulation for zero-copy operations\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure that:\n    /// - The pointer is valid and properly aligned\n    /// - The data lives at least as long as the operation\n    /// - No other code modifies the memory concurrently\n    ///\n    /// # Arguments\n    ///\n    /// * `ptr` - Raw pointer to data\n    /// * `len` - Length of data in bytes\n    ///\n    /// # Returns\n    ///\n    /// Checksum of the data\n    pub unsafe fn fast_checksum(ptr: *const u8, len: usize) -> u32 {\n        let mut checksum = 0u32; // Initialize accumulator\n        let mut i = 0;\n\n        /* Process 4 bytes at a time for efficiency */\n        while i + 4 <= len {\n            let chunk = ptr.add(i) as *const u32;\n            checksum = checksum.wrapping_add(*chunk); // Add without overflow check\n            i += 4; // Move to next chunk\n        }\n\n        // Handle remaining bytes\n        while i < len {\n            let byte = *ptr.add(i); /* Read single byte */\n            checksum = checksum.wrapping_add(byte as u32);\n            i += 1; // Next byte\n        }\n\n        checksum // Return final result\n    }\n\n    /// Direct memory copy without bounds checking\n    ///\n    /// This function performs a raw memory copy operation\n    /// without any safety checks for maximum speed.\n    ///\n    /// # Safety\n    ///\n    /// Extremely dangerous! The caller must guarantee:\n    /// - Both pointers are valid and non-null\n    /// - Source and destination don't overlap\n    /// - Both regions have at least `len` bytes\n    /// - Proper alignment for the data type\n    ///\n    /// # Performance\n    ///\n    /// This is faster than `std::ptr::copy` because it\n    /// skips all safety checks and uses optimized assembly.\n    pub unsafe fn raw_copy(src: *const u8, dst: *mut u8, len: usize) {\n        // Use platform-specific optimized copy\n        #[cfg(target_arch = \"x86_64\")]\n        {\n            /* x86_64 optimized version using SIMD instructions */\n            let mut i = 0;\n\n            // Process 32 bytes at a time with AVX if available\n            while i + 32 <= len {\n                let src_chunk = src.add(i) as *const [u8; 32];\n                let dst_chunk = dst.add(i) as *mut [u8; 32];",
      "comment_ranges": [
        [
          51,
          104
        ],
        [
          108,
          112
        ],
        [
          116,
          129
        ],
        [
          133,
          137
        ],
        [
          141,
          174
        ],
        [
          178,
          226
        ],
        [
          230,
          285
        ],
        [
          289,
          342
        ],
        [
          346,
          350
        ],
        [
          354,
          370
        ],
        [
          374,
          378
        ],
        [
          382,
          416
        ],
        [
          420,
          458
        ],
        [
          462,
          466
        ],
        [
          470,
          484
        ],
        [
          488,
          492
        ],
        [
          496,
          521
        ],
        [
          623,
          648
        ],
        [
          681,
          727
        ],
        [
          861,
          890
        ],
        [
          911,
          932
        ],
        [
          952,
          977
        ],
        [
          1038,
          1060
        ],
        [
          1140,
          1152
        ],
        [
          1181,
          1203
        ],
        [
          1215,
          1262
        ],
        [
          1266,
          1270
        ],
        [
          1274,
          1329
        ],
        [
          1333,
          1382
        ],
        [
          1386,
          1390
        ],
        [
          1394,
          1407
        ],
        [
          1411,
          1415
        ],
        [
          1419,
          1471
        ],
        [
          1475,
          1518
        ],
        [
          1522,
          1565
        ],
        [
          1569,
          1614
        ],
        [
          1618,
          1659
        ],
        [
          1663,
          1667
        ],
        [
          1671,
          1689
        ],
        [
          1693,
          1697
        ],
        [
          1701,
          1753
        ],
        [
          1757,
          1814
        ],
        [
          1893,
          1932
        ],
        [
          1994,
          2048
        ],
        [
          2089,
          2140
        ]
      ],
      "content_length": 2298,
      "difficulty": "Some(Hard)",
      "end_line": 460,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 392
    },
    {
      "code_content": "pub mod unsafe_operations {\n    use super::*;\n\n    /// Raw memory manipulation for zero-copy operations\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure that:\n    /// - The pointer is valid and properly aligned\n    /// - The data lives at least as long as the operation\n    /// - No other code modifies the memory concurrently\n    ///\n    /// # Arguments\n    ///\n    /// * `ptr` - Raw pointer to data\n    /// * `len` - Length of data in bytes\n    ///\n    /// # Returns\n    ///\n    /// Checksum of the data\n    pub unsafe fn fast_checksum(ptr: *const u8, len: usize) -> u32 {\n        let mut checksum = 0u32; // Initialize accumulator\n        let mut i = 0;\n\n        /* Process 4 bytes at a time for efficiency */\n        while i + 4 <= len {\n            let chunk = ptr.add(i) as *const u32;\n            checksum = checksum.wrapping_add(*chunk); // Add without overflow check\n            i += 4; // Move to next chunk\n        }\n\n        // Handle remaining bytes\n        while i < len {\n            let byte = *ptr.add(i); /* Read single byte */\n            checksum = checksum.wrapping_add(byte as u32);\n            i += 1; // Next byte\n        }\n\n        checksum // Return final result\n    }\n\n    /// Direct memory copy without bounds checking\n    ///\n    /// This function performs a raw memory copy operation\n    /// without any safety checks for maximum speed.\n    ///\n    /// # Safety\n    ///\n    /// Extremely dangerous! The caller must guarantee:\n    /// - Both pointers are valid and non-null\n    /// - Source and destination don't overlap\n    /// - Both regions have at least `len` bytes\n    /// - Proper alignment for the data type\n    ///\n    /// # Performance\n    ///\n    /// This is faster than `std::ptr::copy` because it\n    /// skips all safety checks and uses optimized assembly.\n    pub unsafe fn raw_copy(src: *const u8, dst: *mut u8, len: usize) {\n        // Use platform-specific optimized copy\n        #[cfg(target_arch = \"x86_64\")]\n        {\n            /* x86_64 optimized version using SIMD instructions */\n            let mut i = 0;\n\n            // Process 32 bytes at a time with AVX if available\n            while i + 32 <= len {\n                let src_chunk = src.add(i) as *const [u8; 32];\n                let dst_chunk = dst.add(i) as *mut [u8; 32];\n                *dst_chunk = *src_chunk; // Bulk copy\n                i += 32;\n            }\n\n            // Handle remaining bytes\n            while i < len {\n                *dst.add(i) = *src.add(i); /* Byte-by-byte copy */\n                i += 1;\n            }\n        }\n\n        #[cfg(not(target_arch = \"x86_64\"))]\n        {\n            // Generic fallback for other architectures\n            std::ptr::copy_nonoverlapping(src, dst, len);\n        }\n    }\n\n    /**\n     * Lock-free atomic operations for high-performance counters\n     *\n     * This structure provides thread-safe counters without\n     * the overhead of mutex locking.\n     */\n    pub struct LockFreeCounter {\n        value: std::sync::atomic::AtomicU64, // Atomic counter\n    }\n\n    impl LockFreeCounter {\n        /// Creates a new counter starting at zero\n        pub fn new() -> Self {\n            Self {\n                value: std::sync::atomic::AtomicU64::new(0),\n            }\n        }\n\n        /// Increments the counter and returns the previous value\n        ///\n        /// This operation is atomic and lock-free.\n        pub fn increment(&self) -> u64 {\n            self.value.fetch_add(1, std::sync::atomic::Ordering::Relaxed)\n        }\n\n        /* Gets the current counter value */\n        pub fn get(&self) -> u64 {\n            self.value.load(std::sync::atomic::Ordering::Relaxed)\n        }\n\n        /// Resets the counter to zero\n        pub fn reset(&self) -> u64 {\n            self.value.swap(0, std::sync::atomic::Ordering::Relaxed) /* Return old value */\n        }\n    }\n}",
      "comment_ranges": [
        [
          51,
          104
        ],
        [
          108,
          112
        ],
        [
          116,
          129
        ],
        [
          133,
          137
        ],
        [
          141,
          174
        ],
        [
          178,
          226
        ],
        [
          230,
          285
        ],
        [
          289,
          342
        ],
        [
          346,
          350
        ],
        [
          354,
          370
        ],
        [
          374,
          378
        ],
        [
          382,
          416
        ],
        [
          420,
          458
        ],
        [
          462,
          466
        ],
        [
          470,
          484
        ],
        [
          488,
          492
        ],
        [
          496,
          521
        ],
        [
          623,
          648
        ],
        [
          681,
          727
        ],
        [
          861,
          890
        ],
        [
          911,
          932
        ],
        [
          952,
          977
        ],
        [
          1038,
          1060
        ],
        [
          1140,
          1152
        ],
        [
          1181,
          1203
        ],
        [
          1215,
          1262
        ],
        [
          1266,
          1270
        ],
        [
          1274,
          1329
        ],
        [
          1333,
          1382
        ],
        [
          1386,
          1390
        ],
        [
          1394,
          1407
        ],
        [
          1411,
          1415
        ],
        [
          1419,
          1471
        ],
        [
          1475,
          1518
        ],
        [
          1522,
          1565
        ],
        [
          1569,
          1614
        ],
        [
          1618,
          1659
        ],
        [
          1663,
          1667
        ],
        [
          1671,
          1689
        ],
        [
          1693,
          1697
        ],
        [
          1701,
          1753
        ],
        [
          1757,
          1814
        ],
        [
          1893,
          1932
        ],
        [
          1994,
          2048
        ],
        [
          2089,
          2140
        ],
        [
          2340,
          2352
        ],
        [
          2405,
          2430
        ],
        [
          2502,
          2525
        ],
        [
          2641,
          2684
        ],
        [
          2764,
          2945
        ],
        [
          3024,
          3041
        ],
        [
          3084,
          3127
        ],
        [
          3271,
          3329
        ],
        [
          3337,
          3341
        ],
        [
          3349,
          3393
        ],
        [
          3527,
          3563
        ],
        [
          3684,
          3715
        ],
        [
          3821,
          3843
        ]
      ],
      "content_length": 3861,
      "difficulty": "Some(Wild)",
      "end_line": 514,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 392
    },
    {
      "code_content": "    pub async fn process_batch(&self, items: Vec<T>) -> Vec<Result<T, AppError>> {",
      "comment_ranges": [],
      "content_length": 82,
      "difficulty": "Some(Easy)",
      "end_line": 292,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 292
    },
    {
      "code_content": "    pub async fn process_batch(&self, items: Vec<T>) -> Vec<Result<T, AppError>> {\n        use std::sync::atomic::{AtomicUsize, Ordering};\n\n        let results = Arc::new(Mutex::new(Vec::with_capacity(items.len())));",
      "comment_ranges": [],
      "content_length": 216,
      "difficulty": "Some(Normal)",
      "end_line": 295,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 292
    },
    {
      "code_content": "    pub async fn process_batch(&self, items: Vec<T>) -> Vec<Result<T, AppError>> {\n        use std::sync::atomic::{AtomicUsize, Ordering};\n\n        let results = Arc::new(Mutex::new(Vec::with_capacity(items.len())));\n        let completed = Arc::new(AtomicUsize::new(0));\n        let total_items = items.len();\n\n        /* Process items in chunks to limit concurrency */\n        let chunk_size = (total_items / self.max_concurrency).max(1);\n        let chunks: Vec<_> = items.chunks(chunk_size).collect();\n\n        // Spawn tasks for each chunk\n        let mut handles = Vec::new();",
      "comment_ranges": [
        [
          320,
          370
        ],
        [
          515,
          544
        ]
      ],
      "content_length": 582,
      "difficulty": "Some(Hard)",
      "end_line": 305,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 292
    },
    {
      "code_content": "    pub async fn process_batch(&self, items: Vec<T>) -> Vec<Result<T, AppError>> {\n        use std::sync::atomic::{AtomicUsize, Ordering};\n\n        let results = Arc::new(Mutex::new(Vec::with_capacity(items.len())));\n        let completed = Arc::new(AtomicUsize::new(0));\n        let total_items = items.len();\n\n        /* Process items in chunks to limit concurrency */\n        let chunk_size = (total_items / self.max_concurrency).max(1);\n        let chunks: Vec<_> = items.chunks(chunk_size).collect();\n\n        // Spawn tasks for each chunk\n        let mut handles = Vec::new();\n\n        for (chunk_index, chunk) in chunks.into_iter().enumerate() {\n            let chunk_data = chunk.to_vec(); // Clone the chunk\n            let pipeline_stages = self.stages.clone(); /* Can't clone directly */\n            let results_ref = Arc::clone(&results);\n            let completed_ref = Arc::clone(&completed);\n\n            let handle = tokio::spawn(async move {\n                let mut chunk_results = Vec::new();\n\n                // Process each item in the chunk\n                for item in chunk_data {\n                    let mut current_data = item;\n                    let mut success = true;\n\n                    /* Execute all stages for this item */\n                    for (stage_index, _stage) in pipeline_stages.iter().enumerate() {\n                        // Note: Can't actually call the stage here due to borrow checker\n                        // This is a simplified example\n\n                        /* Simulate stage processing\n                           In real implementation, we'd need a different approach */\n                        if stage_index % 7 == 0 && chunk_index % 3 == 0 {\n                            // Simulate occasional failures\n                            chunk_results.push(Err(AppError::TimeoutError));\n                            success = false;\n                            break;\n                        }\n                    }\n\n                    if success {\n                        chunk_results.push(Ok(current_data)); // Success case\n                    }\n                }\n\n                // Store results\n                {\n                    let mut results_guard = results_ref.lock().unwrap();\n                    results_guard.extend(chunk_results);\n                }\n\n                // Update completion counter\n                completed_ref.fetch_add(chunk_data.len(), Ordering::Relaxed);\n            });\n\n            handles.push(handle);\n        }\n\n        // Wait for all chunks to complete\n        for handle in handles {\n            let _ = handle.await; /* Ignore join errors for simplicity */\n        }\n\n        // Extract and return results\n        let results_guard = results.lock().unwrap();\n        results_guard.clone() // Return the collected results\n    }",
      "comment_ranges": [
        [
          320,
          370
        ],
        [
          515,
          544
        ],
        [
          698,
          716
        ],
        [
          772,
          798
        ],
        [
          1028,
          1061
        ],
        [
          1217,
          1255
        ],
        [
          1366,
          1431
        ],
        [
          1456,
          1487
        ],
        [
          1513,
          1626
        ],
        [
          1729,
          1760
        ],
        [
          2062,
          2077
        ],
        [
          2135,
          2151
        ],
        [
          2335,
          2363
        ],
        [
          2512,
          2546
        ],
        [
          2613,
          2652
        ],
        [
          2672,
          2701
        ],
        [
          2785,
          2816
        ]
      ],
      "content_length": 2822,
      "difficulty": "Some(Wild)",
      "end_line": 361,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 292
    },
    {
      "code_content": "        for (chunk_index, chunk) in chunks.into_iter().enumerate() {",
      "comment_ranges": [],
      "content_length": 68,
      "difficulty": "Some(Easy)",
      "end_line": 306,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 306
    },
    {
      "code_content": "        for (chunk_index, chunk) in chunks.into_iter().enumerate() {\n            let chunk_data = chunk.to_vec(); // Clone the chunk\n            let pipeline_stages = self.stages.clone(); /* Can't clone directly */\n            let results_ref = Arc::clone(&results);\n            let completed_ref = Arc::clone(&completed);",
      "comment_ranges": [
        [
          114,
          132
        ],
        [
          188,
          214
        ]
      ],
      "content_length": 322,
      "difficulty": "Some(Normal)",
      "end_line": 311,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 306
    },
    {
      "code_content": "        for (chunk_index, chunk) in chunks.into_iter().enumerate() {\n            let chunk_data = chunk.to_vec(); // Clone the chunk\n            let pipeline_stages = self.stages.clone(); /* Can't clone directly */\n            let results_ref = Arc::clone(&results);\n            let completed_ref = Arc::clone(&completed);\n\n            let handle = tokio::spawn(async move {\n                let mut chunk_results = Vec::new();\n\n                // Process each item in the chunk\n                for item in chunk_data {\n                    let mut current_data = item;\n                    let mut success = true;\n\n                    /* Execute all stages for this item */\n                    for (stage_index, _stage) in pipeline_stages.iter().enumerate() {\n                        // Note: Can't actually call the stage here due to borrow checker\n                        // This is a simplified example\n\n                        /* Simulate stage processing\n                           In real implementation, we'd need a different approach */\n                        if stage_index % 7 == 0 && chunk_index % 3 == 0 {\n                            // Simulate occasional failures\n                            chunk_results.push(Err(AppError::TimeoutError));\n                            success = false;\n                            break;\n                        }\n                    }",
      "comment_ranges": [
        [
          114,
          132
        ],
        [
          188,
          214
        ],
        [
          444,
          477
        ],
        [
          633,
          671
        ],
        [
          782,
          847
        ],
        [
          872,
          903
        ],
        [
          929,
          1042
        ],
        [
          1145,
          1176
        ]
      ],
      "content_length": 1381,
      "difficulty": "Some(Hard)",
      "end_line": 334,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 306
    },
    {
      "code_content": "        for (chunk_index, chunk) in chunks.into_iter().enumerate() {\n            let chunk_data = chunk.to_vec(); // Clone the chunk\n            let pipeline_stages = self.stages.clone(); /* Can't clone directly */\n            let results_ref = Arc::clone(&results);\n            let completed_ref = Arc::clone(&completed);\n\n            let handle = tokio::spawn(async move {\n                let mut chunk_results = Vec::new();\n\n                // Process each item in the chunk\n                for item in chunk_data {\n                    let mut current_data = item;\n                    let mut success = true;\n\n                    /* Execute all stages for this item */\n                    for (stage_index, _stage) in pipeline_stages.iter().enumerate() {\n                        // Note: Can't actually call the stage here due to borrow checker\n                        // This is a simplified example\n\n                        /* Simulate stage processing\n                           In real implementation, we'd need a different approach */\n                        if stage_index % 7 == 0 && chunk_index % 3 == 0 {\n                            // Simulate occasional failures\n                            chunk_results.push(Err(AppError::TimeoutError));\n                            success = false;\n                            break;\n                        }\n                    }\n\n                    if success {\n                        chunk_results.push(Ok(current_data)); // Success case\n                    }\n                }\n\n                // Store results\n                {\n                    let mut results_guard = results_ref.lock().unwrap();\n                    results_guard.extend(chunk_results);\n                }\n\n                // Update completion counter\n                completed_ref.fetch_add(chunk_data.len(), Ordering::Relaxed);\n            });\n\n            handles.push(handle);\n        }",
      "comment_ranges": [
        [
          114,
          132
        ],
        [
          188,
          214
        ],
        [
          444,
          477
        ],
        [
          633,
          671
        ],
        [
          782,
          847
        ],
        [
          872,
          903
        ],
        [
          929,
          1042
        ],
        [
          1145,
          1176
        ],
        [
          1478,
          1493
        ],
        [
          1551,
          1567
        ],
        [
          1751,
          1779
        ]
      ],
      "content_length": 1918,
      "difficulty": "Some(Wild)",
      "end_line": 351,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 306
    },
    {
      "code_content": "            let handle = tokio::spawn(async move {\n                let mut chunk_results = Vec::new();",
      "comment_ranges": [],
      "content_length": 102,
      "difficulty": "Some(Easy)",
      "end_line": 314,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 312
    },
    {
      "code_content": "            let handle = tokio::spawn(async move {\n                let mut chunk_results = Vec::new();\n\n                // Process each item in the chunk\n                for item in chunk_data {\n                    let mut current_data = item;\n                    let mut success = true;\n\n                    /* Execute all stages for this item */\n                    for (stage_index, _stage) in pipeline_stages.iter().enumerate() {\n                        // Note: Can't actually call the stage here due to borrow checker\n                        // This is a simplified example",
      "comment_ranges": [
        [
          120,
          153
        ],
        [
          309,
          347
        ],
        [
          458,
          523
        ],
        [
          548,
          579
        ]
      ],
      "content_length": 579,
      "difficulty": "Some(Normal)",
      "end_line": 324,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 312
    },
    {
      "code_content": "            let handle = tokio::spawn(async move {\n                let mut chunk_results = Vec::new();\n\n                // Process each item in the chunk\n                for item in chunk_data {\n                    let mut current_data = item;\n                    let mut success = true;\n\n                    /* Execute all stages for this item */\n                    for (stage_index, _stage) in pipeline_stages.iter().enumerate() {\n                        // Note: Can't actually call the stage here due to borrow checker\n                        // This is a simplified example\n\n                        /* Simulate stage processing\n                           In real implementation, we'd need a different approach */\n                        if stage_index % 7 == 0 && chunk_index % 3 == 0 {\n                            // Simulate occasional failures\n                            chunk_results.push(Err(AppError::TimeoutError));\n                            success = false;\n                            break;\n                        }\n                    }\n\n                    if success {\n                        chunk_results.push(Ok(current_data)); // Success case\n                    }\n                }\n\n                // Store results\n                {\n                    let mut results_guard = results_ref.lock().unwrap();\n                    results_guard.extend(chunk_results);\n                }\n\n                // Update completion counter\n                completed_ref.fetch_add(chunk_data.len(), Ordering::Relaxed);\n            })",
      "comment_ranges": [
        [
          120,
          153
        ],
        [
          309,
          347
        ],
        [
          458,
          523
        ],
        [
          548,
          579
        ],
        [
          605,
          718
        ],
        [
          821,
          852
        ],
        [
          1154,
          1169
        ],
        [
          1227,
          1243
        ],
        [
          1427,
          1455
        ]
      ],
      "content_length": 1548,
      "difficulty": "Some(Hard)",
      "end_line": 348,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 312
    },
    {
      "code_content": "            let handle = tokio::spawn(async move {\n                let mut chunk_results = Vec::new();\n\n                // Process each item in the chunk\n                for item in chunk_data {\n                    let mut current_data = item;\n                    let mut success = true;\n\n                    /* Execute all stages for this item */\n                    for (stage_index, _stage) in pipeline_stages.iter().enumerate() {\n                        // Note: Can't actually call the stage here due to borrow checker\n                        // This is a simplified example\n\n                        /* Simulate stage processing\n                           In real implementation, we'd need a different approach */\n                        if stage_index % 7 == 0 && chunk_index % 3 == 0 {\n                            // Simulate occasional failures\n                            chunk_results.push(Err(AppError::TimeoutError));\n                            success = false;\n                            break;\n                        }\n                    }\n\n                    if success {\n                        chunk_results.push(Ok(current_data)); // Success case\n                    }\n                }\n\n                // Store results\n                {\n                    let mut results_guard = results_ref.lock().unwrap();\n                    results_guard.extend(chunk_results);\n                }\n\n                // Update completion counter\n                completed_ref.fetch_add(chunk_data.len(), Ordering::Relaxed);\n            })",
      "comment_ranges": [
        [
          120,
          153
        ],
        [
          309,
          347
        ],
        [
          458,
          523
        ],
        [
          548,
          579
        ],
        [
          605,
          718
        ],
        [
          821,
          852
        ],
        [
          1154,
          1169
        ],
        [
          1227,
          1243
        ],
        [
          1427,
          1455
        ]
      ],
      "content_length": 1548,
      "difficulty": "Some(Wild)",
      "end_line": 348,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 312
    },
    {
      "code_content": "    pub async fn process(&self, mut data: T) -> Result<T, AppError> {\n        let start_time = Instant::now(); // Track processing time",
      "comment_ranges": [
        [
          111,
          135
        ]
      ],
      "content_length": 135,
      "difficulty": "Some(Easy)",
      "end_line": 237,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 235
    },
    {
      "code_content": "    pub async fn process(&self, mut data: T) -> Result<T, AppError> {\n        let start_time = Instant::now(); // Track processing time",
      "comment_ranges": [
        [
          111,
          135
        ]
      ],
      "content_length": 135,
      "difficulty": "Some(Normal)",
      "end_line": 237,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 235
    },
    {
      "code_content": "    pub async fn process(&self, mut data: T) -> Result<T, AppError> {\n        let start_time = Instant::now(); // Track processing time\n\n        // Process through each stage\n        for (index, stage) in self.stages.iter().enumerate() {\n            match stage(data.clone()) {\n                Ok(result) => {\n                    data = result; // Update for next stage\n                },\n                Err(e) => {\n                    /* Log the error with stage information */\n                    eprintln!(\"Stage {} failed: {}\", index, e);\n\n                    // Update failure metrics\n                    if let Ok(mut metrics) = self.metrics.lock() {\n                        metrics.total_failed += 1;\n                    }\n\n                    return Err(e); // Propagate the error\n                },\n            }\n        }\n\n        // Update success metrics\n        let processing_time = start_time.elapsed();\n        if let Ok(mut metrics) = self.metrics.lock() {\n            metrics.total_processed += 1; /* Increment counter */\n\n            // Update average processing time\n            let total_items = metrics.total_processed + metrics.total_failed;",
      "comment_ranges": [
        [
          111,
          135
        ],
        [
          145,
          174
        ],
        [
          345,
          369
        ],
        [
          437,
          479
        ],
        [
          565,
          590
        ],
        [
          767,
          789
        ],
        [
          842,
          867
        ],
        [
          1017,
          1040
        ],
        [
          1054,
          1087
        ]
      ],
      "content_length": 1165,
      "difficulty": "Some(Hard)",
      "end_line": 264,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 235
    },
    {
      "code_content": "    pub async fn process(&self, mut data: T) -> Result<T, AppError> {\n        let start_time = Instant::now(); // Track processing time\n\n        // Process through each stage\n        for (index, stage) in self.stages.iter().enumerate() {\n            match stage(data.clone()) {\n                Ok(result) => {\n                    data = result; // Update for next stage\n                },\n                Err(e) => {\n                    /* Log the error with stage information */\n                    eprintln!(\"Stage {} failed: {}\", index, e);\n\n                    // Update failure metrics\n                    if let Ok(mut metrics) = self.metrics.lock() {\n                        metrics.total_failed += 1;\n                    }\n\n                    return Err(e); // Propagate the error\n                },\n            }\n        }\n\n        // Update success metrics\n        let processing_time = start_time.elapsed();\n        if let Ok(mut metrics) = self.metrics.lock() {\n            metrics.total_processed += 1; /* Increment counter */\n\n            // Update average processing time\n            let total_items = metrics.total_processed + metrics.total_failed;\n            if total_items > 0 {\n                let total_time = metrics.avg_processing_time * (total_items - 1) as u32\n                    + processing_time;\n                metrics.avg_processing_time = total_time / total_items as u32;\n            }\n        }\n\n        Ok(data) // Return processed result\n    }",
      "comment_ranges": [
        [
          111,
          135
        ],
        [
          145,
          174
        ],
        [
          345,
          369
        ],
        [
          437,
          479
        ],
        [
          565,
          590
        ],
        [
          767,
          789
        ],
        [
          842,
          867
        ],
        [
          1017,
          1040
        ],
        [
          1054,
          1087
        ],
        [
          1447,
          1473
        ]
      ],
      "content_length": 1479,
      "difficulty": "Some(Wild)",
      "end_line": 273,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 235
    },
    {
      "code_content": "    async fn test_integration() {\n        // Create a complex pipeline\n        let mut pipeline = ProcessingPipeline::<String, String>::new(4);",
      "comment_ranges": [
        [
          42,
          70
        ]
      ],
      "content_length": 143,
      "difficulty": "Some(Easy)",
      "end_line": 753,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 750
    },
    {
      "code_content": "    async fn test_integration() {\n        // Create a complex pipeline\n        let mut pipeline = ProcessingPipeline::<String, String>::new(4);\n\n        // Add multiple processing stages\n        pipeline.add_stage(Box::new(|data: String| {\n            if data.is_empty() {\n                Err(AppError::ConfigError(\"Empty input\".to_string()))",
      "comment_ranges": [
        [
          42,
          70
        ],
        [
          153,
          186
        ]
      ],
      "content_length": 342,
      "difficulty": "Some(Normal)",
      "end_line": 757,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 750
    },
    {
      "code_content": "    async fn test_integration() {\n        // Create a complex pipeline\n        let mut pipeline = ProcessingPipeline::<String, String>::new(4);\n\n        // Add multiple processing stages\n        pipeline.add_stage(Box::new(|data: String| {\n            if data.is_empty() {\n                Err(AppError::ConfigError(\"Empty input\".to_string()))\n            } else {\n                Ok(data.trim().to_string()) /* Remove whitespace */\n            }\n        }));\n\n        pipeline.add_stage(Box::new(|data: String| {\n            Ok(data.replace(\" \", \"_\")) // Replace spaces with underscores\n        }));\n\n        pipeline.add_stage(Box::new(|data: String| {\n            Ok(format!(\"final_{}\", data.to_lowercase())) /* Add prefix and lowercase */\n        }));\n\n        // Test with valid input\n        let result = pipeline.process(\"  Hello World  \".to_string()).await;\n        assert!(result.is_ok());",
      "comment_ranges": [
        [
          42,
          70
        ],
        [
          153,
          186
        ],
        [
          408,
          431
        ],
        [
          552,
          586
        ],
        [
          711,
          741
        ],
        [
          764,
          788
        ]
      ],
      "content_length": 897,
      "difficulty": "Some(Hard)",
      "end_line": 773,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 750
    },
    {
      "code_content": "    async fn test_integration() {\n        // Create a complex pipeline\n        let mut pipeline = ProcessingPipeline::<String, String>::new(4);\n\n        // Add multiple processing stages\n        pipeline.add_stage(Box::new(|data: String| {\n            if data.is_empty() {\n                Err(AppError::ConfigError(\"Empty input\".to_string()))\n            } else {\n                Ok(data.trim().to_string()) /* Remove whitespace */\n            }\n        }));\n\n        pipeline.add_stage(Box::new(|data: String| {\n            Ok(data.replace(\" \", \"_\")) // Replace spaces with underscores\n        }));\n\n        pipeline.add_stage(Box::new(|data: String| {\n            Ok(format!(\"final_{}\", data.to_lowercase())) /* Add prefix and lowercase */\n        }));\n\n        // Test with valid input\n        let result = pipeline.process(\"  Hello World  \".to_string()).await;\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"final_hello_world\");\n\n        // Test with invalid input\n        let error_result = pipeline.process(\"\".to_string()).await;\n        assert!(error_result.is_err()); /* Should fail for empty input */\n\n        // Check metrics\n        let metrics = pipeline.get_metrics();\n        assert_eq!(metrics.total_processed, 1); // One successful operation\n        assert_eq!(metrics.total_failed, 1); /* One failed operation */\n    }",
      "comment_ranges": [
        [
          42,
          70
        ],
        [
          153,
          186
        ],
        [
          408,
          431
        ],
        [
          552,
          586
        ],
        [
          711,
          741
        ],
        [
          764,
          788
        ],
        [
          965,
          991
        ],
        [
          1099,
          1132
        ],
        [
          1142,
          1158
        ],
        [
          1253,
          1280
        ],
        [
          1326,
          1352
        ]
      ],
      "content_length": 1358,
      "difficulty": "Some(Wild)",
      "end_line": 784,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 750
    },
    {
      "code_content": "                for item in chunk_data {\n                    let mut current_data = item;\n                    let mut success = true;",
      "comment_ranges": [],
      "content_length": 133,
      "difficulty": "Some(Easy)",
      "end_line": 319,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 316
    },
    {
      "code_content": "                for item in chunk_data {\n                    let mut current_data = item;\n                    let mut success = true;\n\n                    /* Execute all stages for this item */\n                    for (stage_index, _stage) in pipeline_stages.iter().enumerate() {\n                        // Note: Can't actually call the stage here due to borrow checker\n                        // This is a simplified example",
      "comment_ranges": [
        [
          155,
          193
        ],
        [
          304,
          369
        ],
        [
          394,
          425
        ]
      ],
      "content_length": 425,
      "difficulty": "Some(Normal)",
      "end_line": 324,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 316
    },
    {
      "code_content": "                for item in chunk_data {\n                    let mut current_data = item;\n                    let mut success = true;\n\n                    /* Execute all stages for this item */\n                    for (stage_index, _stage) in pipeline_stages.iter().enumerate() {\n                        // Note: Can't actually call the stage here due to borrow checker\n                        // This is a simplified example\n\n                        /* Simulate stage processing\n                           In real implementation, we'd need a different approach */\n                        if stage_index % 7 == 0 && chunk_index % 3 == 0 {\n                            // Simulate occasional failures\n                            chunk_results.push(Err(AppError::TimeoutError));\n                            success = false;\n                            break;\n                        }\n                    }\n\n                    if success {\n                        chunk_results.push(Ok(current_data)); // Success case\n                    }\n                }",
      "comment_ranges": [
        [
          155,
          193
        ],
        [
          304,
          369
        ],
        [
          394,
          425
        ],
        [
          451,
          564
        ],
        [
          667,
          698
        ],
        [
          1000,
          1015
        ]
      ],
      "content_length": 1055,
      "difficulty": "Some(Hard)",
      "end_line": 338,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 316
    },
    {
      "code_content": "                for item in chunk_data {\n                    let mut current_data = item;\n                    let mut success = true;\n\n                    /* Execute all stages for this item */\n                    for (stage_index, _stage) in pipeline_stages.iter().enumerate() {\n                        // Note: Can't actually call the stage here due to borrow checker\n                        // This is a simplified example\n\n                        /* Simulate stage processing\n                           In real implementation, we'd need a different approach */\n                        if stage_index % 7 == 0 && chunk_index % 3 == 0 {\n                            // Simulate occasional failures\n                            chunk_results.push(Err(AppError::TimeoutError));\n                            success = false;\n                            break;\n                        }\n                    }\n\n                    if success {\n                        chunk_results.push(Ok(current_data)); // Success case\n                    }\n                }",
      "comment_ranges": [
        [
          155,
          193
        ],
        [
          304,
          369
        ],
        [
          394,
          425
        ],
        [
          451,
          564
        ],
        [
          667,
          698
        ],
        [
          1000,
          1015
        ]
      ],
      "content_length": 1055,
      "difficulty": "Some(Wild)",
      "end_line": 338,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 316
    },
    {
      "code_content": "    pub unsafe fn raw_copy(src: *const u8, dst: *mut u8, len: usize) {\n        // Use platform-specific optimized copy\n        #[cfg(target_arch = \"x86_64\")]\n        {\n            /* x86_64 optimized version using SIMD instructions */\n            let mut i = 0;",
      "comment_ranges": [
        [
          79,
          118
        ],
        [
          180,
          234
        ]
      ],
      "content_length": 261,
      "difficulty": "Some(Easy)",
      "end_line": 456,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 450
    },
    {
      "code_content": "    pub unsafe fn raw_copy(src: *const u8, dst: *mut u8, len: usize) {\n        // Use platform-specific optimized copy\n        #[cfg(target_arch = \"x86_64\")]\n        {\n            /* x86_64 optimized version using SIMD instructions */\n            let mut i = 0;\n\n            // Process 32 bytes at a time with AVX if available\n            while i + 32 <= len {\n                let src_chunk = src.add(i) as *const [u8; 32];\n                let dst_chunk = dst.add(i) as *mut [u8; 32];",
      "comment_ranges": [
        [
          79,
          118
        ],
        [
          180,
          234
        ],
        [
          275,
          326
        ]
      ],
      "content_length": 484,
      "difficulty": "Some(Normal)",
      "end_line": 460,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 450
    },
    {
      "code_content": "    pub unsafe fn raw_copy(src: *const u8, dst: *mut u8, len: usize) {\n        // Use platform-specific optimized copy\n        #[cfg(target_arch = \"x86_64\")]\n        {\n            /* x86_64 optimized version using SIMD instructions */\n            let mut i = 0;\n\n            // Process 32 bytes at a time with AVX if available\n            while i + 32 <= len {\n                let src_chunk = src.add(i) as *const [u8; 32];\n                let dst_chunk = dst.add(i) as *mut [u8; 32];\n                *dst_chunk = *src_chunk; // Bulk copy\n                i += 32;\n            }\n\n            // Handle remaining bytes\n            while i < len {\n                *dst.add(i) = *src.add(i); /* Byte-by-byte copy */\n                i += 1;\n            }\n        }\n\n        #[cfg(not(target_arch = \"x86_64\"))]\n        {\n            // Generic fallback for other architectures\n            std::ptr::copy_nonoverlapping(src, dst, len);\n        }\n    }",
      "comment_ranges": [
        [
          79,
          118
        ],
        [
          180,
          234
        ],
        [
          275,
          326
        ],
        [
          526,
          538
        ],
        [
          591,
          616
        ],
        [
          688,
          711
        ],
        [
          827,
          870
        ]
      ],
      "content_length": 944,
      "difficulty": "Some(Hard)",
      "end_line": 477,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 450
    },
    {
      "code_content": "    pub unsafe fn raw_copy(src: *const u8, dst: *mut u8, len: usize) {\n        // Use platform-specific optimized copy\n        #[cfg(target_arch = \"x86_64\")]\n        {\n            /* x86_64 optimized version using SIMD instructions */\n            let mut i = 0;\n\n            // Process 32 bytes at a time with AVX if available\n            while i + 32 <= len {\n                let src_chunk = src.add(i) as *const [u8; 32];\n                let dst_chunk = dst.add(i) as *mut [u8; 32];\n                *dst_chunk = *src_chunk; // Bulk copy\n                i += 32;\n            }\n\n            // Handle remaining bytes\n            while i < len {\n                *dst.add(i) = *src.add(i); /* Byte-by-byte copy */\n                i += 1;\n            }\n        }\n\n        #[cfg(not(target_arch = \"x86_64\"))]\n        {\n            // Generic fallback for other architectures\n            std::ptr::copy_nonoverlapping(src, dst, len);\n        }\n    }",
      "comment_ranges": [
        [
          79,
          118
        ],
        [
          180,
          234
        ],
        [
          275,
          326
        ],
        [
          526,
          538
        ],
        [
          591,
          616
        ],
        [
          688,
          711
        ],
        [
          827,
          870
        ]
      ],
      "content_length": 944,
      "difficulty": "Some(Wild)",
      "end_line": 477,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 450
    },
    {
      "code_content": "    impl LockFreeCounter {\n        /// Creates a new counter starting at zero\n        pub fn new() -> Self {\n            Self {\n                value: std::sync::atomic::AtomicU64::new(0),\n            }\n        }",
      "comment_ranges": [
        [
          35,
          78
        ]
      ],
      "content_length": 212,
      "difficulty": "Some(Easy)",
      "end_line": 496,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 489
    },
    {
      "code_content": "    impl LockFreeCounter {\n        /// Creates a new counter starting at zero\n        pub fn new() -> Self {\n            Self {\n                value: std::sync::atomic::AtomicU64::new(0),\n            }\n        }\n\n        /// Increments the counter and returns the previous value\n        ///\n        /// This operation is atomic and lock-free.\n        pub fn increment(&self) -> u64 {\n            self.value.fetch_add(1, std::sync::atomic::Ordering::Relaxed)\n        }",
      "comment_ranges": [
        [
          35,
          78
        ],
        [
          222,
          280
        ],
        [
          288,
          292
        ],
        [
          300,
          344
        ]
      ],
      "content_length": 468,
      "difficulty": "Some(Normal)",
      "end_line": 503,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 489
    },
    {
      "code_content": "    impl LockFreeCounter {\n        /// Creates a new counter starting at zero\n        pub fn new() -> Self {\n            Self {\n                value: std::sync::atomic::AtomicU64::new(0),\n            }\n        }\n\n        /// Increments the counter and returns the previous value\n        ///\n        /// This operation is atomic and lock-free.\n        pub fn increment(&self) -> u64 {\n            self.value.fetch_add(1, std::sync::atomic::Ordering::Relaxed)\n        }\n\n        /* Gets the current counter value */\n        pub fn get(&self) -> u64 {\n            self.value.load(std::sync::atomic::Ordering::Relaxed)\n        }\n\n        /// Resets the counter to zero\n        pub fn reset(&self) -> u64 {\n            self.value.swap(0, std::sync::atomic::Ordering::Relaxed) /* Return old value */\n        }\n    }",
      "comment_ranges": [
        [
          35,
          78
        ],
        [
          222,
          280
        ],
        [
          288,
          292
        ],
        [
          300,
          344
        ],
        [
          478,
          514
        ],
        [
          635,
          666
        ],
        [
          772,
          794
        ]
      ],
      "content_length": 810,
      "difficulty": "Some(Hard)",
      "end_line": 513,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 489
    },
    {
      "code_content": "    impl LockFreeCounter {\n        /// Creates a new counter starting at zero\n        pub fn new() -> Self {\n            Self {\n                value: std::sync::atomic::AtomicU64::new(0),\n            }\n        }\n\n        /// Increments the counter and returns the previous value\n        ///\n        /// This operation is atomic and lock-free.\n        pub fn increment(&self) -> u64 {\n            self.value.fetch_add(1, std::sync::atomic::Ordering::Relaxed)\n        }\n\n        /* Gets the current counter value */\n        pub fn get(&self) -> u64 {\n            self.value.load(std::sync::atomic::Ordering::Relaxed)\n        }\n\n        /// Resets the counter to zero\n        pub fn reset(&self) -> u64 {\n            self.value.swap(0, std::sync::atomic::Ordering::Relaxed) /* Return old value */\n        }\n    }",
      "comment_ranges": [
        [
          35,
          78
        ],
        [
          222,
          280
        ],
        [
          288,
          292
        ],
        [
          300,
          344
        ],
        [
          478,
          514
        ],
        [
          635,
          666
        ],
        [
          772,
          794
        ]
      ],
      "content_length": 810,
      "difficulty": "Some(Wild)",
      "end_line": 513,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 489
    },
    {
      "code_content": "                    for (stage_index, _stage) in pipeline_stages.iter().enumerate() {\n                        // Note: Can't actually call the stage here due to borrow checker\n                        // This is a simplified example",
      "comment_ranges": [
        [
          110,
          175
        ],
        [
          200,
          231
        ]
      ],
      "content_length": 231,
      "difficulty": "Some(Easy)",
      "end_line": 324,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 321
    },
    {
      "code_content": "                    for (stage_index, _stage) in pipeline_stages.iter().enumerate() {\n                        // Note: Can't actually call the stage here due to borrow checker\n                        // This is a simplified example\n\n                        /* Simulate stage processing\n                           In real implementation, we'd need a different approach */\n                        if stage_index % 7 == 0 && chunk_index % 3 == 0 {\n                            // Simulate occasional failures\n                            chunk_results.push(Err(AppError::TimeoutError));\n                            success = false;\n                            break;\n                        }\n                    }",
      "comment_ranges": [
        [
          110,
          175
        ],
        [
          200,
          231
        ],
        [
          257,
          370
        ],
        [
          473,
          504
        ]
      ],
      "content_length": 709,
      "difficulty": "Some(Normal)",
      "end_line": 333,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 321
    },
    {
      "code_content": "                    for (stage_index, _stage) in pipeline_stages.iter().enumerate() {\n                        // Note: Can't actually call the stage here due to borrow checker\n                        // This is a simplified example\n\n                        /* Simulate stage processing\n                           In real implementation, we'd need a different approach */\n                        if stage_index % 7 == 0 && chunk_index % 3 == 0 {\n                            // Simulate occasional failures\n                            chunk_results.push(Err(AppError::TimeoutError));\n                            success = false;\n                            break;\n                        }\n                    }",
      "comment_ranges": [
        [
          110,
          175
        ],
        [
          200,
          231
        ],
        [
          257,
          370
        ],
        [
          473,
          504
        ]
      ],
      "content_length": 709,
      "difficulty": "Some(Wild)",
      "end_line": 333,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 321
    },
    {
      "code_content": "    pub unsafe fn fast_checksum(ptr: *const u8, len: usize) -> u32 {\n        let mut checksum = 0u32; // Initialize accumulator\n        let mut i = 0;",
      "comment_ranges": [
        [
          102,
          127
        ]
      ],
      "content_length": 150,
      "difficulty": "Some(Easy)",
      "end_line": 415,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 412
    },
    {
      "code_content": "    pub unsafe fn fast_checksum(ptr: *const u8, len: usize) -> u32 {\n        let mut checksum = 0u32; // Initialize accumulator\n        let mut i = 0;\n\n        /* Process 4 bytes at a time for efficiency */\n        while i + 4 <= len {\n            let chunk = ptr.add(i) as *const u32;\n            checksum = checksum.wrapping_add(*chunk); // Add without overflow check\n            i += 4; // Move to next chunk\n        }",
      "comment_ranges": [
        [
          102,
          127
        ],
        [
          160,
          206
        ],
        [
          340,
          369
        ],
        [
          390,
          411
        ]
      ],
      "content_length": 421,
      "difficulty": "Some(Normal)",
      "end_line": 422,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 412
    },
    {
      "code_content": "    pub unsafe fn fast_checksum(ptr: *const u8, len: usize) -> u32 {\n        let mut checksum = 0u32; // Initialize accumulator\n        let mut i = 0;\n\n        /* Process 4 bytes at a time for efficiency */\n        while i + 4 <= len {\n            let chunk = ptr.add(i) as *const u32;\n            checksum = checksum.wrapping_add(*chunk); // Add without overflow check\n            i += 4; // Move to next chunk\n        }\n\n        // Handle remaining bytes\n        while i < len {\n            let byte = *ptr.add(i); /* Read single byte */\n            checksum = checksum.wrapping_add(byte as u32);\n            i += 1; // Next byte\n        }\n\n        checksum // Return final result\n    }",
      "comment_ranges": [
        [
          102,
          127
        ],
        [
          160,
          206
        ],
        [
          340,
          369
        ],
        [
          390,
          411
        ],
        [
          431,
          456
        ],
        [
          517,
          539
        ],
        [
          619,
          631
        ],
        [
          660,
          682
        ]
      ],
      "content_length": 688,
      "difficulty": "Some(Hard)",
      "end_line": 431,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 412
    },
    {
      "code_content": "    pub unsafe fn fast_checksum(ptr: *const u8, len: usize) -> u32 {\n        let mut checksum = 0u32; // Initialize accumulator\n        let mut i = 0;\n\n        /* Process 4 bytes at a time for efficiency */\n        while i + 4 <= len {\n            let chunk = ptr.add(i) as *const u32;\n            checksum = checksum.wrapping_add(*chunk); // Add without overflow check\n            i += 4; // Move to next chunk\n        }\n\n        // Handle remaining bytes\n        while i < len {\n            let byte = *ptr.add(i); /* Read single byte */\n            checksum = checksum.wrapping_add(byte as u32);\n            i += 1; // Next byte\n        }\n\n        checksum // Return final result\n    }",
      "comment_ranges": [
        [
          102,
          127
        ],
        [
          160,
          206
        ],
        [
          340,
          369
        ],
        [
          390,
          411
        ],
        [
          431,
          456
        ],
        [
          517,
          539
        ],
        [
          619,
          631
        ],
        [
          660,
          682
        ]
      ],
      "content_length": 688,
      "difficulty": "Some(Wild)",
      "end_line": 431,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 412
    },
    {
      "code_content": "impl std::fmt::Display for AppError {",
      "comment_ranges": [],
      "content_length": 37,
      "difficulty": "Some(Easy)",
      "end_line": 109,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 109
    },
    {
      "code_content": "impl std::fmt::Display for AppError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            // Simple error formatting\n            AppError::NetworkError { code, message, .. } => {\n                write!(f, \"Network error {}: {}\", code, message)",
      "comment_ranges": [
        [
          144,
          170
        ]
      ],
      "content_length": 297,
      "difficulty": "Some(Normal)",
      "end_line": 114,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 109
    },
    {
      "code_content": "impl std::fmt::Display for AppError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            // Simple error formatting\n            AppError::NetworkError { code, message, .. } => {\n                write!(f, \"Network error {}: {}\", code, message)\n            },\n            AppError::ConfigError(msg) => write!(f, \"Config error: {}\", msg),\n            AppError::TimeoutError => write!(f, \"Operation timed out\"),\n            /* Complex error with location info */\n            AppError::ParseError { line, column, details } => {\n                write!(f, \"Parse error at {}:{}: {}\", line, column, details)\n            },\n        }\n    }\n}",
      "comment_ranges": [
        [
          144,
          170
        ],
        [
          475,
          513
        ]
      ],
      "content_length": 687,
      "difficulty": "Some(Hard)",
      "end_line": 124,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 109
    },
    {
      "code_content": "impl std::fmt::Display for AppError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            // Simple error formatting\n            AppError::NetworkError { code, message, .. } => {\n                write!(f, \"Network error {}: {}\", code, message)\n            },\n            AppError::ConfigError(msg) => write!(f, \"Config error: {}\", msg),\n            AppError::TimeoutError => write!(f, \"Operation timed out\"),\n            /* Complex error with location info */\n            AppError::ParseError { line, column, details } => {\n                write!(f, \"Parse error at {}:{}: {}\", line, column, details)\n            },\n        }\n    }\n}",
      "comment_ranges": [
        [
          144,
          170
        ],
        [
          475,
          513
        ]
      ],
      "content_length": 687,
      "difficulty": "Some(Wild)",
      "end_line": 124,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 109
    },
    {
      "code_content": "pub enum AppError {\n    /// Network connectivity issues\n    NetworkError {\n        code: u16,              // HTTP status code\n        message: String,        /* Error message from server */\n        retry_after: Option<u64>, // Seconds to wait before retry\n    },\n\n    /* Configuration validation errors */\n    ConfigError(String), // Error message",
      "comment_ranges": [
        [
          24,
          56
        ],
        [
          107,
          126
        ],
        [
          159,
          190
        ],
        [
          225,
          256
        ],
        [
          269,
          306
        ],
        [
          332,
          348
        ]
      ],
      "content_length": 348,
      "difficulty": "Some(Easy)",
      "end_line": 97,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 87
    },
    {
      "code_content": "pub enum AppError {\n    /// Network connectivity issues\n    NetworkError {\n        code: u16,              // HTTP status code\n        message: String,        /* Error message from server */\n        retry_after: Option<u64>, // Seconds to wait before retry\n    },\n\n    /* Configuration validation errors */\n    ConfigError(String), // Error message\n\n    // Timeout occurred during operation\n    TimeoutError, /* No additional data needed */\n\n    /// Parse errors with location information\n    ParseError {\n        line: usize,    // Line number where error occurred\n        column: usize,  /* Column position */\n        details: String, // Detailed error description\n    },\n}",
      "comment_ranges": [
        [
          24,
          56
        ],
        [
          107,
          126
        ],
        [
          159,
          190
        ],
        [
          225,
          256
        ],
        [
          269,
          306
        ],
        [
          332,
          348
        ],
        [
          354,
          390
        ],
        [
          409,
          440
        ],
        [
          446,
          489
        ],
        [
          530,
          565
        ],
        [
          590,
          611
        ],
        [
          637,
          666
        ]
      ],
      "content_length": 675,
      "difficulty": "Some(Normal)",
      "end_line": 107,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 87
    },
    {
      "code_content": "pub enum AppError {\n    /// Network connectivity issues\n    NetworkError {\n        code: u16,              // HTTP status code\n        message: String,        /* Error message from server */\n        retry_after: Option<u64>, // Seconds to wait before retry\n    },\n\n    /* Configuration validation errors */\n    ConfigError(String), // Error message\n\n    // Timeout occurred during operation\n    TimeoutError, /* No additional data needed */\n\n    /// Parse errors with location information\n    ParseError {\n        line: usize,    // Line number where error occurred\n        column: usize,  /* Column position */\n        details: String, // Detailed error description\n    },\n}",
      "comment_ranges": [
        [
          24,
          56
        ],
        [
          107,
          126
        ],
        [
          159,
          190
        ],
        [
          225,
          256
        ],
        [
          269,
          306
        ],
        [
          332,
          348
        ],
        [
          354,
          390
        ],
        [
          409,
          440
        ],
        [
          446,
          489
        ],
        [
          530,
          565
        ],
        [
          590,
          611
        ],
        [
          637,
          666
        ]
      ],
      "content_length": 675,
      "difficulty": "Some(Wild)",
      "end_line": 107,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 87
    },
    {
      "code_content": "    fn test_unsafe_checksum() {",
      "comment_ranges": [],
      "content_length": 31,
      "difficulty": "Some(Easy)",
      "end_line": 686,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 686
    },
    {
      "code_content": "    fn test_unsafe_checksum() {\n        let data = b\"Hello, world!\"; // Test data\n        let checksum = unsafe {\n            unsafe_operations::fast_checksum(\n                data.as_ptr(),\n                data.len()\n            )\n        };\n\n        // Verify checksum is calculated correctly\n        assert_ne!(checksum, 0); /* Should not be zero for this data */",
      "comment_ranges": [
        [
          69,
          81
        ],
        [
          252,
          294
        ],
        [
          328,
          366
        ]
      ],
      "content_length": 366,
      "difficulty": "Some(Normal)",
      "end_line": 697,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 686
    },
    {
      "code_content": "    fn test_unsafe_checksum() {\n        let data = b\"Hello, world!\"; // Test data\n        let checksum = unsafe {\n            unsafe_operations::fast_checksum(\n                data.as_ptr(),\n                data.len()\n            )\n        };\n\n        // Verify checksum is calculated correctly\n        assert_ne!(checksum, 0); /* Should not be zero for this data */\n\n        // Test with empty data\n        let empty_checksum = unsafe {\n            unsafe_operations::fast_checksum(\n                std::ptr::null(), /* Null pointer */\n                0 /* Zero length */\n            )\n        };\n        assert_eq!(empty_checksum, 0); // Should be zero for empty data\n    }",
      "comment_ranges": [
        [
          69,
          81
        ],
        [
          252,
          294
        ],
        [
          328,
          366
        ],
        [
          376,
          399
        ],
        [
          518,
          536
        ],
        [
          555,
          572
        ],
        [
          637,
          669
        ]
      ],
      "content_length": 675,
      "difficulty": "Some(Hard)",
      "end_line": 706,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 686
    },
    {
      "code_content": "    fn test_unsafe_checksum() {\n        let data = b\"Hello, world!\"; // Test data\n        let checksum = unsafe {\n            unsafe_operations::fast_checksum(\n                data.as_ptr(),\n                data.len()\n            )\n        };\n\n        // Verify checksum is calculated correctly\n        assert_ne!(checksum, 0); /* Should not be zero for this data */\n\n        // Test with empty data\n        let empty_checksum = unsafe {\n            unsafe_operations::fast_checksum(\n                std::ptr::null(), /* Null pointer */\n                0 /* Zero length */\n            )\n        };\n        assert_eq!(empty_checksum, 0); // Should be zero for empty data\n    }",
      "comment_ranges": [
        [
          69,
          81
        ],
        [
          252,
          294
        ],
        [
          328,
          366
        ],
        [
          376,
          399
        ],
        [
          518,
          536
        ],
        [
          555,
          572
        ],
        [
          637,
          669
        ]
      ],
      "content_length": 675,
      "difficulty": "Some(Wild)",
      "end_line": 706,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 686
    },
    {
      "code_content": "        for (index, stage) in self.stages.iter().enumerate() {",
      "comment_ranges": [],
      "content_length": 62,
      "difficulty": "Some(Easy)",
      "end_line": 239,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 239
    },
    {
      "code_content": "        for (index, stage) in self.stages.iter().enumerate() {\n            match stage(data.clone()) {\n                Ok(result) => {\n                    data = result; // Update for next stage\n                },\n                Err(e) => {\n                    /* Log the error with stage information */\n                    eprintln!(\"Stage {} failed: {}\", index, e);",
      "comment_ranges": [
        [
          170,
          194
        ],
        [
          262,
          304
        ]
      ],
      "content_length": 368,
      "difficulty": "Some(Normal)",
      "end_line": 247,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 239
    },
    {
      "code_content": "        for (index, stage) in self.stages.iter().enumerate() {\n            match stage(data.clone()) {\n                Ok(result) => {\n                    data = result; // Update for next stage\n                },\n                Err(e) => {\n                    /* Log the error with stage information */\n                    eprintln!(\"Stage {} failed: {}\", index, e);\n\n                    // Update failure metrics\n                    if let Ok(mut metrics) = self.metrics.lock() {\n                        metrics.total_failed += 1;\n                    }\n\n                    return Err(e); // Propagate the error\n                },\n            }\n        }",
      "comment_ranges": [
        [
          170,
          194
        ],
        [
          262,
          304
        ],
        [
          390,
          415
        ],
        [
          592,
          614
        ]
      ],
      "content_length": 657,
      "difficulty": "Some(Hard)",
      "end_line": 256,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 239
    },
    {
      "code_content": "        for (index, stage) in self.stages.iter().enumerate() {\n            match stage(data.clone()) {\n                Ok(result) => {\n                    data = result; // Update for next stage\n                },\n                Err(e) => {\n                    /* Log the error with stage information */\n                    eprintln!(\"Stage {} failed: {}\", index, e);\n\n                    // Update failure metrics\n                    if let Ok(mut metrics) = self.metrics.lock() {\n                        metrics.total_failed += 1;\n                    }\n\n                    return Err(e); // Propagate the error\n                },\n            }\n        }",
      "comment_ranges": [
        [
          170,
          194
        ],
        [
          262,
          304
        ],
        [
          390,
          415
        ],
        [
          592,
          614
        ]
      ],
      "content_length": 657,
      "difficulty": "Some(Wild)",
      "end_line": 256,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 239
    },
    {
      "code_content": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "comment_ranges": [],
      "content_length": 72,
      "difficulty": "Some(Easy)",
      "end_line": 110,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 110
    },
    {
      "code_content": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            // Simple error formatting\n            AppError::NetworkError { code, message, .. } => {\n                write!(f, \"Network error {}: {}\", code, message)",
      "comment_ranges": [
        [
          106,
          132
        ]
      ],
      "content_length": 259,
      "difficulty": "Some(Normal)",
      "end_line": 114,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 110
    },
    {
      "code_content": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            // Simple error formatting\n            AppError::NetworkError { code, message, .. } => {\n                write!(f, \"Network error {}: {}\", code, message)\n            },\n            AppError::ConfigError(msg) => write!(f, \"Config error: {}\", msg),\n            AppError::TimeoutError => write!(f, \"Operation timed out\"),\n            /* Complex error with location info */\n            AppError::ParseError { line, column, details } => {\n                write!(f, \"Parse error at {}:{}: {}\", line, column, details)\n            },\n        }\n    }",
      "comment_ranges": [
        [
          106,
          132
        ],
        [
          437,
          475
        ]
      ],
      "content_length": 647,
      "difficulty": "Some(Hard)",
      "end_line": 123,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 110
    },
    {
      "code_content": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            // Simple error formatting\n            AppError::NetworkError { code, message, .. } => {\n                write!(f, \"Network error {}: {}\", code, message)\n            },\n            AppError::ConfigError(msg) => write!(f, \"Config error: {}\", msg),\n            AppError::TimeoutError => write!(f, \"Operation timed out\"),\n            /* Complex error with location info */\n            AppError::ParseError { line, column, details } => {\n                write!(f, \"Parse error at {}:{}: {}\", line, column, details)\n            },\n        }\n    }",
      "comment_ranges": [
        [
          106,
          132
        ],
        [
          437,
          475
        ]
      ],
      "content_length": 647,
      "difficulty": "Some(Wild)",
      "end_line": 123,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 110
    },
    {
      "code_content": "    async fn test_pipeline_basic() {\n        let mut pipeline = ProcessingPipeline::<String, String>::new(2);",
      "comment_ranges": [],
      "content_length": 109,
      "difficulty": "Some(Easy)",
      "end_line": 645,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 643
    },
    {
      "code_content": "    async fn test_pipeline_basic() {\n        let mut pipeline = ProcessingPipeline::<String, String>::new(2);\n\n        // Add stages that transform the data\n        pipeline.add_stage(Box::new(|data: String| {\n            Ok(data.to_uppercase()) /* Convert to uppercase */\n        }));",
      "comment_ranges": [
        [
          119,
          156
        ],
        [
          246,
          272
        ]
      ],
      "content_length": 285,
      "difficulty": "Some(Normal)",
      "end_line": 650,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 643
    },
    {
      "code_content": "    async fn test_pipeline_basic() {\n        let mut pipeline = ProcessingPipeline::<String, String>::new(2);\n\n        // Add stages that transform the data\n        pipeline.add_stage(Box::new(|data: String| {\n            Ok(data.to_uppercase()) /* Convert to uppercase */\n        }));\n\n        pipeline.add_stage(Box::new(|data: String| {\n            Ok(format!(\"Processed: {}\", data)) // Add prefix\n        }));\n\n        let result = pipeline.process(\"hello world\".to_string()).await;\n        assert!(result.is_ok());\n\n        let processed = result.unwrap();\n        assert_eq!(processed, \"Processed: HELLO WORLD\"); /* Expected result */\n    }",
      "comment_ranges": [
        [
          119,
          156
        ],
        [
          246,
          272
        ],
        [
          387,
          400
        ],
        [
          619,
          640
        ]
      ],
      "content_length": 646,
      "difficulty": "Some(Hard)",
      "end_line": 660,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 643
    },
    {
      "code_content": "    async fn test_pipeline_basic() {\n        let mut pipeline = ProcessingPipeline::<String, String>::new(2);\n\n        // Add stages that transform the data\n        pipeline.add_stage(Box::new(|data: String| {\n            Ok(data.to_uppercase()) /* Convert to uppercase */\n        }));\n\n        pipeline.add_stage(Box::new(|data: String| {\n            Ok(format!(\"Processed: {}\", data)) // Add prefix\n        }));\n\n        let result = pipeline.process(\"hello world\".to_string()).await;\n        assert!(result.is_ok());\n\n        let processed = result.unwrap();\n        assert_eq!(processed, \"Processed: HELLO WORLD\"); /* Expected result */\n    }",
      "comment_ranges": [
        [
          119,
          156
        ],
        [
          246,
          272
        ],
        [
          387,
          400
        ],
        [
          619,
          640
        ]
      ],
      "content_length": 646,
      "difficulty": "Some(Wild)",
      "end_line": 660,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 643
    },
    {
      "code_content": "        {\n            /* x86_64 optimized version using SIMD instructions */\n            let mut i = 0;\n\n            // Process 32 bytes at a time with AVX if available\n            while i + 32 <= len {\n                let src_chunk = src.add(i) as *const [u8; 32];",
      "comment_ranges": [
        [
          22,
          76
        ],
        [
          117,
          168
        ]
      ],
      "content_length": 265,
      "difficulty": "Some(Easy)",
      "end_line": 459,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 453
    },
    {
      "code_content": "        {\n            /* x86_64 optimized version using SIMD instructions */\n            let mut i = 0;\n\n            // Process 32 bytes at a time with AVX if available\n            while i + 32 <= len {\n                let src_chunk = src.add(i) as *const [u8; 32];\n                let dst_chunk = dst.add(i) as *mut [u8; 32];\n                *dst_chunk = *src_chunk; // Bulk copy\n                i += 32;\n            }\n\n            // Handle remaining bytes\n            while i < len {\n                *dst.add(i) = *src.add(i); /* Byte-by-byte copy */\n                i += 1;\n            }\n        }",
      "comment_ranges": [
        [
          22,
          76
        ],
        [
          117,
          168
        ],
        [
          368,
          380
        ],
        [
          433,
          458
        ],
        [
          530,
          553
        ]
      ],
      "content_length": 601,
      "difficulty": "Some(Normal)",
      "end_line": 470,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 453
    },
    {
      "code_content": "        {\n            /* x86_64 optimized version using SIMD instructions */\n            let mut i = 0;\n\n            // Process 32 bytes at a time with AVX if available\n            while i + 32 <= len {\n                let src_chunk = src.add(i) as *const [u8; 32];\n                let dst_chunk = dst.add(i) as *mut [u8; 32];\n                *dst_chunk = *src_chunk; // Bulk copy\n                i += 32;\n            }\n\n            // Handle remaining bytes\n            while i < len {\n                *dst.add(i) = *src.add(i); /* Byte-by-byte copy */\n                i += 1;\n            }\n        }",
      "comment_ranges": [
        [
          22,
          76
        ],
        [
          117,
          168
        ],
        [
          368,
          380
        ],
        [
          433,
          458
        ],
        [
          530,
          553
        ]
      ],
      "content_length": 601,
      "difficulty": "Some(Wild)",
      "end_line": 470,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 453
    },
    {
      "code_content": "            match stage(data.clone()) {\n                Ok(result) => {\n                    data = result; // Update for next stage\n                },\n                Err(e) => {\n                    /* Log the error with stage information */\n                    eprintln!(\"Stage {} failed: {}\", index, e);",
      "comment_ranges": [
        [
          107,
          131
        ],
        [
          199,
          241
        ]
      ],
      "content_length": 305,
      "difficulty": "Some(Easy)",
      "end_line": 247,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 240
    },
    {
      "code_content": "            match stage(data.clone()) {\n                Ok(result) => {\n                    data = result; // Update for next stage\n                },\n                Err(e) => {\n                    /* Log the error with stage information */\n                    eprintln!(\"Stage {} failed: {}\", index, e);\n\n                    // Update failure metrics\n                    if let Ok(mut metrics) = self.metrics.lock() {\n                        metrics.total_failed += 1;\n                    }\n\n                    return Err(e); // Propagate the error\n                },\n            }",
      "comment_ranges": [
        [
          107,
          131
        ],
        [
          199,
          241
        ],
        [
          327,
          352
        ],
        [
          529,
          551
        ]
      ],
      "content_length": 584,
      "difficulty": "Some(Normal)",
      "end_line": 255,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 240
    },
    {
      "code_content": "            match stage(data.clone()) {\n                Ok(result) => {\n                    data = result; // Update for next stage\n                },\n                Err(e) => {\n                    /* Log the error with stage information */\n                    eprintln!(\"Stage {} failed: {}\", index, e);\n\n                    // Update failure metrics\n                    if let Ok(mut metrics) = self.metrics.lock() {\n                        metrics.total_failed += 1;\n                    }\n\n                    return Err(e); // Propagate the error\n                },\n            }",
      "comment_ranges": [
        [
          107,
          131
        ],
        [
          199,
          241
        ],
        [
          327,
          352
        ],
        [
          529,
          551
        ]
      ],
      "content_length": 584,
      "difficulty": "Some(Hard)",
      "end_line": 255,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 240
    },
    {
      "code_content": "            match stage(data.clone()) {\n                Ok(result) => {\n                    data = result; // Update for next stage\n                },\n                Err(e) => {\n                    /* Log the error with stage information */\n                    eprintln!(\"Stage {} failed: {}\", index, e);\n\n                    // Update failure metrics\n                    if let Ok(mut metrics) = self.metrics.lock() {\n                        metrics.total_failed += 1;\n                    }\n\n                    return Err(e); // Propagate the error\n                },\n            }",
      "comment_ranges": [
        [
          107,
          131
        ],
        [
          199,
          241
        ],
        [
          327,
          352
        ],
        [
          529,
          551
        ]
      ],
      "content_length": 584,
      "difficulty": "Some(Wild)",
      "end_line": 255,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 240
    },
    {
      "code_content": "        match self {\n            // Simple error formatting\n            AppError::NetworkError { code, message, .. } => {\n                write!(f, \"Network error {}: {}\", code, message)",
      "comment_ranges": [
        [
          33,
          59
        ]
      ],
      "content_length": 186,
      "difficulty": "Some(Easy)",
      "end_line": 114,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 111
    },
    {
      "code_content": "        match self {\n            // Simple error formatting\n            AppError::NetworkError { code, message, .. } => {\n                write!(f, \"Network error {}: {}\", code, message)",
      "comment_ranges": [
        [
          33,
          59
        ]
      ],
      "content_length": 186,
      "difficulty": "Some(Normal)",
      "end_line": 114,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 111
    },
    {
      "code_content": "        match self {\n            // Simple error formatting\n            AppError::NetworkError { code, message, .. } => {\n                write!(f, \"Network error {}: {}\", code, message)\n            },\n            AppError::ConfigError(msg) => write!(f, \"Config error: {}\", msg),\n            AppError::TimeoutError => write!(f, \"Operation timed out\"),\n            /* Complex error with location info */\n            AppError::ParseError { line, column, details } => {\n                write!(f, \"Parse error at {}:{}: {}\", line, column, details)\n            },\n        }",
      "comment_ranges": [
        [
          33,
          59
        ],
        [
          364,
          402
        ]
      ],
      "content_length": 568,
      "difficulty": "Some(Hard)",
      "end_line": 122,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 111
    },
    {
      "code_content": "        match self {\n            // Simple error formatting\n            AppError::NetworkError { code, message, .. } => {\n                write!(f, \"Network error {}: {}\", code, message)\n            },\n            AppError::ConfigError(msg) => write!(f, \"Config error: {}\", msg),\n            AppError::TimeoutError => write!(f, \"Operation timed out\"),\n            /* Complex error with location info */\n            AppError::ParseError { line, column, details } => {\n                write!(f, \"Parse error at {}:{}: {}\", line, column, details)\n            },\n        }",
      "comment_ranges": [
        [
          33,
          59
        ],
        [
          364,
          402
        ]
      ],
      "content_length": 568,
      "difficulty": "Some(Wild)",
      "end_line": 122,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 111
    },
    {
      "code_content": "    async fn test_pipeline_error_handling() {\n        let mut pipeline = ProcessingPipeline::<String, String>::new(1);",
      "comment_ranges": [],
      "content_length": 118,
      "difficulty": "Some(Easy)",
      "end_line": 671,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 669
    },
    {
      "code_content": "    async fn test_pipeline_error_handling() {\n        let mut pipeline = ProcessingPipeline::<String, String>::new(1);\n\n        // Add a stage that always fails\n        pipeline.add_stage(Box::new(|_data: String| {\n            Err(AppError::TimeoutError) /* Simulate failure */\n        }));",
      "comment_ranges": [
        [
          128,
          160
        ],
        [
          255,
          277
        ]
      ],
      "content_length": 290,
      "difficulty": "Some(Normal)",
      "end_line": 676,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 669
    },
    {
      "code_content": "    async fn test_pipeline_error_handling() {\n        let mut pipeline = ProcessingPipeline::<String, String>::new(1);\n\n        // Add a stage that always fails\n        pipeline.add_stage(Box::new(|_data: String| {\n            Err(AppError::TimeoutError) /* Simulate failure */\n        }));\n\n        let result = pipeline.process(\"test\".to_string()).await;\n        assert!(result.is_err()); // Should fail\n\n        let error = result.unwrap_err();\n        matches!(error, AppError::TimeoutError); /* Should be timeout error */\n    }",
      "comment_ranges": [
        [
          128,
          160
        ],
        [
          255,
          277
        ],
        [
          391,
          405
        ],
        [
          497,
          526
        ]
      ],
      "content_length": 532,
      "difficulty": "Some(Hard)",
      "end_line": 682,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 669
    },
    {
      "code_content": "    async fn test_pipeline_error_handling() {\n        let mut pipeline = ProcessingPipeline::<String, String>::new(1);\n\n        // Add a stage that always fails\n        pipeline.add_stage(Box::new(|_data: String| {\n            Err(AppError::TimeoutError) /* Simulate failure */\n        }));\n\n        let result = pipeline.process(\"test\".to_string()).await;\n        assert!(result.is_err()); // Should fail\n\n        let error = result.unwrap_err();\n        matches!(error, AppError::TimeoutError); /* Should be timeout error */\n    }",
      "comment_ranges": [
        [
          128,
          160
        ],
        [
          255,
          277
        ],
        [
          391,
          405
        ],
        [
          497,
          526
        ]
      ],
      "content_length": 532,
      "difficulty": "Some(Wild)",
      "end_line": 682,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 669
    },
    {
      "code_content": "    fn test_lock_free_counter() {\n        let counter = unsafe_operations::LockFreeCounter::new();",
      "comment_ranges": [],
      "content_length": 98,
      "difficulty": "Some(Easy)",
      "end_line": 712,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 710
    },
    {
      "code_content": "    fn test_lock_free_counter() {\n        let counter = unsafe_operations::LockFreeCounter::new();\n\n        assert_eq!(counter.get(), 0); // Should start at zero\n\n        let old_value = counter.increment();\n        assert_eq!(old_value, 0); /* Previous value should be 0 */\n        assert_eq!(counter.get(), 1); // New value should be 1",
      "comment_ranges": [
        [
          138,
          161
        ],
        [
          242,
          274
        ],
        [
          313,
          337
        ]
      ],
      "content_length": 337,
      "difficulty": "Some(Normal)",
      "end_line": 718,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 710
    },
    {
      "code_content": "    fn test_lock_free_counter() {\n        let counter = unsafe_operations::LockFreeCounter::new();\n\n        assert_eq!(counter.get(), 0); // Should start at zero\n\n        let old_value = counter.increment();\n        assert_eq!(old_value, 0); /* Previous value should be 0 */\n        assert_eq!(counter.get(), 1); // New value should be 1\n\n        let reset_value = counter.reset();\n        assert_eq!(reset_value, 1); // Should return the previous value\n        assert_eq!(counter.get(), 0); /* Should be back to zero */\n    }",
      "comment_ranges": [
        [
          138,
          161
        ],
        [
          242,
          274
        ],
        [
          313,
          337
        ],
        [
          418,
          453
        ],
        [
          492,
          520
        ]
      ],
      "content_length": 526,
      "difficulty": "Some(Hard)",
      "end_line": 722,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 710
    },
    {
      "code_content": "    fn test_lock_free_counter() {\n        let counter = unsafe_operations::LockFreeCounter::new();\n\n        assert_eq!(counter.get(), 0); // Should start at zero\n\n        let old_value = counter.increment();\n        assert_eq!(old_value, 0); /* Previous value should be 0 */\n        assert_eq!(counter.get(), 1); // New value should be 1\n\n        let reset_value = counter.reset();\n        assert_eq!(reset_value, 1); // Should return the previous value\n        assert_eq!(counter.get(), 0); /* Should be back to zero */\n    }",
      "comment_ranges": [
        [
          138,
          161
        ],
        [
          242,
          274
        ],
        [
          313,
          337
        ],
        [
          418,
          453
        ],
        [
          492,
          520
        ]
      ],
      "content_length": 526,
      "difficulty": "Some(Wild)",
      "end_line": 722,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 710
    },
    {
      "code_content": "        if let Ok(mut metrics) = self.metrics.lock() {\n            metrics.total_processed += 1; /* Increment counter */",
      "comment_ranges": [
        [
          97,
          120
        ]
      ],
      "content_length": 120,
      "difficulty": "Some(Easy)",
      "end_line": 262,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 260
    },
    {
      "code_content": "        if let Ok(mut metrics) = self.metrics.lock() {\n            metrics.total_processed += 1; /* Increment counter */\n\n            // Update average processing time\n            let total_items = metrics.total_processed + metrics.total_failed;",
      "comment_ranges": [
        [
          97,
          120
        ],
        [
          134,
          167
        ]
      ],
      "content_length": 245,
      "difficulty": "Some(Normal)",
      "end_line": 264,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 260
    },
    {
      "code_content": "        if let Ok(mut metrics) = self.metrics.lock() {\n            metrics.total_processed += 1; /* Increment counter */\n\n            // Update average processing time\n            let total_items = metrics.total_processed + metrics.total_failed;\n            if total_items > 0 {\n                let total_time = metrics.avg_processing_time * (total_items - 1) as u32\n                    + processing_time;\n                metrics.avg_processing_time = total_time / total_items as u32;\n            }\n        }",
      "comment_ranges": [
        [
          97,
          120
        ],
        [
          134,
          167
        ]
      ],
      "content_length": 508,
      "difficulty": "Some(Hard)",
      "end_line": 270,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 260
    },
    {
      "code_content": "        if let Ok(mut metrics) = self.metrics.lock() {\n            metrics.total_processed += 1; /* Increment counter */\n\n            // Update average processing time\n            let total_items = metrics.total_processed + metrics.total_failed;\n            if total_items > 0 {\n                let total_time = metrics.avg_processing_time * (total_items - 1) as u32\n                    + processing_time;\n                metrics.avg_processing_time = total_time / total_items as u32;\n            }\n        }",
      "comment_ranges": [
        [
          97,
          120
        ],
        [
          134,
          167
        ]
      ],
      "content_length": 508,
      "difficulty": "Some(Wild)",
      "end_line": 270,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 260
    },
    {
      "code_content": "    fn test_performance_benchmark() {\n        let iterations = 1_000_000;\n        let start = Instant::now();\n\n        // Simulate some work\n        let mut sum = 0u64;",
      "comment_ranges": [
        [
          119,
          140
        ]
      ],
      "content_length": 168,
      "difficulty": "Some(Easy)",
      "end_line": 731,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 726
    },
    {
      "code_content": "    fn test_performance_benchmark() {\n        let iterations = 1_000_000;\n        let start = Instant::now();\n\n        // Simulate some work\n        let mut sum = 0u64;\n        for i in 0..iterations {\n            sum = sum.wrapping_add(i); /* Prevent overflow */\n        }\n\n        let duration = start.elapsed();",
      "comment_ranges": [
        [
          119,
          140
        ],
        [
          241,
          263
        ]
      ],
      "content_length": 314,
      "difficulty": "Some(Normal)",
      "end_line": 736,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 726
    },
    {
      "code_content": "    fn test_performance_benchmark() {\n        let iterations = 1_000_000;\n        let start = Instant::now();\n\n        // Simulate some work\n        let mut sum = 0u64;\n        for i in 0..iterations {\n            sum = sum.wrapping_add(i); /* Prevent overflow */\n        }\n\n        let duration = start.elapsed();\n        println!(\"Benchmark completed in {:?}\", duration);\n\n        // Verify the computation was not optimized away\n        assert_ne!(sum, 0); // Sum should not be zero\n    }",
      "comment_ranges": [
        [
          119,
          140
        ],
        [
          241,
          263
        ],
        [
          383,
          431
        ],
        [
          460,
          485
        ]
      ],
      "content_length": 491,
      "difficulty": "Some(Hard)",
      "end_line": 741,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 726
    },
    {
      "code_content": "    fn test_performance_benchmark() {\n        let iterations = 1_000_000;\n        let start = Instant::now();\n\n        // Simulate some work\n        let mut sum = 0u64;\n        for i in 0..iterations {\n            sum = sum.wrapping_add(i); /* Prevent overflow */\n        }\n\n        let duration = start.elapsed();\n        println!(\"Benchmark completed in {:?}\", duration);\n\n        // Verify the computation was not optimized away\n        assert_ne!(sum, 0); // Sum should not be zero\n    }",
      "comment_ranges": [
        [
          119,
          140
        ],
        [
          241,
          263
        ],
        [
          383,
          431
        ],
        [
          460,
          485
        ]
      ],
      "content_length": 491,
      "difficulty": "Some(Wild)",
      "end_line": 741,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 726
    },
    {
      "code_content": "pub struct Config {\n    /// Maximum number of concurrent connections\n    /// Must be between 1 and 10000\n    pub max_connections: usize,\n\n    /* Timeout for network operations\n       Set to 0 for no timeout */\n    pub timeout: Duration,\n\n    // Enable debug logging\n    pub debug_mode: bool, /* This affects performance\n                             only enable for development */",
      "comment_ranges": [
        [
          24,
          69
        ],
        [
          73,
          105
        ],
        [
          142,
          209
        ],
        [
          242,
          265
        ],
        [
          292,
          379
        ]
      ],
      "content_length": 379,
      "difficulty": "Some(Easy)",
      "end_line": 60,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 48
    },
    {
      "code_content": "pub struct Config {\n    /// Maximum number of concurrent connections\n    /// Must be between 1 and 10000\n    pub max_connections: usize,\n\n    /* Timeout for network operations\n       Set to 0 for no timeout */\n    pub timeout: Duration,\n\n    // Enable debug logging\n    pub debug_mode: bool, /* This affects performance\n                             only enable for development */\n\n    /// Custom headers for HTTP requests\n    pub headers: HashMap<String, String>, // Key-value pairs\n}",
      "comment_ranges": [
        [
          24,
          69
        ],
        [
          73,
          105
        ],
        [
          142,
          209
        ],
        [
          242,
          265
        ],
        [
          292,
          379
        ],
        [
          385,
          422
        ],
        [
          464,
          482
        ]
      ],
      "content_length": 484,
      "difficulty": "Some(Normal)",
      "end_line": 63,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 48
    },
    {
      "code_content": "pub struct Config {\n    /// Maximum number of concurrent connections\n    /// Must be between 1 and 10000\n    pub max_connections: usize,\n\n    /* Timeout for network operations\n       Set to 0 for no timeout */\n    pub timeout: Duration,\n\n    // Enable debug logging\n    pub debug_mode: bool, /* This affects performance\n                             only enable for development */\n\n    /// Custom headers for HTTP requests\n    pub headers: HashMap<String, String>, // Key-value pairs\n}",
      "comment_ranges": [
        [
          24,
          69
        ],
        [
          73,
          105
        ],
        [
          142,
          209
        ],
        [
          242,
          265
        ],
        [
          292,
          379
        ],
        [
          385,
          422
        ],
        [
          464,
          482
        ]
      ],
      "content_length": 484,
      "difficulty": "Some(Wild)",
      "end_line": 63,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 48
    },
    {
      "code_content": "pub struct ProcessingPipeline<T, R> {\n    // Vector of processing stages\n    stages: Vec<Box<dyn Fn(T) -> Result<T, AppError> + Send + Sync>>,",
      "comment_ranges": [
        [
          42,
          72
        ]
      ],
      "content_length": 142,
      "difficulty": "Some(Easy)",
      "end_line": 151,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 148
    },
    {
      "code_content": "pub struct ProcessingPipeline<T, R> {\n    // Vector of processing stages\n    stages: Vec<Box<dyn Fn(T) -> Result<T, AppError> + Send + Sync>>,\n\n    /// Maximum number of concurrent operations\n    max_concurrency: usize, /* Limited to prevent resource exhaustion */\n\n    // Statistics and metrics\n    metrics: Arc<Mutex<PipelineMetrics>>, /* Thread-safe metrics collection */\n\n    /// Configuration for the pipeline\n    config: Config, // Reuse the config struct\n}",
      "comment_ranges": [
        [
          42,
          72
        ],
        [
          148,
          192
        ],
        [
          220,
          264
        ],
        [
          270,
          295
        ],
        [
          338,
          374
        ],
        [
          380,
          415
        ],
        [
          435,
          461
        ]
      ],
      "content_length": 463,
      "difficulty": "Some(Normal)",
      "end_line": 160,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 148
    },
    {
      "code_content": "pub struct ProcessingPipeline<T, R> {\n    // Vector of processing stages\n    stages: Vec<Box<dyn Fn(T) -> Result<T, AppError> + Send + Sync>>,\n\n    /// Maximum number of concurrent operations\n    max_concurrency: usize, /* Limited to prevent resource exhaustion */\n\n    // Statistics and metrics\n    metrics: Arc<Mutex<PipelineMetrics>>, /* Thread-safe metrics collection */\n\n    /// Configuration for the pipeline\n    config: Config, // Reuse the config struct\n}",
      "comment_ranges": [
        [
          42,
          72
        ],
        [
          148,
          192
        ],
        [
          220,
          264
        ],
        [
          270,
          295
        ],
        [
          338,
          374
        ],
        [
          380,
          415
        ],
        [
          435,
          461
        ]
      ],
      "content_length": 463,
      "difficulty": "Some(Wild)",
      "end_line": 160,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 148
    },
    {
      "code_content": "impl Default for Config {",
      "comment_ranges": [],
      "content_length": 25,
      "difficulty": "Some(Easy)",
      "end_line": 65,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 65
    },
    {
      "code_content": "impl Default for Config {\n    /// Creates a default configuration\n    ///\n    /// All values are set to safe defaults that work\n    /// in most environments.\n    fn default() -> Self {\n        Self {\n            max_connections: 10, // Conservative default\n            timeout: Duration::from_secs(DEFAULT_TIMEOUT),\n            debug_mode: false, /* Disabled by default for performance */\n            headers: HashMap::new(), // Empty headers\n        }\n    }\n}",
      "comment_ranges": [
        [
          30,
          66
        ],
        [
          70,
          74
        ],
        [
          78,
          128
        ],
        [
          132,
          158
        ],
        [
          233,
          256
        ],
        [
          347,
          388
        ],
        [
          426,
          442
        ]
      ],
      "content_length": 460,
      "difficulty": "Some(Normal)",
      "end_line": 78,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 65
    },
    {
      "code_content": "impl Default for Config {\n    /// Creates a default configuration\n    ///\n    /// All values are set to safe defaults that work\n    /// in most environments.\n    fn default() -> Self {\n        Self {\n            max_connections: 10, // Conservative default\n            timeout: Duration::from_secs(DEFAULT_TIMEOUT),\n            debug_mode: false, /* Disabled by default for performance */\n            headers: HashMap::new(), // Empty headers\n        }\n    }\n}",
      "comment_ranges": [
        [
          30,
          66
        ],
        [
          70,
          74
        ],
        [
          78,
          128
        ],
        [
          132,
          158
        ],
        [
          233,
          256
        ],
        [
          347,
          388
        ],
        [
          426,
          442
        ]
      ],
      "content_length": 460,
      "difficulty": "Some(Wild)",
      "end_line": 78,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 65
    },
    {
      "code_content": "                Err(e) => {\n                    /* Log the error with stage information */\n                    eprintln!(\"Stage {} failed: {}\", index, e);",
      "comment_ranges": [
        [
          48,
          90
        ]
      ],
      "content_length": 154,
      "difficulty": "Some(Easy)",
      "end_line": 247,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 244
    },
    {
      "code_content": "                Err(e) => {\n                    /* Log the error with stage information */\n                    eprintln!(\"Stage {} failed: {}\", index, e);\n\n                    // Update failure metrics\n                    if let Ok(mut metrics) = self.metrics.lock() {\n                        metrics.total_failed += 1;\n                    }\n\n                    return Err(e); // Propagate the error\n                }",
      "comment_ranges": [
        [
          48,
          90
        ],
        [
          176,
          201
        ],
        [
          378,
          400
        ]
      ],
      "content_length": 418,
      "difficulty": "Some(Normal)",
      "end_line": 254,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 244
    },
    {
      "code_content": "                Err(e) => {\n                    /* Log the error with stage information */\n                    eprintln!(\"Stage {} failed: {}\", index, e);\n\n                    // Update failure metrics\n                    if let Ok(mut metrics) = self.metrics.lock() {\n                        metrics.total_failed += 1;\n                    }\n\n                    return Err(e); // Propagate the error\n                }",
      "comment_ranges": [
        [
          48,
          90
        ],
        [
          176,
          201
        ],
        [
          378,
          400
        ]
      ],
      "content_length": 418,
      "difficulty": "Some(Wild)",
      "end_line": 254,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 244
    },
    {
      "code_content": "    fn test_error_display() {",
      "comment_ranges": [],
      "content_length": 29,
      "difficulty": "Some(Easy)",
      "end_line": 629,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 629
    },
    {
      "code_content": "    fn test_error_display() {\n        let network_error = AppError::NetworkError {\n            code: 404,\n            message: \"Not Found\".to_string(),\n            retry_after: Some(60),\n        };\n\n        let error_string = network_error.to_string();",
      "comment_ranges": [],
      "content_length": 252,
      "difficulty": "Some(Normal)",
      "end_line": 636,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 629
    },
    {
      "code_content": "    fn test_error_display() {\n        let network_error = AppError::NetworkError {\n            code: 404,\n            message: \"Not Found\".to_string(),\n            retry_after: Some(60),\n        };\n\n        let error_string = network_error.to_string();\n        assert!(error_string.contains(\"404\")); // Should contain status code\n        assert!(error_string.contains(\"Not Found\")); /* Should contain message */\n    }",
      "comment_ranges": [
        [
          300,
          329
        ],
        [
          383,
          411
        ]
      ],
      "content_length": 417,
      "difficulty": "Some(Hard)",
      "end_line": 639,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 629
    },
    {
      "code_content": "    fn test_error_display() {\n        let network_error = AppError::NetworkError {\n            code: 404,\n            message: \"Not Found\".to_string(),\n            retry_after: Some(60),\n        };\n\n        let error_string = network_error.to_string();\n        assert!(error_string.contains(\"404\")); // Should contain status code\n        assert!(error_string.contains(\"Not Found\")); /* Should contain message */\n    }",
      "comment_ranges": [
        [
          300,
          329
        ],
        [
          383,
          411
        ]
      ],
      "content_length": 417,
      "difficulty": "Some(Wild)",
      "end_line": 639,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 629
    },
    {
      "code_content": "pub struct PipelineMetrics {\n    /// Total number of items processed\n    total_processed: u64, // Counter\n\n    /* Number of failed operations */\n    total_failed: u64,\n\n    // Average processing time per item\n    avg_processing_time: Duration, /* Calculated automatically */",
      "comment_ranges": [
        [
          33,
          69
        ],
        [
          95,
          105
        ],
        [
          111,
          144
        ],
        [
          173,
          208
        ],
        [
          244,
          274
        ]
      ],
      "content_length": 274,
      "difficulty": "Some(Easy)",
      "end_line": 175,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 166
    },
    {
      "code_content": "pub struct PipelineMetrics {\n    /// Total number of items processed\n    total_processed: u64, // Counter\n\n    /* Number of failed operations */\n    total_failed: u64,\n\n    // Average processing time per item\n    avg_processing_time: Duration, /* Calculated automatically */\n\n    /// Peak memory usage during processing\n    peak_memory_usage: usize, // Bytes\n}",
      "comment_ranges": [
        [
          33,
          69
        ],
        [
          95,
          105
        ],
        [
          111,
          144
        ],
        [
          173,
          208
        ],
        [
          244,
          274
        ],
        [
          280,
          320
        ],
        [
          350,
          358
        ]
      ],
      "content_length": 360,
      "difficulty": "Some(Normal)",
      "end_line": 178,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 166
    },
    {
      "code_content": "pub struct PipelineMetrics {\n    /// Total number of items processed\n    total_processed: u64, // Counter\n\n    /* Number of failed operations */\n    total_failed: u64,\n\n    // Average processing time per item\n    avg_processing_time: Duration, /* Calculated automatically */\n\n    /// Peak memory usage during processing\n    peak_memory_usage: usize, // Bytes\n}",
      "comment_ranges": [
        [
          33,
          69
        ],
        [
          95,
          105
        ],
        [
          111,
          144
        ],
        [
          173,
          208
        ],
        [
          244,
          274
        ],
        [
          280,
          320
        ],
        [
          350,
          358
        ]
      ],
      "content_length": 360,
      "difficulty": "Some(Wild)",
      "end_line": 178,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 166
    },
    {
      "code_content": "    fn test_config_defaults() {\n        let config = Config::default();",
      "comment_ranges": [],
      "content_length": 71,
      "difficulty": "Some(Easy)",
      "end_line": 620,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 619
    },
    {
      "code_content": "    fn test_config_defaults() {\n        let config = Config::default();\n        assert_eq!(config.max_connections, 10); // Check default value\n        assert_eq!(config.timeout.as_secs(), DEFAULT_TIMEOUT);",
      "comment_ranges": [
        [
          120,
          142
        ]
      ],
      "content_length": 205,
      "difficulty": "Some(Normal)",
      "end_line": 622,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 619
    },
    {
      "code_content": "    fn test_config_defaults() {\n        let config = Config::default();\n        assert_eq!(config.max_connections, 10); // Check default value\n        assert_eq!(config.timeout.as_secs(), DEFAULT_TIMEOUT);\n        assert!(!config.debug_mode); /* Should be false by default */\n        assert!(config.headers.is_empty()); // No headers by default\n    }",
      "comment_ranges": [
        [
          120,
          142
        ],
        [
          243,
          275
        ],
        [
          320,
          344
        ]
      ],
      "content_length": 350,
      "difficulty": "Some(Hard)",
      "end_line": 625,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 619
    },
    {
      "code_content": "    fn test_config_defaults() {\n        let config = Config::default();\n        assert_eq!(config.max_connections, 10); // Check default value\n        assert_eq!(config.timeout.as_secs(), DEFAULT_TIMEOUT);\n        assert!(!config.debug_mode); /* Should be false by default */\n        assert!(config.headers.is_empty()); // No headers by default\n    }",
      "comment_ranges": [
        [
          120,
          142
        ],
        [
          243,
          275
        ],
        [
          320,
          344
        ]
      ],
      "content_length": 350,
      "difficulty": "Some(Wild)",
      "end_line": 625,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 619
    },
    {
      "code_content": "    pub fn new(max_concurrency: usize) -> Self {",
      "comment_ranges": [],
      "content_length": 48,
      "difficulty": "Some(Easy)",
      "end_line": 194,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 194
    },
    {
      "code_content": "    pub fn new(max_concurrency: usize) -> Self {\n        Self {\n            stages: Vec::new(), // Empty initially\n            max_concurrency, /* Store the limit */\n            metrics: Arc::new(Mutex::new(PipelineMetrics::default())),\n            config: Config::default(), // Use default configuration\n        }\n    }",
      "comment_ranges": [
        [
          96,
          114
        ],
        [
          144,
          165
        ],
        [
          276,
          304
        ]
      ],
      "content_length": 320,
      "difficulty": "Some(Normal)",
      "end_line": 201,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 194
    },
    {
      "code_content": "    pub fn new(max_concurrency: usize) -> Self {\n        Self {\n            stages: Vec::new(), // Empty initially\n            max_concurrency, /* Store the limit */\n            metrics: Arc::new(Mutex::new(PipelineMetrics::default())),\n            config: Config::default(), // Use default configuration\n        }\n    }",
      "comment_ranges": [
        [
          96,
          114
        ],
        [
          144,
          165
        ],
        [
          276,
          304
        ]
      ],
      "content_length": 320,
      "difficulty": "Some(Wild)",
      "end_line": 201,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 194
    },
    {
      "code_content": "                        if stage_index % 7 == 0 && chunk_index % 3 == 0 {\n                            // Simulate occasional failures\n                            chunk_results.push(Err(AppError::TimeoutError));\n                            success = false;",
      "comment_ranges": [
        [
          102,
          133
        ]
      ],
      "content_length": 255,
      "difficulty": "Some(Easy)",
      "end_line": 330,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 327
    },
    {
      "code_content": "                        if stage_index % 7 == 0 && chunk_index % 3 == 0 {\n                            // Simulate occasional failures\n                            chunk_results.push(Err(AppError::TimeoutError));\n                            success = false;\n                            break;\n                        }",
      "comment_ranges": [
        [
          102,
          133
        ]
      ],
      "content_length": 316,
      "difficulty": "Some(Normal)",
      "end_line": 332,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 327
    },
    {
      "code_content": "                        if stage_index % 7 == 0 && chunk_index % 3 == 0 {\n                            // Simulate occasional failures\n                            chunk_results.push(Err(AppError::TimeoutError));\n                            success = false;\n                            break;\n                        }",
      "comment_ranges": [
        [
          102,
          133
        ]
      ],
      "content_length": 316,
      "difficulty": "Some(Wild)",
      "end_line": 332,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 327
    },
    {
      "code_content": "    fn default() -> Self {\n        Self {\n            max_connections: 10, // Conservative default\n            timeout: Duration::from_secs(DEFAULT_TIMEOUT),\n            debug_mode: false, /* Disabled by default for performance */\n            headers: HashMap::new(), // Empty headers\n        }\n    }",
      "comment_ranges": [
        [
          75,
          98
        ],
        [
          189,
          230
        ],
        [
          268,
          284
        ]
      ],
      "content_length": 300,
      "difficulty": "Some(Normal)",
      "end_line": 77,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 70
    },
    {
      "code_content": "    fn default() -> Self {\n        Self {\n            max_connections: 10, // Conservative default\n            timeout: Duration::from_secs(DEFAULT_TIMEOUT),\n            debug_mode: false, /* Disabled by default for performance */\n            headers: HashMap::new(), // Empty headers\n        }\n    }",
      "comment_ranges": [
        [
          75,
          98
        ],
        [
          189,
          230
        ],
        [
          268,
          284
        ]
      ],
      "content_length": 300,
      "difficulty": "Some(Wild)",
      "end_line": 77,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 70
    },
    {
      "code_content": "        pipeline.add_stage(Box::new(|data: String| {",
      "comment_ranges": [],
      "content_length": 52,
      "difficulty": "Some(Easy)",
      "end_line": 755,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 755
    },
    {
      "code_content": "        pipeline.add_stage(Box::new(|data: String| {\n            if data.is_empty() {\n                Err(AppError::ConfigError(\"Empty input\".to_string()))\n            } else {\n                Ok(data.trim().to_string()) /* Remove whitespace */\n            }\n        }))",
      "comment_ranges": [
        [
          221,
          244
        ]
      ],
      "content_length": 270,
      "difficulty": "Some(Normal)",
      "end_line": 761,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 755
    },
    {
      "code_content": "        pipeline.add_stage(Box::new(|data: String| {\n            if data.is_empty() {\n                Err(AppError::ConfigError(\"Empty input\".to_string()))\n            } else {\n                Ok(data.trim().to_string()) /* Remove whitespace */\n            }\n        }))",
      "comment_ranges": [
        [
          221,
          244
        ]
      ],
      "content_length": 270,
      "difficulty": "Some(Wild)",
      "end_line": 761,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 755
    },
    {
      "code_content": "            if total_items > 0 {\n                let total_time = metrics.avg_processing_time * (total_items - 1) as u32\n                    + processing_time;",
      "comment_ranges": [],
      "content_length": 159,
      "difficulty": "Some(Easy)",
      "end_line": 267,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 265
    },
    {
      "code_content": "            if total_items > 0 {\n                let total_time = metrics.avg_processing_time * (total_items - 1) as u32\n                    + processing_time;\n                metrics.avg_processing_time = total_time / total_items as u32;\n            }",
      "comment_ranges": [],
      "content_length": 252,
      "difficulty": "Some(Normal)",
      "end_line": 269,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 265
    },
    {
      "code_content": "            if total_items > 0 {\n                let total_time = metrics.avg_processing_time * (total_items - 1) as u32\n                    + processing_time;\n                metrics.avg_processing_time = total_time / total_items as u32;\n            }",
      "comment_ranges": [],
      "content_length": 252,
      "difficulty": "Some(Wild)",
      "end_line": 269,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 265
    },
    {
      "code_content": "            while i + 32 <= len {\n                let src_chunk = src.add(i) as *const [u8; 32];\n                let dst_chunk = dst.add(i) as *mut [u8; 32];",
      "comment_ranges": [],
      "content_length": 157,
      "difficulty": "Some(Easy)",
      "end_line": 460,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 458
    },
    {
      "code_content": "            while i + 32 <= len {\n                let src_chunk = src.add(i) as *const [u8; 32];\n                let dst_chunk = dst.add(i) as *mut [u8; 32];\n                *dst_chunk = *src_chunk; // Bulk copy\n                i += 32;\n            }",
      "comment_ranges": [
        [
          199,
          211
        ]
      ],
      "content_length": 250,
      "difficulty": "Some(Normal)",
      "end_line": 463,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 458
    },
    {
      "code_content": "            while i + 32 <= len {\n                let src_chunk = src.add(i) as *const [u8; 32];\n                let dst_chunk = dst.add(i) as *mut [u8; 32];\n                *dst_chunk = *src_chunk; // Bulk copy\n                i += 32;\n            }",
      "comment_ranges": [
        [
          199,
          211
        ]
      ],
      "content_length": 250,
      "difficulty": "Some(Wild)",
      "end_line": 463,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 458
    },
    {
      "code_content": "        while i + 4 <= len {\n            let chunk = ptr.add(i) as *const u32;\n            checksum = checksum.wrapping_add(*chunk); // Add without overflow check\n            i += 4; // Move to next chunk\n        }",
      "comment_ranges": [
        [
          133,
          162
        ],
        [
          183,
          204
        ]
      ],
      "content_length": 214,
      "difficulty": "Some(Easy)",
      "end_line": 421,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 417
    },
    {
      "code_content": "        while i + 4 <= len {\n            let chunk = ptr.add(i) as *const u32;\n            checksum = checksum.wrapping_add(*chunk); // Add without overflow check\n            i += 4; // Move to next chunk\n        }",
      "comment_ranges": [
        [
          133,
          162
        ],
        [
          183,
          204
        ]
      ],
      "content_length": 214,
      "difficulty": "Some(Normal)",
      "end_line": 421,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 417
    },
    {
      "code_content": "        while i + 4 <= len {\n            let chunk = ptr.add(i) as *const u32;\n            checksum = checksum.wrapping_add(*chunk); // Add without overflow check\n            i += 4; // Move to next chunk\n        }",
      "comment_ranges": [
        [
          133,
          162
        ],
        [
          183,
          204
        ]
      ],
      "content_length": 214,
      "difficulty": "Some(Wild)",
      "end_line": 421,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 417
    },
    {
      "code_content": "            if data.is_empty() {\n                Err(AppError::ConfigError(\"Empty input\".to_string()))",
      "comment_ranges": [],
      "content_length": 102,
      "difficulty": "Some(Easy)",
      "end_line": 757,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 756
    },
    {
      "code_content": "            if data.is_empty() {\n                Err(AppError::ConfigError(\"Empty input\".to_string()))\n            } else {\n                Ok(data.trim().to_string()) /* Remove whitespace */\n            }",
      "comment_ranges": [
        [
          168,
          191
        ]
      ],
      "content_length": 205,
      "difficulty": "Some(Normal)",
      "end_line": 760,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 756
    },
    {
      "code_content": "            if data.is_empty() {\n                Err(AppError::ConfigError(\"Empty input\".to_string()))\n            } else {\n                Ok(data.trim().to_string()) /* Remove whitespace */\n            }",
      "comment_ranges": [
        [
          168,
          191
        ]
      ],
      "content_length": 205,
      "difficulty": "Some(Wild)",
      "end_line": 760,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 756
    },
    {
      "code_content": "        let empty_checksum = unsafe {\n            unsafe_operations::fast_checksum(\n                std::ptr::null(), /* Null pointer */\n                0 /* Zero length */\n            )\n        }",
      "comment_ranges": [
        [
          118,
          136
        ],
        [
          155,
          172
        ]
      ],
      "content_length": 196,
      "difficulty": "Some(Easy)",
      "end_line": 704,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 699
    },
    {
      "code_content": "        let empty_checksum = unsafe {\n            unsafe_operations::fast_checksum(\n                std::ptr::null(), /* Null pointer */\n                0 /* Zero length */\n            )\n        }",
      "comment_ranges": [
        [
          118,
          136
        ],
        [
          155,
          172
        ]
      ],
      "content_length": 196,
      "difficulty": "Some(Wild)",
      "end_line": 704,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 699
    },
    {
      "code_content": "    pub fn add_stage<F>(&mut self, stage: F)",
      "comment_ranges": [],
      "content_length": 44,
      "difficulty": "Some(Easy)",
      "end_line": 219,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 219
    },
    {
      "code_content": "    pub fn add_stage<F>(&mut self, stage: F)\n    where\n        F: Fn(T) -> Result<T, AppError> + Send + Sync + 'static\n    {\n        self.stages.push(Box::new(stage)); // Box the closure\n    }",
      "comment_ranges": [
        [
          168,
          186
        ]
      ],
      "content_length": 192,
      "difficulty": "Some(Normal)",
      "end_line": 224,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 219
    },
    {
      "code_content": "    pub fn add_stage<F>(&mut self, stage: F)\n    where\n        F: Fn(T) -> Result<T, AppError> + Send + Sync + 'static\n    {\n        self.stages.push(Box::new(stage)); // Box the closure\n    }",
      "comment_ranges": [
        [
          168,
          186
        ]
      ],
      "content_length": 192,
      "difficulty": "Some(Wild)",
      "end_line": 224,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 219
    },
    {
      "code_content": "        while i < len {\n            let byte = *ptr.add(i); /* Read single byte */\n            checksum = checksum.wrapping_add(byte as u32);\n            i += 1; // Next byte\n        }",
      "comment_ranges": [
        [
          60,
          82
        ],
        [
          162,
          174
        ]
      ],
      "content_length": 184,
      "difficulty": "Some(Easy)",
      "end_line": 428,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 424
    },
    {
      "code_content": "        while i < len {\n            let byte = *ptr.add(i); /* Read single byte */\n            checksum = checksum.wrapping_add(byte as u32);\n            i += 1; // Next byte\n        }",
      "comment_ranges": [
        [
          60,
          82
        ],
        [
          162,
          174
        ]
      ],
      "content_length": 184,
      "difficulty": "Some(Wild)",
      "end_line": 428,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 424
    },
    {
      "code_content": "    pub fn reset_metrics(&self) {\n        let mut metrics = self.metrics.lock().unwrap();",
      "comment_ranges": [],
      "content_length": 89,
      "difficulty": "Some(Easy)",
      "end_line": 378,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 377
    },
    {
      "code_content": "    pub fn reset_metrics(&self) {\n        let mut metrics = self.metrics.lock().unwrap();\n        *metrics = PipelineMetrics::default(); /* Reset to defaults */\n    }",
      "comment_ranges": [
        [
          137,
          160
        ]
      ],
      "content_length": 166,
      "difficulty": "Some(Normal)",
      "end_line": 380,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 377
    },
    {
      "code_content": "    pub fn reset_metrics(&self) {\n        let mut metrics = self.metrics.lock().unwrap();\n        *metrics = PipelineMetrics::default(); /* Reset to defaults */\n    }",
      "comment_ranges": [
        [
          137,
          160
        ]
      ],
      "content_length": 166,
      "difficulty": "Some(Wild)",
      "end_line": 380,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 377
    },
    {
      "code_content": "                {\n                    let mut results_guard = results_ref.lock().unwrap();\n                    results_guard.extend(chunk_results);\n                }",
      "comment_ranges": [],
      "content_length": 165,
      "difficulty": "Some(Easy)",
      "end_line": 344,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 341
    },
    {
      "code_content": "                {\n                    let mut results_guard = results_ref.lock().unwrap();\n                    results_guard.extend(chunk_results);\n                }",
      "comment_ranges": [],
      "content_length": 165,
      "difficulty": "Some(Normal)",
      "end_line": 344,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 341
    },
    {
      "code_content": "                {\n                    let mut results_guard = results_ref.lock().unwrap();\n                    results_guard.extend(chunk_results);\n                }",
      "comment_ranges": [],
      "content_length": 165,
      "difficulty": "Some(Wild)",
      "end_line": 344,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 341
    },
    {
      "code_content": "        let checksum = unsafe {\n            unsafe_operations::fast_checksum(\n                data.as_ptr(),\n                data.len()\n            )\n        }",
      "comment_ranges": [],
      "content_length": 159,
      "difficulty": "Some(Easy)",
      "end_line": 693,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 688
    },
    {
      "code_content": "        let checksum = unsafe {\n            unsafe_operations::fast_checksum(\n                data.as_ptr(),\n                data.len()\n            )\n        }",
      "comment_ranges": [],
      "content_length": 159,
      "difficulty": "Some(Wild)",
      "end_line": 693,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 688
    },
    {
      "code_content": "            AppError::ParseError { line, column, details } => {\n                write!(f, \"Parse error at {}:{}: {}\", line, column, details)\n            }",
      "comment_ranges": [],
      "content_length": 154,
      "difficulty": "Some(Easy)",
      "end_line": 121,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 119
    },
    {
      "code_content": "            AppError::ParseError { line, column, details } => {\n                write!(f, \"Parse error at {}:{}: {}\", line, column, details)\n            }",
      "comment_ranges": [],
      "content_length": 154,
      "difficulty": "Some(Normal)",
      "end_line": 121,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 119
    },
    {
      "code_content": "            AppError::ParseError { line, column, details } => {\n                write!(f, \"Parse error at {}:{}: {}\", line, column, details)\n            }",
      "comment_ranges": [],
      "content_length": 154,
      "difficulty": "Some(Wild)",
      "end_line": 121,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 119
    },
    {
      "code_content": "        pipeline.add_stage(Box::new(|data: String| {\n            Ok(format!(\"final_{}\", data.to_lowercase())) /* Add prefix and lowercase */\n        }))",
      "comment_ranges": [
        [
          110,
          140
        ]
      ],
      "content_length": 152,
      "difficulty": "Some(Easy)",
      "end_line": 769,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 767
    },
    {
      "code_content": "        pipeline.add_stage(Box::new(|data: String| {\n            Ok(format!(\"final_{}\", data.to_lowercase())) /* Add prefix and lowercase */\n        }))",
      "comment_ranges": [
        [
          110,
          140
        ]
      ],
      "content_length": 152,
      "difficulty": "Some(Normal)",
      "end_line": 769,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 767
    },
    {
      "code_content": "        pipeline.add_stage(Box::new(|data: String| {\n            Ok(format!(\"final_{}\", data.to_lowercase())) /* Add prefix and lowercase */\n        }))",
      "comment_ranges": [
        [
          110,
          140
        ]
      ],
      "content_length": 152,
      "difficulty": "Some(Wild)",
      "end_line": 769,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 767
    },
    {
      "code_content": "            unsafe_operations::fast_checksum(\n                std::ptr::null(), /* Null pointer */\n                0 /* Zero length */\n            )",
      "comment_ranges": [
        [
          80,
          98
        ],
        [
          117,
          134
        ]
      ],
      "content_length": 148,
      "difficulty": "Some(Easy)",
      "end_line": 703,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 700
    },
    {
      "code_content": "            unsafe_operations::fast_checksum(\n                std::ptr::null(), /* Null pointer */\n                0 /* Zero length */\n            )",
      "comment_ranges": [
        [
          80,
          98
        ],
        [
          117,
          134
        ]
      ],
      "content_length": 148,
      "difficulty": "Some(Wild)",
      "end_line": 703,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 700
    },
    {
      "code_content": "            AppError::NetworkError { code, message, .. } => {\n                write!(f, \"Network error {}: {}\", code, message)\n            }",
      "comment_ranges": [],
      "content_length": 140,
      "difficulty": "Some(Easy)",
      "end_line": 115,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 113
    },
    {
      "code_content": "            AppError::NetworkError { code, message, .. } => {\n                write!(f, \"Network error {}: {}\", code, message)\n            }",
      "comment_ranges": [],
      "content_length": 140,
      "difficulty": "Some(Normal)",
      "end_line": 115,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 113
    },
    {
      "code_content": "            AppError::NetworkError { code, message, .. } => {\n                write!(f, \"Network error {}: {}\", code, message)\n            }",
      "comment_ranges": [],
      "content_length": 140,
      "difficulty": "Some(Wild)",
      "end_line": 115,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 113
    },
    {
      "code_content": "                    if let Ok(mut metrics) = self.metrics.lock() {\n                        metrics.total_failed += 1;\n                    }",
      "comment_ranges": [],
      "content_length": 139,
      "difficulty": "Some(Easy)",
      "end_line": 251,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 249
    },
    {
      "code_content": "                    if let Ok(mut metrics) = self.metrics.lock() {\n                        metrics.total_failed += 1;\n                    }",
      "comment_ranges": [],
      "content_length": 139,
      "difficulty": "Some(Wild)",
      "end_line": 251,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 249
    },
    {
      "code_content": "        pub fn reset(&self) -> u64 {\n            self.value.swap(0, std::sync::atomic::Ordering::Relaxed) /* Return old value */\n        }",
      "comment_ranges": [
        [
          106,
          128
        ]
      ],
      "content_length": 138,
      "difficulty": "Some(Easy)",
      "end_line": 512,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 510
    },
    {
      "code_content": "        pub fn reset(&self) -> u64 {\n            self.value.swap(0, std::sync::atomic::Ordering::Relaxed) /* Return old value */\n        }",
      "comment_ranges": [
        [
          106,
          128
        ]
      ],
      "content_length": 138,
      "difficulty": "Some(Wild)",
      "end_line": 512,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 510
    },
    {
      "code_content": "        pipeline.add_stage(Box::new(|data: String| {\n            Ok(data.replace(\" \", \"_\")) // Replace spaces with underscores\n        }))",
      "comment_ranges": [
        [
          92,
          126
        ]
      ],
      "content_length": 138,
      "difficulty": "Some(Easy)",
      "end_line": 765,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 763
    },
    {
      "code_content": "        pipeline.add_stage(Box::new(|data: String| {\n            Ok(data.replace(\" \", \"_\")) // Replace spaces with underscores\n        }))",
      "comment_ranges": [
        [
          92,
          126
        ]
      ],
      "content_length": 138,
      "difficulty": "Some(Wild)",
      "end_line": 765,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 763
    },
    {
      "code_content": "        pub fn new() -> Self {\n            Self {\n                value: std::sync::atomic::AtomicU64::new(0),\n            }\n        }",
      "comment_ranges": [],
      "content_length": 134,
      "difficulty": "Some(Easy)",
      "end_line": 495,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 491
    },
    {
      "code_content": "        pub fn new() -> Self {\n            Self {\n                value: std::sync::atomic::AtomicU64::new(0),\n            }\n        }",
      "comment_ranges": [],
      "content_length": 134,
      "difficulty": "Some(Wild)",
      "end_line": 495,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 491
    },
    {
      "code_content": "        {\n            // Generic fallback for other architectures\n            std::ptr::copy_nonoverlapping(src, dst, len);\n        }",
      "comment_ranges": [
        [
          22,
          65
        ]
      ],
      "content_length": 133,
      "difficulty": "Some(Easy)",
      "end_line": 476,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 473
    },
    {
      "code_content": "        {\n            // Generic fallback for other architectures\n            std::ptr::copy_nonoverlapping(src, dst, len);\n        }",
      "comment_ranges": [
        [
          22,
          65
        ]
      ],
      "content_length": 133,
      "difficulty": "Some(Wild)",
      "end_line": 476,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 473
    },
    {
      "code_content": "                    if success {\n                        chunk_results.push(Ok(current_data)); // Success case\n                    }",
      "comment_ranges": [
        [
          95,
          110
        ]
      ],
      "content_length": 132,
      "difficulty": "Some(Easy)",
      "end_line": 337,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 335
    },
    {
      "code_content": "                    if success {\n                        chunk_results.push(Ok(current_data)); // Success case\n                    }",
      "comment_ranges": [
        [
          95,
          110
        ]
      ],
      "content_length": 132,
      "difficulty": "Some(Wild)",
      "end_line": 337,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 335
    },
    {
      "code_content": "            while i < len {\n                *dst.add(i) = *src.add(i); /* Byte-by-byte copy */\n                i += 1;\n            }",
      "comment_ranges": [
        [
          71,
          94
        ]
      ],
      "content_length": 132,
      "difficulty": "Some(Easy)",
      "end_line": 469,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 466
    },
    {
      "code_content": "            while i < len {\n                *dst.add(i) = *src.add(i); /* Byte-by-byte copy */\n                i += 1;\n            }",
      "comment_ranges": [
        [
          71,
          94
        ]
      ],
      "content_length": 132,
      "difficulty": "Some(Wild)",
      "end_line": 469,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 466
    },
    {
      "code_content": "        pipeline.add_stage(Box::new(|_data: String| {\n            Err(AppError::TimeoutError) /* Simulate failure */\n        }))",
      "comment_ranges": [
        [
          94,
          116
        ]
      ],
      "content_length": 128,
      "difficulty": "Some(Easy)",
      "end_line": 675,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 673
    },
    {
      "code_content": "        pipeline.add_stage(Box::new(|_data: String| {\n            Err(AppError::TimeoutError) /* Simulate failure */\n        }))",
      "comment_ranges": [
        [
          94,
          116
        ]
      ],
      "content_length": 128,
      "difficulty": "Some(Wild)",
      "end_line": 675,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 673
    },
    {
      "code_content": "        pipeline.add_stage(Box::new(|data: String| {\n            Ok(data.to_uppercase()) /* Convert to uppercase */\n        }))",
      "comment_ranges": [
        [
          89,
          115
        ]
      ],
      "content_length": 127,
      "difficulty": "Some(Easy)",
      "end_line": 649,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 647
    },
    {
      "code_content": "        pipeline.add_stage(Box::new(|data: String| {\n            Ok(data.to_uppercase()) /* Convert to uppercase */\n        }))",
      "comment_ranges": [
        [
          89,
          115
        ]
      ],
      "content_length": 127,
      "difficulty": "Some(Wild)",
      "end_line": 649,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 647
    },
    {
      "code_content": "        pipeline.add_stage(Box::new(|data: String| {\n            Ok(format!(\"Processed: {}\", data)) // Add prefix\n        }))",
      "comment_ranges": [
        [
          100,
          113
        ]
      ],
      "content_length": 125,
      "difficulty": "Some(Easy)",
      "end_line": 653,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 651
    },
    {
      "code_content": "        pipeline.add_stage(Box::new(|data: String| {\n            Ok(format!(\"Processed: {}\", data)) // Add prefix\n        }))",
      "comment_ranges": [
        [
          100,
          113
        ]
      ],
      "content_length": 125,
      "difficulty": "Some(Wild)",
      "end_line": 653,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 651
    },
    {
      "code_content": "        pub fn increment(&self) -> u64 {\n            self.value.fetch_add(1, std::sync::atomic::Ordering::Relaxed)\n        }",
      "comment_ranges": [],
      "content_length": 124,
      "difficulty": "Some(Easy)",
      "end_line": 502,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 500
    },
    {
      "code_content": "        pub fn increment(&self) -> u64 {\n            self.value.fetch_add(1, std::sync::atomic::Ordering::Relaxed)\n        }",
      "comment_ranges": [],
      "content_length": 124,
      "difficulty": "Some(Normal)",
      "end_line": 502,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 500
    },
    {
      "code_content": "        pub fn increment(&self) -> u64 {\n            self.value.fetch_add(1, std::sync::atomic::Ordering::Relaxed)\n        }",
      "comment_ranges": [],
      "content_length": 124,
      "difficulty": "Some(Wild)",
      "end_line": 502,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 500
    },
    {
      "code_content": "    pub fn get_metrics(&self) -> PipelineMetrics {\n        self.metrics.lock().unwrap().clone() // Return a copy\n    }",
      "comment_ranges": [
        [
          96,
          112
        ]
      ],
      "content_length": 118,
      "difficulty": "Some(Easy)",
      "end_line": 369,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 367
    },
    {
      "code_content": "    pub fn get_metrics(&self) -> PipelineMetrics {\n        self.metrics.lock().unwrap().clone() // Return a copy\n    }",
      "comment_ranges": [
        [
          96,
          112
        ]
      ],
      "content_length": 118,
      "difficulty": "Some(Wild)",
      "end_line": 369,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 367
    },
    {
      "code_content": "            unsafe_operations::fast_checksum(\n                data.as_ptr(),\n                data.len()\n            )",
      "comment_ranges": [],
      "content_length": 117,
      "difficulty": "Some(Easy)",
      "end_line": 692,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 689
    },
    {
      "code_content": "            unsafe_operations::fast_checksum(\n                data.as_ptr(),\n                data.len()\n            )",
      "comment_ranges": [],
      "content_length": 117,
      "difficulty": "Some(Wild)",
      "end_line": 692,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 689
    },
    {
      "code_content": "            if data.is_empty() {\n                Err(AppError::ConfigError(\"Empty input\".to_string()))\n            }",
      "comment_ranges": [],
      "content_length": 116,
      "difficulty": "Some(Easy)",
      "end_line": 758,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 756
    },
    {
      "code_content": "            if data.is_empty() {\n                Err(AppError::ConfigError(\"Empty input\".to_string()))\n            }",
      "comment_ranges": [],
      "content_length": 116,
      "difficulty": "Some(Wild)",
      "end_line": 758,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 756
    },
    {
      "code_content": "        for handle in handles {\n            let _ = handle.await; /* Ignore join errors for simplicity */\n        }",
      "comment_ranges": [
        [
          66,
          105
        ]
      ],
      "content_length": 115,
      "difficulty": "Some(Easy)",
      "end_line": 356,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 354
    },
    {
      "code_content": "        for handle in handles {\n            let _ = handle.await; /* Ignore join errors for simplicity */\n        }",
      "comment_ranges": [
        [
          66,
          105
        ]
      ],
      "content_length": 115,
      "difficulty": "Some(Wild)",
      "end_line": 356,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 354
    },
    {
      "code_content": "        pub fn get(&self) -> u64 {\n            self.value.load(std::sync::atomic::Ordering::Relaxed)\n        }",
      "comment_ranges": [],
      "content_length": 110,
      "difficulty": "Some(Easy)",
      "end_line": 507,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 505
    },
    {
      "code_content": "        pub fn get(&self) -> u64 {\n            self.value.load(std::sync::atomic::Ordering::Relaxed)\n        }",
      "comment_ranges": [],
      "content_length": 110,
      "difficulty": "Some(Wild)",
      "end_line": 507,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 505
    },
    {
      "code_content": "                Ok(result) => {\n                    data = result; // Update for next stage\n                }",
      "comment_ranges": [
        [
          67,
          91
        ]
      ],
      "content_length": 109,
      "difficulty": "Some(Easy)",
      "end_line": 243,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 241
    },
    {
      "code_content": "                Ok(result) => {\n                    data = result; // Update for next stage\n                }",
      "comment_ranges": [
        [
          67,
          91
        ]
      ],
      "content_length": 109,
      "difficulty": "Some(Wild)",
      "end_line": 243,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 241
    },
    {
      "code_content": "        for i in 0..iterations {\n            sum = sum.wrapping_add(i); /* Prevent overflow */\n        }",
      "comment_ranges": [
        [
          72,
          94
        ]
      ],
      "content_length": 104,
      "difficulty": "Some(Easy)",
      "end_line": 734,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 732
    },
    {
      "code_content": "        for i in 0..iterations {\n            sum = sum.wrapping_add(i); /* Prevent overflow */\n        }",
      "comment_ranges": [
        [
          72,
          94
        ]
      ],
      "content_length": 104,
      "difficulty": "Some(Wild)",
      "end_line": 734,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 732
    },
    {
      "code_content": "            } else {\n                Ok(data.trim().to_string()) /* Remove whitespace */\n            }",
      "comment_ranges": [
        [
          65,
          88
        ]
      ],
      "content_length": 102,
      "difficulty": "Some(Easy)",
      "end_line": 760,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 758
    },
    {
      "code_content": "            } else {\n                Ok(data.trim().to_string()) /* Remove whitespace */\n            }",
      "comment_ranges": [
        [
          65,
          88
        ]
      ],
      "content_length": 102,
      "difficulty": "Some(Wild)",
      "end_line": 760,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 758
    },
    {
      "code_content": "    pub struct LockFreeCounter {\n        value: std::sync::atomic::AtomicU64, // Atomic counter\n    }",
      "comment_ranges": [
        [
          78,
          95
        ]
      ],
      "content_length": 101,
      "difficulty": "Some(Easy)",
      "end_line": 487,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 485
    },
    {
      "code_content": "    pub struct LockFreeCounter {\n        value: std::sync::atomic::AtomicU64, // Atomic counter\n    }",
      "comment_ranges": [
        [
          78,
          95
        ]
      ],
      "content_length": 101,
      "difficulty": "Some(Wild)",
      "end_line": 487,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 485
    },
    {
      "code_content": "    {\n        self.stages.push(Box::new(stage)); // Box the closure\n    }",
      "comment_ranges": [
        [
          49,
          67
        ]
      ],
      "content_length": 73,
      "difficulty": "Some(Easy)",
      "end_line": 224,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 222
    },
    {
      "code_content": "    {\n        self.stages.push(Box::new(stage)); // Box the closure\n    }",
      "comment_ranges": [
        [
          49,
          67
        ]
      ],
      "content_length": 73,
      "difficulty": "Some(Wild)",
      "end_line": 224,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 222
    },
    {
      "code_content": "    async fn test_pipeline_error_handling",
      "comment_ranges": [],
      "content_length": 41,
      "difficulty": "Some(Easy)",
      "end_line": 669,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 669
    },
    {
      "code_content": "    async fn test_pipeline_error_handling",
      "comment_ranges": [],
      "content_length": 41,
      "difficulty": "Some(Wild)",
      "end_line": 669,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 669
    },
    {
      "code_content": "impl std::error::Error for AppError {}",
      "comment_ranges": [],
      "content_length": 38,
      "difficulty": "Some(Easy)",
      "end_line": 128,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 128
    },
    {
      "code_content": "impl std::error::Error for AppError {}",
      "comment_ranges": [],
      "content_length": 38,
      "difficulty": "Some(Wild)",
      "end_line": 128,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 128
    },
    {
      "code_content": "    fn test_performance_benchmark",
      "comment_ranges": [],
      "content_length": 33,
      "difficulty": "Some(Easy)",
      "end_line": 726,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 726
    },
    {
      "code_content": "    fn test_performance_benchmark",
      "comment_ranges": [],
      "content_length": 33,
      "difficulty": "Some(Wild)",
      "end_line": 726,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 726
    },
    {
      "code_content": "    async fn test_pipeline_basic",
      "comment_ranges": [],
      "content_length": 32,
      "difficulty": "Some(Easy)",
      "end_line": 643,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 643
    },
    {
      "code_content": "    async fn test_pipeline_basic",
      "comment_ranges": [],
      "content_length": 32,
      "difficulty": "Some(Wild)",
      "end_line": 643,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 643
    },
    {
      "code_content": "    pub unsafe fn fast_checksum",
      "comment_ranges": [],
      "content_length": 31,
      "difficulty": "Some(Easy)",
      "end_line": 412,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 412
    },
    {
      "code_content": "    pub unsafe fn fast_checksum",
      "comment_ranges": [],
      "content_length": 31,
      "difficulty": "Some(Wild)",
      "end_line": 412,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 412
    },
    {
      "code_content": "    pub async fn process_batch",
      "comment_ranges": [],
      "content_length": 30,
      "difficulty": "Some(Easy)",
      "end_line": 292,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 292
    },
    {
      "code_content": "    pub async fn process_batch",
      "comment_ranges": [],
      "content_length": 30,
      "difficulty": "Some(Wild)",
      "end_line": 292,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 292
    },
    {
      "code_content": "    pub struct LockFreeCounter",
      "comment_ranges": [],
      "content_length": 30,
      "difficulty": "Some(Easy)",
      "end_line": 485,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 485
    },
    {
      "code_content": "    pub struct LockFreeCounter",
      "comment_ranges": [],
      "content_length": 30,
      "difficulty": "Some(Wild)",
      "end_line": 485,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 485
    },
    {
      "code_content": "pub struct ProcessingPipeline",
      "comment_ranges": [],
      "content_length": 29,
      "difficulty": "Some(Easy)",
      "end_line": 148,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 148
    },
    {
      "code_content": "pub struct ProcessingPipeline",
      "comment_ranges": [],
      "content_length": 29,
      "difficulty": "Some(Wild)",
      "end_line": 148,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 148
    },
    {
      "code_content": "    fn test_lock_free_counter",
      "comment_ranges": [],
      "content_length": 29,
      "difficulty": "Some(Easy)",
      "end_line": 710,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 710
    },
    {
      "code_content": "    fn test_lock_free_counter",
      "comment_ranges": [],
      "content_length": 29,
      "difficulty": "Some(Wild)",
      "end_line": 710,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 710
    },
    {
      "code_content": "    async fn test_integration",
      "comment_ranges": [],
      "content_length": 29,
      "difficulty": "Some(Easy)",
      "end_line": 750,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 750
    },
    {
      "code_content": "    async fn test_integration",
      "comment_ranges": [],
      "content_length": 29,
      "difficulty": "Some(Wild)",
      "end_line": 750,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 750
    },
    {
      "code_content": "    fn test_config_defaults",
      "comment_ranges": [],
      "content_length": 27,
      "difficulty": "Some(Easy)",
      "end_line": 619,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 619
    },
    {
      "code_content": "    fn test_config_defaults",
      "comment_ranges": [],
      "content_length": 27,
      "difficulty": "Some(Wild)",
      "end_line": 619,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 619
    },
    {
      "code_content": "    fn test_unsafe_checksum",
      "comment_ranges": [],
      "content_length": 27,
      "difficulty": "Some(Easy)",
      "end_line": 686,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 686
    },
    {
      "code_content": "    fn test_unsafe_checksum",
      "comment_ranges": [],
      "content_length": 27,
      "difficulty": "Some(Wild)",
      "end_line": 686,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 686
    },
    {
      "code_content": "pub struct PipelineMetrics",
      "comment_ranges": [],
      "content_length": 26,
      "difficulty": "Some(Easy)",
      "end_line": 166,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 166
    },
    {
      "code_content": "pub struct PipelineMetrics",
      "comment_ranges": [],
      "content_length": 26,
      "difficulty": "Some(Wild)",
      "end_line": 166,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 166
    },
    {
      "code_content": "pub mod unsafe_operations",
      "comment_ranges": [],
      "content_length": 25,
      "difficulty": "Some(Easy)",
      "end_line": 392,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 392
    },
    {
      "code_content": "pub mod unsafe_operations",
      "comment_ranges": [],
      "content_length": 25,
      "difficulty": "Some(Wild)",
      "end_line": 392,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 392
    },
    {
      "code_content": "    fn test_error_display",
      "comment_ranges": [],
      "content_length": 25,
      "difficulty": "Some(Easy)",
      "end_line": 629,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 629
    },
    {
      "code_content": "    fn test_error_display",
      "comment_ranges": [],
      "content_length": 25,
      "difficulty": "Some(Wild)",
      "end_line": 629,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 629
    },
    {
      "code_content": "    pub fn reset_metrics",
      "comment_ranges": [],
      "content_length": 24,
      "difficulty": "Some(Wild)",
      "end_line": 377,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 377
    },
    {
      "code_content": "    impl LockFreeCounter",
      "comment_ranges": [],
      "content_length": 24,
      "difficulty": "Some(Wild)",
      "end_line": 489,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 489
    },
    {
      "code_content": "    pub fn get_metrics",
      "comment_ranges": [],
      "content_length": 22,
      "difficulty": "Some(Wild)",
      "end_line": 367,
      "source_file": "tests/fixtures/complex_commented_rust.rs",
      "start_line": 367
    }
  ],
  "challenges_with_comments": 166,
  "chunk_types": [
    [
      "Class",
      4
    ],
    [
      "CodeBlock",
      29
    ],
    [
      "Conditional",
      8
    ],
    [
      "Enum",
      1
    ],
    [
      "File",
      1
    ],
    [
      "Function",
      22
    ],
    [
      "FunctionCall",
      9
    ],
    [
      "Loop",
      10
    ],
    [
      "Module",
      2
    ],
    [
      "Struct",
      4
    ]
  ],
  "difficulty_distribution": [
    [
      "Some(Easy)",
      85
    ],
    [
      "Some(Hard)",
      25
    ],
    [
      "Some(Normal)",
      48
    ],
    [
      "Some(Wild)",
      90
    ],
    [
      "Some(Zen)",
      1
    ]
  ],
  "total_challenges": 249,
  "total_chunks": 90
}
