---
source: tests/unit/domain/services/challenge_generator/challenge_generator_tests.rs
expression: json_string
---
{
  "challenges": [
    {
      "code_content": "// Complex Rust service module with various patterns\n// This file contains multiple structs, enums, traits, and complex logic\n// to test the ChallengeGenerator with realistic code patterns\n\nuse std::collections::{HashMap, BTreeMap, HashSet};\nuse std::sync::{Arc, Mutex, RwLock};",
      "content_length": 278,
      "difficulty": "Some(Easy)",
      "end_line": 6,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 1
    },
    {
      "code_content": "// Complex Rust service module with various patterns\n// This file contains multiple structs, enums, traits, and complex logic\n// to test the ChallengeGenerator with realistic code patterns\n\nuse std::collections::{HashMap, BTreeMap, HashSet};\nuse std::sync::{Arc, Mutex, RwLock};\nuse std::time::{Duration, Instant};\nuse std::thread;\nuse std::io::{self, Read, Write};\nuse std::fs::File;",
      "content_length": 384,
      "difficulty": "Some(Normal)",
      "end_line": 10,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 1
    },
    {
      "code_content": "// Complex Rust service module with various patterns\n// This file contains multiple structs, enums, traits, and complex logic\n// to test the ChallengeGenerator with realistic code patterns\n\nuse std::collections::{HashMap, BTreeMap, HashSet};\nuse std::sync::{Arc, Mutex, RwLock};\nuse std::time::{Duration, Instant};\nuse std::thread;\nuse std::io::{self, Read, Write};\nuse std::fs::File;\nuse std::path::{Path, PathBuf};\nuse serde::{Serialize, Deserialize};\n\n/// Configuration struct for the service\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ServiceConfig {\n    pub max_connections: usize,\n    pub timeout: Duration,\n    pub retry_count: u32,\n    pub enable_logging: bool,\n    pub cache_size: usize,\n    pub worker_threads: usize,\n}",
      "content_length": 745,
      "difficulty": "Some(Hard)",
      "end_line": 24,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 1
    },
    {
      "code_content": "// Complex Rust service module with various patterns\n// This file contains multiple structs, enums, traits, and complex logic\n// to test the ChallengeGenerator with realistic code patterns\n\nuse std::collections::{HashMap, BTreeMap, HashSet};\nuse std::sync::{Arc, Mutex, RwLock};\nuse std::time::{Duration, Instant};\nuse std::thread;\nuse std::io::{self, Read, Write};\nuse std::fs::File;\nuse std::path::{Path, PathBuf};\nuse serde::{Serialize, Deserialize};\n\n/// Configuration struct for the service\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ServiceConfig {\n    pub max_connections: usize,\n    pub timeout: Duration,\n    pub retry_count: u32,\n    pub enable_logging: bool,\n    pub cache_size: usize,\n    pub worker_threads: usize,\n}\n\nimpl Default for ServiceConfig {\n    fn default() -> Self {\n        Self {\n            max_connections: 100,\n            timeout: Duration::from_secs(30),\n            retry_count: 3,\n            enable_logging: true,\n            cache_size: 1000,\n            worker_threads: 4,\n        }\n    }\n}\n\n/// Error types for the service\n#[derive(Debug, Clone, PartialEq)]\npub enum ServiceError {\n    ConnectionFailed(String),\n    Timeout,\n    InvalidInput(String),\n    CacheFull,\n    WorkerPanic,\n    ConfigurationError(String),\n    NetworkError { code: u16, message: String },\n    ParseError { line: usize, column: usize, details: String },\n}\n\nimpl std::fmt::Display for ServiceError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            ServiceError::ConnectionFailed(msg) => write!(f, \"Connection failed: {}\", msg),\n            ServiceError::Timeout => write!(f, \"Operation timed out\"),\n            ServiceError::InvalidInput(msg) => write!(f, \"Invalid input: {}\", msg),\n            ServiceError::CacheFull => write!(f, \"Cache is full\"),\n            ServiceError::WorkerPanic => write!(f, \"Worker thread panicked\"),\n            ServiceError::ConfigurationError(msg) => write!(f, \"Configuration error: {}\", msg),\n            ServiceError::NetworkError { code, message } => {\n                write!(f, \"Network error {}: {}\", code, message)\n            }\n            ServiceError::ParseError { line, column, details } => {\n                write!(f, \"Parse error at {}:{}: {}\", line, column, details)\n            }\n        }\n    }\n}\n\nimpl std::error::Error for ServiceError {}\n\n/// Request structure\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ServiceRequest {\n    pub id: String,\n    pub method: RequestMethod,\n    pub data: RequestData,\n    pub headers: HashMap<String, String>,\n    pub timestamp: u64,\n    pub priority: Priority,\n}\n\n/// HTTP-like request methods\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum RequestMethod {\n    Get,\n    Post,\n    Put,\n    Delete,\n    Patch,\n    Head,\n    Options,\n}\n\n/// Request data variants\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum RequestData {\n    Json(serde_json::Value),\n    Binary(Vec<u8>),\n    Text(String),\n    FormData(HashMap<String, String>),\n    Empty,\n}\n\n/// Priority levels\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]\npub enum Priority {\n    Low = 1,\n    Normal = 2,\n    High = 3,\n    Critical = 4,\n}\n\n/// Response structure\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ServiceResponse {\n    pub id: String,\n    pub status: ResponseStatus,\n    pub data: Option<ResponseData>,\n    pub headers: HashMap<String, String>,\n    pub processing_time: Duration,\n    pub worker_id: usize,\n}\n\n/// Response status codes\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum ResponseStatus {\n    Success = 200,\n    Created = 201,\n    BadRequest = 400,\n    Unauthorized = 401,\n    NotFound = 404,\n    InternalError = 500,\n    ServiceUnavailable = 503,\n}\n\n/// Response data variants\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ResponseData {\n    Json(serde_json::Value),\n    Binary(Vec<u8>),\n    Text(String),\n    Stream(String), // URL or identifier for streaming data\n}\n\n/// Cache entry with metadata\n#[derive(Debug, Clone)]\nstruct CacheEntry<T> {\n    data: T,\n    created_at: Instant,\n    access_count: u64,\n    last_accessed: Instant,\n    size: usize,\n}\n\nimpl<T> CacheEntry<T> {\n    fn new(data: T, size: usize) -> Self {\n        let now = Instant::now();\n        Self {\n            data,\n            created_at: now,\n            access_count: 0,\n            last_accessed: now,\n            size,\n        }\n    }\n\n    fn access(&mut self) -> &T {\n        self.access_count += 1;\n        self.last_accessed = Instant::now();\n        &self.data\n    }\n\n    fn is_expired(&self, ttl: Duration) -> bool {\n        self.created_at.elapsed() > ttl\n    }\n\n    fn score(&self) -> f64 {\n        // LFU + LRU hybrid scoring\n        let frequency_score = self.access_count as f64;\n        let recency_score = 1.0 / (self.last_accessed.elapsed().as_secs_f64() + 1.0);\n        frequency_score * 0.7 + recency_score * 0.3\n    }\n}\n\n/// Thread-safe LRU cache implementation\npub struct LruCache<K, V>\nwhere\n    K: Clone + Eq + std::hash::Hash,\n    V: Clone,\n{\n    capacity: usize,\n    data: Arc<RwLock<HashMap<K, CacheEntry<V>>>>,\n    access_order: Arc<Mutex<Vec<K>>>,\n    current_size: Arc<Mutex<usize>>,\n    ttl: Duration,\n    stats: Arc<Mutex<CacheStats>>,\n}\n\n#[derive(Debug, Default)]\npub struct CacheStats {\n    pub hits: u64,\n    pub misses: u64,\n    pub evictions: u64,\n    pub size: usize,\n    pub capacity: usize,\n}\n\nimpl CacheStats {\n    pub fn hit_rate(&self) -> f64 {\n        if self.hits + self.misses == 0 {\n            0.0\n        } else {\n            self.hits as f64 / (self.hits + self.misses) as f64\n        }\n    }\n}\n\nimpl<K, V> LruCache<K, V>\nwhere\n    K: Clone + Eq + std::hash::Hash,\n    V: Clone,\n{\n    pub fn new(capacity: usize, ttl: Duration) -> Self {\n        Self {\n            capacity,\n            data: Arc::new(RwLock::new(HashMap::new())),\n            access_order: Arc::new(Mutex::new(Vec::new())),\n            current_size: Arc::new(Mutex::new(0)),\n            ttl,\n            stats: Arc::new(Mutex::new(CacheStats::default())),\n        }\n    }\n\n    pub fn get(&self, key: &K) -> Option<V> {\n        let mut data = self.data.write().unwrap();\n        let mut stats = self.stats.lock().unwrap();\n\n        if let Some(entry) = data.get_mut(key) {\n            if entry.is_expired(self.ttl) {\n                data.remove(key);\n                self.remove_from_access_order(key);\n                stats.misses += 1;\n                None\n            } else {\n                let value = entry.access().clone();\n                self.move_to_front(key);\n                stats.hits += 1;\n                Some(value)\n            }\n        } else {\n            stats.misses += 1;\n            None\n        }\n    }\n\n    pub fn put(&self, key: K, value: V, size: usize) -> Result<(), ServiceError> {\n        let mut data = self.data.write().unwrap();\n        let mut current_size = self.current_size.lock().unwrap();\n        let mut stats = self.stats.lock().unwrap();\n\n        // Check if we need to evict entries\n        while *current_size + size > self.capacity && !data.is_empty() {\n            if let Err(_) = self.evict_lru(&mut data, &mut *current_size, &mut stats) {\n                return Err(ServiceError::CacheFull);\n            }\n        }\n\n        if *current_size + size > self.capacity {\n            return Err(ServiceError::CacheFull);\n        }\n\n        // Remove old entry if exists\n        if let Some(old_entry) = data.remove(&key) {\n            *current_size -= old_entry.size;\n            self.remove_from_access_order(&key);\n        }\n\n        // Insert new entry\n        let entry = CacheEntry::new(value, size);\n        data.insert(key.clone(), entry);\n        *current_size += size;\n        stats.size = data.len();\n\n        self.add_to_front(key);\n        Ok(())\n    }\n\n    fn evict_lru(&self, data: &mut HashMap<K, CacheEntry<V>>, current_size: &mut usize, stats: &mut CacheStats) -> Result<(), ServiceError> {\n        let access_order = self.access_order.lock().unwrap();\n        if let Some(lru_key) = access_order.last() {\n            if let Some(entry) = data.remove(lru_key) {\n                *current_size -= entry.size;\n                stats.evictions += 1;\n                stats.size = data.len();\n                drop(access_order);\n                self.remove_from_access_order(lru_key);\n                Ok(())\n            } else {\n                Err(ServiceError::CacheFull)\n            }\n        } else {\n            Err(ServiceError::CacheFull)\n        }\n    }\n\n    fn move_to_front(&self, key: &K) {\n        let mut access_order = self.access_order.lock().unwrap();\n        if let Some(pos) = access_order.iter().position(|x| x == key) {\n            let key = access_order.remove(pos);\n            access_order.insert(0, key);\n        }\n    }\n\n    fn add_to_front(&self, key: K) {\n        let mut access_order = self.access_order.lock().unwrap();\n        access_order.insert(0, key);\n    }\n\n    fn remove_from_access_order(&self, key: &K) {\n        let mut access_order = self.access_order.lock().unwrap();\n        if let Some(pos) = access_order.iter().position(|x| x == key) {\n            access_order.remove(pos);\n        }\n    }\n\n    pub fn stats(&self) -> CacheStats {\n        self.stats.lock().unwrap().clone()\n    }\n\n    pub fn clear(&self) {\n        let mut data = self.data.write().unwrap();\n        let mut access_order = self.access_order.lock().unwrap();\n        let mut current_size = self.current_size.lock().unwrap();\n        let mut stats = self.stats.lock().unwrap();\n\n        data.clear();\n        access_order.clear();\n        *current_size = 0;\n        stats.size = 0;\n    }\n}\n\n/// Worker thread implementation\npub struct Worker {\n    id: usize,\n    config: ServiceConfig,\n    cache: Arc<LruCache<String, ServiceResponse>>,\n    request_queue: Arc<Mutex<Vec<ServiceRequest>>>,\n    response_sender: Arc<Mutex<HashMap<String, ServiceResponse>>>,\n    is_running: Arc<Mutex<bool>>,\n    metrics: Arc<Mutex<WorkerMetrics>>,\n}\n\n#[derive(Debug, Default, Clone)]\npub struct WorkerMetrics {\n    pub requests_processed: u64,\n    pub errors_encountered: u64,\n    pub average_processing_time: Duration,\n    pub total_processing_time: Duration,\n    pub cache_hits: u64,\n    pub cache_misses: u64,\n}\n\nimpl Worker {\n    pub fn new(\n        id: usize,\n        config: ServiceConfig,\n        cache: Arc<LruCache<String, ServiceResponse>>,\n        request_queue: Arc<Mutex<Vec<ServiceRequest>>>,\n        response_sender: Arc<Mutex<HashMap<String, ServiceResponse>>>,\n    ) -> Self {\n        Self {\n            id,\n            config,\n            cache,\n            request_queue,\n            response_sender,\n            is_running: Arc::new(Mutex::new(false)),\n            metrics: Arc::new(Mutex::new(WorkerMetrics::default())),\n        }\n    }\n\n    pub fn start(&self) -> Result<thread::JoinHandle<()>, ServiceError> {\n        let id = self.id;\n        let config = self.config.clone();\n        let cache = Arc::clone(&self.cache);\n        let request_queue = Arc::clone(&self.request_queue);\n        let response_sender = Arc::clone(&self.response_sender);\n        let is_running = Arc::clone(&self.is_running);\n        let metrics = Arc::clone(&self.metrics);\n\n        {\n            let mut running = is_running.lock().unwrap();\n            *running = true;\n        }\n\n        let handle = thread::spawn(move || {\n            let mut local_metrics = WorkerMetrics::default();\n\n            loop {\n                let should_continue = {\n                    let running = is_running.lock().unwrap();\n                    *running\n                };\n\n                if !should_continue {\n                    break;\n                }\n\n                // Get next request\n                let request = {\n                    let mut queue = request_queue.lock().unwrap();\n                    queue.pop()\n                };\n\n                if let Some(req) = request {\n                    let start_time = Instant::now();\n\n                    // Check cache first\n                    let cached_response = cache.get(&req.id);\n\n                    let response = if let Some(cached) = cached_response {\n                        local_metrics.cache_hits += 1;\n                        cached\n                    } else {\n                        local_metrics.cache_misses += 1;\n\n                        // Process request\n                        match Self::process_request(&req, &config, id) {\n                            Ok(resp) => {\n                                // Cache the response\n                                let response_size = Self::estimate_response_size(&resp);\n                                if let Err(e) = cache.put(req.id.clone(), resp.clone(), response_size) {\n                                    if config.enable_logging {\n                                        eprintln!(\"Worker {}: Failed to cache response: {:?}\", id, e);\n                                    }\n                                }\n                                resp\n                            }\n                            Err(e) => {\n                                local_metrics.errors_encountered += 1;\n                                ServiceResponse {\n                                    id: req.id.clone(),\n                                    status: ResponseStatus::InternalError,\n                                    data: Some(ResponseData::Text(format!(\"Error: {}\", e))),\n                                    headers: HashMap::new(),\n                                    processing_time: start_time.elapsed(),\n                                    worker_id: id,\n                                }\n                            }\n                        }\n                    };\n\n                    let processing_time = start_time.elapsed();\n                    local_metrics.requests_processed += 1;\n                    local_metrics.total_processing_time += processing_time;\n                    local_metrics.average_processing_time =\n                        local_metrics.total_processing_time / local_metrics.requests_processed as u32;\n\n                    // Send response\n                    {\n                        let mut sender = response_sender.lock().unwrap();\n                        sender.insert(req.id.clone(), response);\n                    }\n                } else {\n                    // No requests available, sleep briefly\n                    thread::sleep(Duration::from_millis(10));\n                }\n\n                // Update metrics periodically\n                if local_metrics.requests_processed % 100 == 0 {\n                    let mut global_metrics = metrics.lock().unwrap();\n                    *global_metrics = local_metrics.clone();\n                }\n            }\n\n            // Final metrics update\n            let mut global_metrics = metrics.lock().unwrap();\n            *global_metrics = local_metrics;\n        });\n\n        Ok(handle)\n    }\n\n    pub fn stop(&self) {\n        let mut running = self.is_running.lock().unwrap();\n        *running = false;\n    }\n\n    pub fn metrics(&self) -> WorkerMetrics {\n        self.metrics.lock().unwrap().clone()\n    }\n\n    fn process_request(\n        request: &ServiceRequest,\n        config: &ServiceConfig,\n        worker_id: usize,\n    ) -> Result<ServiceResponse, ServiceError> {\n        // Simulate processing time based on request complexity\n        let processing_delay = Self::calculate_processing_delay(&request);\n        thread::sleep(processing_delay);\n\n        // Validate request\n        Self::validate_request(request)?;\n\n        // Process based on method\n        let data = match &request.method {\n            RequestMethod::Get => Self::handle_get_request(request)?,\n            RequestMethod::Post => Self::handle_post_request(request)?,\n            RequestMethod::Put => Self::handle_put_request(request)?,\n            RequestMethod::Delete => Self::handle_delete_request(request)?,\n            RequestMethod::Patch => Self::handle_patch_request(request)?,\n            RequestMethod::Head => None,\n            RequestMethod::Options => Self::handle_options_request(request)?,\n        };\n\n        // Create response headers\n        let mut headers = HashMap::new();\n        headers.insert(\"Content-Type\".to_string(), \"application/json\".to_string());\n        headers.insert(\"X-Worker-Id\".to_string(), worker_id.to_string());\n        headers.insert(\"X-Request-Id\".to_string(), request.id.clone());\n        headers.insert(\"X-Processing-Time\".to_string(), processing_delay.as_millis().to_string());\n\n        Ok(ServiceResponse {\n            id: request.id.clone(),\n            status: ResponseStatus::Success,\n            data,\n            headers,\n            processing_time: processing_delay,\n            worker_id,\n        })\n    }\n\n    fn calculate_processing_delay(request: &ServiceRequest) -> Duration {\n        let base_delay = Duration::from_millis(10);\n        let priority_multiplier = match request.priority {\n            Priority::Critical => 0.5,\n            Priority::High => 0.75,\n            Priority::Normal => 1.0,\n            Priority::Low => 1.5,\n        };\n\n        let data_size_factor = match &request.data {\n            RequestData::Json(value) => value.to_string().len() as f64 / 1000.0,\n            RequestData::Binary(data) => data.len() as f64 / 1000.0,\n            RequestData::Text(text) => text.len() as f64 / 1000.0,\n            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>() as f64 / 1000.0\n            }\n            RequestData::Empty => 0.0,\n        };\n\n        let total_multiplier = priority_multiplier * (1.0 + data_size_factor);\n        Duration::from_millis((base_delay.as_millis() as f64 * total_multiplier) as u64)\n    }\n\n    fn validate_request(request: &ServiceRequest) -> Result<(), ServiceError> {\n        if request.id.is_empty() {\n            return Err(ServiceError::InvalidInput(\"Request ID cannot be empty\".to_string()));\n        }\n\n        if request.id.len() > 255 {\n            return Err(ServiceError::InvalidInput(\"Request ID too long\".to_string()));\n        }\n\n        // Validate data size\n        let data_size = match &request.data {\n            RequestData::Json(value) => value.to_string().len(),\n            RequestData::Binary(data) => data.len(),\n            RequestData::Text(text) => text.len(),\n            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>()\n            }\n            RequestData::Empty => 0,\n        };\n\n        if data_size > 10_000_000 { // 10MB limit\n            return Err(ServiceError::InvalidInput(\"Request data too large\".to_string()));\n        }\n\n        Ok(())\n    }\n\n    fn handle_get_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate GET processing\n        let response_data = serde_json::json!({\n            \"message\": \"GET request processed successfully\",\n            \"request_id\": request.id,\n            \"timestamp\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            \"headers\": request.headers,\n        });\n\n        Ok(Some(ResponseData::Json(response_data)))\n    }\n\n    fn handle_post_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate POST processing with data validation\n        let processed_data = match &request.data {\n            RequestData::Json(value) => {\n                // Simulate JSON processing\n                let mut result = value.clone();\n                if let Some(obj) = result.as_object_mut() {\n                    obj.insert(\"processed\".to_string(), serde_json::Value::Bool(true));\n                    obj.insert(\"processor_id\".to_string(), serde_json::Value::String(request.id.clone()));\n                }\n                result\n            }\n            RequestData::Text(text) => {\n                serde_json::json!({\n                    \"original_text\": text,\n                    \"processed\": true,\n                    \"length\": text.len(),\n                    \"word_count\": text.split_whitespace().count(),\n                })\n            }\n            RequestData::FormData(form) => {\n                serde_json::json!({\n                    \"form_fields\": form,\n                    \"field_count\": form.len(),\n                    \"processed\": true,\n                })\n            }\n            RequestData::Binary(data) => {\n                serde_json::json!({\n                    \"binary_size\": data.len(),\n                    \"processed\": true,\n                    \"checksum\": format!(\"{:x}\", md5::compute(data)),\n                })\n            }\n            RequestData::Empty => {\n                serde_json::json!({\n                    \"message\": \"Empty data processed\",\n                    \"processed\": true,\n                })\n            }\n        };\n\n        Ok(Some(ResponseData::Json(processed_data)))\n    }\n\n    fn handle_put_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate PUT processing (update operation)\n        let response_data = serde_json::json!({\n            \"message\": \"Resource updated successfully\",\n            \"request_id\": request.id,\n            \"updated_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            \"data_size\": match &request.data {\n                RequestData::Json(v) => v.to_string().len(),\n                RequestData::Binary(d) => d.len(),\n                RequestData::Text(t) => t.len(),\n                RequestData::FormData(f) => f.values().map(|v| v.len()).sum::<usize>(),\n                RequestData::Empty => 0,\n            },\n        });\n\n        Ok(Some(ResponseData::Json(response_data)))\n    }\n\n    fn handle_delete_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate DELETE processing\n        let response_data = serde_json::json!({\n            \"message\": \"Resource deleted successfully\",\n            \"request_id\": request.id,\n            \"deleted_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n        });\n\n        Ok(Some(ResponseData::Json(response_data)))\n    }\n\n    fn handle_patch_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate PATCH processing (partial update)\n        let response_data = serde_json::json!({\n            \"message\": \"Resource partially updated\",\n            \"request_id\": request.id,\n            \"patched_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            \"patch_data\": &request.data,\n        });\n\n        Ok(Some(ResponseData::Json(response_data)))\n    }\n\n    fn handle_options_request(_request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // CORS preflight response\n        Ok(Some(ResponseData::Json(serde_json::json!({\n            \"allowed_methods\": [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"HEAD\", \"OPTIONS\"],\n            \"allowed_headers\": [\"Content-Type\", \"Authorization\", \"X-Request-Id\"],\n            \"max_age\": 86400,\n        }))))\n    }\n\n    fn estimate_response_size(response: &ServiceResponse) -> usize {\n        let base_size = std::mem::size_of::<ServiceResponse>();\n        let headers_size = response.headers.iter()\n            .map(|(k, v)| k.len() + v.len())\n            .sum::<usize>();\n\n        let data_size = match &response.data {\n            Some(ResponseData::Json(value)) => value.to_string().len(),\n            Some(ResponseData::Binary(data)) => data.len(),\n            Some(ResponseData::Text(text)) => text.len(),\n            Some(ResponseData::Stream(url)) => url.len(),\n            None => 0,\n        };\n\n        base_size + headers_size + data_size + response.id.len()\n    }\n}\n\n/// Main service orchestrator\npub struct ComplexService {\n    config: ServiceConfig,\n    workers: Vec<Worker>,\n    cache: Arc<LruCache<String, ServiceResponse>>,\n    request_queue: Arc<Mutex<Vec<ServiceRequest>>>,\n    response_store: Arc<Mutex<HashMap<String, ServiceResponse>>>,\n    worker_handles: Vec<thread::JoinHandle<()>>,\n    request_counter: Arc<Mutex<u64>>,\n    service_metrics: Arc<Mutex<ServiceMetrics>>,\n}\n\n#[derive(Debug, Default, Clone)]\npub struct ServiceMetrics {\n    pub total_requests: u64,\n    pub successful_requests: u64,\n    pub failed_requests: u64,\n    pub average_response_time: Duration,\n    pub total_response_time: Duration,\n    pub cache_hit_rate: f64,\n    pub active_workers: usize,\n    pub queue_size: usize,\n}\n\nimpl ComplexService {\n    pub fn new(config: ServiceConfig) -> Result<Self, ServiceError> {\n        Self::validate_config(&config)?;\n\n        let cache = Arc::new(LruCache::new(\n            config.cache_size,\n            Duration::from_secs(300), // 5 minute TTL\n        ));\n\n        let request_queue = Arc::new(Mutex::new(Vec::new()));\n        let response_store = Arc::new(Mutex::new(HashMap::new()));\n\n        let mut workers = Vec::new();\n        for i in 0..config.worker_threads {\n            let worker = Worker::new(\n                i,\n                config.clone(),\n                Arc::clone(&cache),\n                Arc::clone(&request_queue),\n                Arc::clone(&response_store),\n            );\n            workers.push(worker);\n        }\n\n        Ok(Self {\n            config,\n            workers,\n            cache,\n            request_queue,\n            response_store,\n            worker_handles: Vec::new(),\n            request_counter: Arc::new(Mutex::new(0)),\n            service_metrics: Arc::new(Mutex::new(ServiceMetrics::default())),\n        })\n    }\n\n    fn validate_config(config: &ServiceConfig) -> Result<(), ServiceError> {\n        if config.max_connections == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"max_connections must be greater than 0\".to_string()\n            ));\n        }\n\n        if config.worker_threads == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"worker_threads must be greater than 0\".to_string()\n            ));\n        }\n\n        if config.cache_size == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"cache_size must be greater than 0\".to_string()\n            ));\n        }\n\n        if config.timeout.as_secs() == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"timeout must be greater than 0\".to_string()\n            ));\n        }\n\n        Ok(())\n    }\n\n    pub fn start(&mut self) -> Result<(), ServiceError> {\n        if !self.worker_handles.is_empty() {\n            return Err(ServiceError::ConfigurationError(\n                \"Service is already running\".to_string()\n            ));\n        }\n\n        for worker in &self.workers {\n            let handle = worker.start()?;\n            self.worker_handles.push(handle);\n        }\n\n        if self.config.enable_logging {\n            println!(\"ComplexService started with {} workers\", self.config.worker_threads);\n        }\n\n        Ok(())\n    }\n\n    pub fn stop(&mut self) -> Result<(), ServiceError> {\n        // Stop all workers\n        for worker in &self.workers {\n            worker.stop();\n        }\n\n        // Wait for all worker threads to finish\n        while let Some(handle) = self.worker_handles.pop() {\n            if let Err(_) = handle.join() {\n                return Err(ServiceError::WorkerPanic);\n            }\n        }\n\n        if self.config.enable_logging {\n            println!(\"ComplexService stopped\");\n        }\n\n        Ok(())\n    }\n\n    pub fn submit_request(&self, mut request: ServiceRequest) -> Result<String, ServiceError> {\n        // Generate request ID if not provided\n        if request.id.is_empty() {\n            let mut counter = self.request_counter.lock().unwrap();\n            *counter += 1;\n            request.id = format!(\"req_{:08x}\", *counter);\n        }\n\n        // Validate request\n        Self::validate_request_limits(&request, &self.config)?;\n\n        // Add to queue\n        {\n            let mut queue = self.request_queue.lock().unwrap();\n            if queue.len() >= self.config.max_connections {\n                return Err(ServiceError::CacheFull); // Queue full, reusing error type\n            }\n\n            // Insert based on priority\n            let insert_pos = queue.iter().position(|r| r.priority < request.priority)\n                .unwrap_or(queue.len());\n            queue.insert(insert_pos, request.clone());\n        }\n\n        // Update metrics\n        {\n            let mut metrics = self.service_metrics.lock().unwrap();\n            metrics.total_requests += 1;\n            metrics.queue_size = self.request_queue.lock().unwrap().len();\n        }\n\n        Ok(request.id)\n    }\n\n    fn validate_request_limits(request: &ServiceRequest, config: &ServiceConfig) -> Result<(), ServiceError> {\n        // Implement rate limiting and validation logic here\n        let data_size = match &request.data {\n            RequestData::Json(value) => value.to_string().len(),\n            RequestData::Binary(data) => data.len(),\n            RequestData::Text(text) => text.len(),\n            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>()\n            }\n            RequestData::Empty => 0,\n        };\n\n        // Example size limit: 50MB\n        if data_size > 50_000_000 {\n            return Err(ServiceError::InvalidInput(\n                \"Request data exceeds maximum size limit\".to_string()\n            ));\n        }\n\n        Ok(())\n    }\n\n    pub fn get_response(&self, request_id: &str) -> Option<ServiceResponse> {\n        let mut store = self.response_store.lock().unwrap();\n        store.remove(request_id)\n    }\n\n    pub fn wait_for_response(&self, request_id: &str, timeout: Duration) -> Result<ServiceResponse, ServiceError> {\n        let start = Instant::now();\n\n        loop {\n            if let Some(response) = self.get_response(request_id) {\n                // Update success metrics\n                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.successful_requests += 1;\n                    let response_time = start.elapsed();\n                    metrics.total_response_time += response_time;\n                    metrics.average_response_time =\n                        metrics.total_response_time / metrics.successful_requests as u32;\n                }\n                return Ok(response);\n            }\n\n            if start.elapsed() > timeout {\n                // Update failure metrics\n                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.failed_requests += 1;\n                }\n                return Err(ServiceError::Timeout);\n            }\n\n            thread::sleep(Duration::from_millis(10));\n        }\n    }\n\n    pub fn metrics(&self) -> ServiceMetrics {\n        let mut metrics = self.service_metrics.lock().unwrap().clone();\n        metrics.active_workers = self.worker_handles.len();\n        metrics.queue_size = self.request_queue.lock().unwrap().len();\n\n        let cache_stats = self.cache.stats();\n        metrics.cache_hit_rate = cache_stats.hit_rate();\n\n        metrics\n    }\n\n    pub fn worker_metrics(&self) -> Vec<WorkerMetrics> {\n        self.workers.iter().map(|w| w.metrics()).collect()\n    }\n\n    pub fn cache_stats(&self) -> CacheStats {\n        self.cache.stats()\n    }\n\n    pub fn clear_cache(&self) {\n        self.cache.clear();\n    }\n\n    pub fn health_check(&self) -> Result<serde_json::Value, ServiceError> {\n        let metrics = self.metrics();\n        let cache_stats = self.cache_stats();\n        let worker_metrics = self.worker_metrics();\n\n        Ok(serde_json::json!({\n            \"status\": \"healthy\",\n            \"service_metrics\": {\n                \"total_requests\": metrics.total_requests,\n                \"successful_requests\": metrics.successful_requests,\n                \"failed_requests\": metrics.failed_requests,\n                \"average_response_time_ms\": metrics.average_response_time.as_millis(),\n                \"cache_hit_rate\": metrics.cache_hit_rate,\n                \"active_workers\": metrics.active_workers,\n                \"queue_size\": metrics.queue_size,\n            },\n            \"cache_stats\": {\n                \"hits\": cache_stats.hits,\n                \"misses\": cache_stats.misses,\n                \"evictions\": cache_stats.evictions,\n                \"size\": cache_stats.size,\n                \"capacity\": cache_stats.capacity,\n                \"hit_rate\": cache_stats.hit_rate(),\n            },\n            \"worker_metrics\": worker_metrics,\n            \"config\": {\n                \"max_connections\": self.config.max_connections,\n                \"timeout_secs\": self.config.timeout.as_secs(),\n                \"retry_count\": self.config.retry_count,\n                \"cache_size\": self.config.cache_size,\n                \"worker_threads\": self.config.worker_threads,\n            }\n        }))\n    }\n}",
      "content_length": 33308,
      "difficulty": "Some(Wild)",
      "end_line": 997,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 1
    },
    {
      "code_content": "// Complex Rust service module with various patterns\n// This file contains multiple structs, enums, traits, and complex logic\n// to test the ChallengeGenerator with realistic code patterns\n\nuse std::collections::{HashMap, BTreeMap, HashSet};\nuse std::sync::{Arc, Mutex, RwLock};\nuse std::time::{Duration, Instant};\nuse std::thread;\nuse std::io::{self, Read, Write};\nuse std::fs::File;\nuse std::path::{Path, PathBuf};\nuse serde::{Serialize, Deserialize};\n\n/// Configuration struct for the service\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ServiceConfig {\n    pub max_connections: usize,\n    pub timeout: Duration,\n    pub retry_count: u32,\n    pub enable_logging: bool,\n    pub cache_size: usize,\n    pub worker_threads: usize,\n}\n\nimpl Default for ServiceConfig {\n    fn default() -> Self {\n        Self {\n            max_connections: 100,\n            timeout: Duration::from_secs(30),\n            retry_count: 3,\n            enable_logging: true,\n            cache_size: 1000,\n            worker_threads: 4,\n        }\n    }\n}\n\n/// Error types for the service\n#[derive(Debug, Clone, PartialEq)]\npub enum ServiceError {\n    ConnectionFailed(String),\n    Timeout,\n    InvalidInput(String),\n    CacheFull,\n    WorkerPanic,\n    ConfigurationError(String),\n    NetworkError { code: u16, message: String },\n    ParseError { line: usize, column: usize, details: String },\n}\n\nimpl std::fmt::Display for ServiceError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            ServiceError::ConnectionFailed(msg) => write!(f, \"Connection failed: {}\", msg),\n            ServiceError::Timeout => write!(f, \"Operation timed out\"),\n            ServiceError::InvalidInput(msg) => write!(f, \"Invalid input: {}\", msg),\n            ServiceError::CacheFull => write!(f, \"Cache is full\"),\n            ServiceError::WorkerPanic => write!(f, \"Worker thread panicked\"),\n            ServiceError::ConfigurationError(msg) => write!(f, \"Configuration error: {}\", msg),\n            ServiceError::NetworkError { code, message } => {\n                write!(f, \"Network error {}: {}\", code, message)\n            }\n            ServiceError::ParseError { line, column, details } => {\n                write!(f, \"Parse error at {}:{}: {}\", line, column, details)\n            }\n        }\n    }\n}\n\nimpl std::error::Error for ServiceError {}\n\n/// Request structure\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ServiceRequest {\n    pub id: String,\n    pub method: RequestMethod,\n    pub data: RequestData,\n    pub headers: HashMap<String, String>,\n    pub timestamp: u64,\n    pub priority: Priority,\n}\n\n/// HTTP-like request methods\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum RequestMethod {\n    Get,\n    Post,\n    Put,\n    Delete,\n    Patch,\n    Head,\n    Options,\n}\n\n/// Request data variants\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum RequestData {\n    Json(serde_json::Value),\n    Binary(Vec<u8>),\n    Text(String),\n    FormData(HashMap<String, String>),\n    Empty,\n}\n\n/// Priority levels\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]\npub enum Priority {\n    Low = 1,\n    Normal = 2,\n    High = 3,\n    Critical = 4,\n}\n\n/// Response structure\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ServiceResponse {\n    pub id: String,\n    pub status: ResponseStatus,\n    pub data: Option<ResponseData>,\n    pub headers: HashMap<String, String>,\n    pub processing_time: Duration,\n    pub worker_id: usize,\n}\n\n/// Response status codes\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum ResponseStatus {\n    Success = 200,\n    Created = 201,\n    BadRequest = 400,\n    Unauthorized = 401,\n    NotFound = 404,\n    InternalError = 500,\n    ServiceUnavailable = 503,\n}\n\n/// Response data variants\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ResponseData {\n    Json(serde_json::Value),\n    Binary(Vec<u8>),\n    Text(String),\n    Stream(String), // URL or identifier for streaming data\n}\n\n/// Cache entry with metadata\n#[derive(Debug, Clone)]\nstruct CacheEntry<T> {\n    data: T,\n    created_at: Instant,\n    access_count: u64,\n    last_accessed: Instant,\n    size: usize,\n}\n\nimpl<T> CacheEntry<T> {\n    fn new(data: T, size: usize) -> Self {\n        let now = Instant::now();\n        Self {\n            data,\n            created_at: now,\n            access_count: 0,\n            last_accessed: now,\n            size,\n        }\n    }\n\n    fn access(&mut self) -> &T {\n        self.access_count += 1;\n        self.last_accessed = Instant::now();\n        &self.data\n    }\n\n    fn is_expired(&self, ttl: Duration) -> bool {\n        self.created_at.elapsed() > ttl\n    }\n\n    fn score(&self) -> f64 {\n        // LFU + LRU hybrid scoring\n        let frequency_score = self.access_count as f64;\n        let recency_score = 1.0 / (self.last_accessed.elapsed().as_secs_f64() + 1.0);\n        frequency_score * 0.7 + recency_score * 0.3\n    }\n}\n\n/// Thread-safe LRU cache implementation\npub struct LruCache<K, V>\nwhere\n    K: Clone + Eq + std::hash::Hash,\n    V: Clone,\n{\n    capacity: usize,\n    data: Arc<RwLock<HashMap<K, CacheEntry<V>>>>,\n    access_order: Arc<Mutex<Vec<K>>>,\n    current_size: Arc<Mutex<usize>>,\n    ttl: Duration,\n    stats: Arc<Mutex<CacheStats>>,\n}\n\n#[derive(Debug, Default)]\npub struct CacheStats {\n    pub hits: u64,\n    pub misses: u64,\n    pub evictions: u64,\n    pub size: usize,\n    pub capacity: usize,\n}\n\nimpl CacheStats {\n    pub fn hit_rate(&self) -> f64 {\n        if self.hits + self.misses == 0 {\n            0.0\n        } else {\n            self.hits as f64 / (self.hits + self.misses) as f64\n        }\n    }\n}\n\nimpl<K, V> LruCache<K, V>\nwhere\n    K: Clone + Eq + std::hash::Hash,\n    V: Clone,\n{\n    pub fn new(capacity: usize, ttl: Duration) -> Self {\n        Self {\n            capacity,\n            data: Arc::new(RwLock::new(HashMap::new())),\n            access_order: Arc::new(Mutex::new(Vec::new())),\n            current_size: Arc::new(Mutex::new(0)),\n            ttl,\n            stats: Arc::new(Mutex::new(CacheStats::default())),\n        }\n    }\n\n    pub fn get(&self, key: &K) -> Option<V> {\n        let mut data = self.data.write().unwrap();\n        let mut stats = self.stats.lock().unwrap();\n\n        if let Some(entry) = data.get_mut(key) {\n            if entry.is_expired(self.ttl) {\n                data.remove(key);\n                self.remove_from_access_order(key);\n                stats.misses += 1;\n                None\n            } else {\n                let value = entry.access().clone();\n                self.move_to_front(key);\n                stats.hits += 1;\n                Some(value)\n            }\n        } else {\n            stats.misses += 1;\n            None\n        }\n    }\n\n    pub fn put(&self, key: K, value: V, size: usize) -> Result<(), ServiceError> {\n        let mut data = self.data.write().unwrap();\n        let mut current_size = self.current_size.lock().unwrap();\n        let mut stats = self.stats.lock().unwrap();\n\n        // Check if we need to evict entries\n        while *current_size + size > self.capacity && !data.is_empty() {\n            if let Err(_) = self.evict_lru(&mut data, &mut *current_size, &mut stats) {\n                return Err(ServiceError::CacheFull);\n            }\n        }\n\n        if *current_size + size > self.capacity {\n            return Err(ServiceError::CacheFull);\n        }\n\n        // Remove old entry if exists\n        if let Some(old_entry) = data.remove(&key) {\n            *current_size -= old_entry.size;\n            self.remove_from_access_order(&key);\n        }\n\n        // Insert new entry\n        let entry = CacheEntry::new(value, size);\n        data.insert(key.clone(), entry);\n        *current_size += size;\n        stats.size = data.len();\n\n        self.add_to_front(key);\n        Ok(())\n    }\n\n    fn evict_lru(&self, data: &mut HashMap<K, CacheEntry<V>>, current_size: &mut usize, stats: &mut CacheStats) -> Result<(), ServiceError> {\n        let access_order = self.access_order.lock().unwrap();\n        if let Some(lru_key) = access_order.last() {\n            if let Some(entry) = data.remove(lru_key) {\n                *current_size -= entry.size;\n                stats.evictions += 1;\n                stats.size = data.len();\n                drop(access_order);\n                self.remove_from_access_order(lru_key);\n                Ok(())\n            } else {\n                Err(ServiceError::CacheFull)\n            }\n        } else {\n            Err(ServiceError::CacheFull)\n        }\n    }\n\n    fn move_to_front(&self, key: &K) {\n        let mut access_order = self.access_order.lock().unwrap();\n        if let Some(pos) = access_order.iter().position(|x| x == key) {\n            let key = access_order.remove(pos);\n            access_order.insert(0, key);\n        }\n    }\n\n    fn add_to_front(&self, key: K) {\n        let mut access_order = self.access_order.lock().unwrap();\n        access_order.insert(0, key);\n    }\n\n    fn remove_from_access_order(&self, key: &K) {\n        let mut access_order = self.access_order.lock().unwrap();\n        if let Some(pos) = access_order.iter().position(|x| x == key) {\n            access_order.remove(pos);\n        }\n    }\n\n    pub fn stats(&self) -> CacheStats {\n        self.stats.lock().unwrap().clone()\n    }\n\n    pub fn clear(&self) {\n        let mut data = self.data.write().unwrap();\n        let mut access_order = self.access_order.lock().unwrap();\n        let mut current_size = self.current_size.lock().unwrap();\n        let mut stats = self.stats.lock().unwrap();\n\n        data.clear();\n        access_order.clear();\n        *current_size = 0;\n        stats.size = 0;\n    }\n}\n\n/// Worker thread implementation\npub struct Worker {\n    id: usize,\n    config: ServiceConfig,\n    cache: Arc<LruCache<String, ServiceResponse>>,\n    request_queue: Arc<Mutex<Vec<ServiceRequest>>>,\n    response_sender: Arc<Mutex<HashMap<String, ServiceResponse>>>,\n    is_running: Arc<Mutex<bool>>,\n    metrics: Arc<Mutex<WorkerMetrics>>,\n}\n\n#[derive(Debug, Default, Clone)]\npub struct WorkerMetrics {\n    pub requests_processed: u64,\n    pub errors_encountered: u64,\n    pub average_processing_time: Duration,\n    pub total_processing_time: Duration,\n    pub cache_hits: u64,\n    pub cache_misses: u64,\n}\n\nimpl Worker {\n    pub fn new(\n        id: usize,\n        config: ServiceConfig,\n        cache: Arc<LruCache<String, ServiceResponse>>,\n        request_queue: Arc<Mutex<Vec<ServiceRequest>>>,\n        response_sender: Arc<Mutex<HashMap<String, ServiceResponse>>>,\n    ) -> Self {\n        Self {\n            id,\n            config,\n            cache,\n            request_queue,\n            response_sender,\n            is_running: Arc::new(Mutex::new(false)),\n            metrics: Arc::new(Mutex::new(WorkerMetrics::default())),\n        }\n    }\n\n    pub fn start(&self) -> Result<thread::JoinHandle<()>, ServiceError> {\n        let id = self.id;\n        let config = self.config.clone();\n        let cache = Arc::clone(&self.cache);\n        let request_queue = Arc::clone(&self.request_queue);\n        let response_sender = Arc::clone(&self.response_sender);\n        let is_running = Arc::clone(&self.is_running);\n        let metrics = Arc::clone(&self.metrics);\n\n        {\n            let mut running = is_running.lock().unwrap();\n            *running = true;\n        }\n\n        let handle = thread::spawn(move || {\n            let mut local_metrics = WorkerMetrics::default();\n\n            loop {\n                let should_continue = {\n                    let running = is_running.lock().unwrap();\n                    *running\n                };\n\n                if !should_continue {\n                    break;\n                }\n\n                // Get next request\n                let request = {\n                    let mut queue = request_queue.lock().unwrap();\n                    queue.pop()\n                };\n\n                if let Some(req) = request {\n                    let start_time = Instant::now();\n\n                    // Check cache first\n                    let cached_response = cache.get(&req.id);\n\n                    let response = if let Some(cached) = cached_response {\n                        local_metrics.cache_hits += 1;\n                        cached\n                    } else {\n                        local_metrics.cache_misses += 1;\n\n                        // Process request\n                        match Self::process_request(&req, &config, id) {\n                            Ok(resp) => {\n                                // Cache the response\n                                let response_size = Self::estimate_response_size(&resp);\n                                if let Err(e) = cache.put(req.id.clone(), resp.clone(), response_size) {\n                                    if config.enable_logging {\n                                        eprintln!(\"Worker {}: Failed to cache response: {:?}\", id, e);\n                                    }\n                                }\n                                resp\n                            }\n                            Err(e) => {\n                                local_metrics.errors_encountered += 1;\n                                ServiceResponse {\n                                    id: req.id.clone(),\n                                    status: ResponseStatus::InternalError,\n                                    data: Some(ResponseData::Text(format!(\"Error: {}\", e))),\n                                    headers: HashMap::new(),\n                                    processing_time: start_time.elapsed(),\n                                    worker_id: id,\n                                }\n                            }\n                        }\n                    };\n\n                    let processing_time = start_time.elapsed();\n                    local_metrics.requests_processed += 1;\n                    local_metrics.total_processing_time += processing_time;\n                    local_metrics.average_processing_time =\n                        local_metrics.total_processing_time / local_metrics.requests_processed as u32;\n\n                    // Send response\n                    {\n                        let mut sender = response_sender.lock().unwrap();\n                        sender.insert(req.id.clone(), response);\n                    }\n                } else {\n                    // No requests available, sleep briefly\n                    thread::sleep(Duration::from_millis(10));\n                }\n\n                // Update metrics periodically\n                if local_metrics.requests_processed % 100 == 0 {\n                    let mut global_metrics = metrics.lock().unwrap();\n                    *global_metrics = local_metrics.clone();\n                }\n            }\n\n            // Final metrics update\n            let mut global_metrics = metrics.lock().unwrap();\n            *global_metrics = local_metrics;\n        });\n\n        Ok(handle)\n    }\n\n    pub fn stop(&self) {\n        let mut running = self.is_running.lock().unwrap();\n        *running = false;\n    }\n\n    pub fn metrics(&self) -> WorkerMetrics {\n        self.metrics.lock().unwrap().clone()\n    }\n\n    fn process_request(\n        request: &ServiceRequest,\n        config: &ServiceConfig,\n        worker_id: usize,\n    ) -> Result<ServiceResponse, ServiceError> {\n        // Simulate processing time based on request complexity\n        let processing_delay = Self::calculate_processing_delay(&request);\n        thread::sleep(processing_delay);\n\n        // Validate request\n        Self::validate_request(request)?;\n\n        // Process based on method\n        let data = match &request.method {\n            RequestMethod::Get => Self::handle_get_request(request)?,\n            RequestMethod::Post => Self::handle_post_request(request)?,\n            RequestMethod::Put => Self::handle_put_request(request)?,\n            RequestMethod::Delete => Self::handle_delete_request(request)?,\n            RequestMethod::Patch => Self::handle_patch_request(request)?,\n            RequestMethod::Head => None,\n            RequestMethod::Options => Self::handle_options_request(request)?,\n        };\n\n        // Create response headers\n        let mut headers = HashMap::new();\n        headers.insert(\"Content-Type\".to_string(), \"application/json\".to_string());\n        headers.insert(\"X-Worker-Id\".to_string(), worker_id.to_string());\n        headers.insert(\"X-Request-Id\".to_string(), request.id.clone());\n        headers.insert(\"X-Processing-Time\".to_string(), processing_delay.as_millis().to_string());\n\n        Ok(ServiceResponse {\n            id: request.id.clone(),\n            status: ResponseStatus::Success,\n            data,\n            headers,\n            processing_time: processing_delay,\n            worker_id,\n        })\n    }\n\n    fn calculate_processing_delay(request: &ServiceRequest) -> Duration {\n        let base_delay = Duration::from_millis(10);\n        let priority_multiplier = match request.priority {\n            Priority::Critical => 0.5,\n            Priority::High => 0.75,\n            Priority::Normal => 1.0,\n            Priority::Low => 1.5,\n        };\n\n        let data_size_factor = match &request.data {\n            RequestData::Json(value) => value.to_string().len() as f64 / 1000.0,\n            RequestData::Binary(data) => data.len() as f64 / 1000.0,\n            RequestData::Text(text) => text.len() as f64 / 1000.0,\n            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>() as f64 / 1000.0\n            }\n            RequestData::Empty => 0.0,\n        };\n\n        let total_multiplier = priority_multiplier * (1.0 + data_size_factor);\n        Duration::from_millis((base_delay.as_millis() as f64 * total_multiplier) as u64)\n    }\n\n    fn validate_request(request: &ServiceRequest) -> Result<(), ServiceError> {\n        if request.id.is_empty() {\n            return Err(ServiceError::InvalidInput(\"Request ID cannot be empty\".to_string()));\n        }\n\n        if request.id.len() > 255 {\n            return Err(ServiceError::InvalidInput(\"Request ID too long\".to_string()));\n        }\n\n        // Validate data size\n        let data_size = match &request.data {\n            RequestData::Json(value) => value.to_string().len(),\n            RequestData::Binary(data) => data.len(),\n            RequestData::Text(text) => text.len(),\n            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>()\n            }\n            RequestData::Empty => 0,\n        };\n\n        if data_size > 10_000_000 { // 10MB limit\n            return Err(ServiceError::InvalidInput(\"Request data too large\".to_string()));\n        }\n\n        Ok(())\n    }\n\n    fn handle_get_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate GET processing\n        let response_data = serde_json::json!({\n            \"message\": \"GET request processed successfully\",\n            \"request_id\": request.id,\n            \"timestamp\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            \"headers\": request.headers,\n        });\n\n        Ok(Some(ResponseData::Json(response_data)))\n    }\n\n    fn handle_post_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate POST processing with data validation\n        let processed_data = match &request.data {\n            RequestData::Json(value) => {\n                // Simulate JSON processing\n                let mut result = value.clone();\n                if let Some(obj) = result.as_object_mut() {\n                    obj.insert(\"processed\".to_string(), serde_json::Value::Bool(true));\n                    obj.insert(\"processor_id\".to_string(), serde_json::Value::String(request.id.clone()));\n                }\n                result\n            }\n            RequestData::Text(text) => {\n                serde_json::json!({\n                    \"original_text\": text,\n                    \"processed\": true,\n                    \"length\": text.len(),\n                    \"word_count\": text.split_whitespace().count(),\n                })\n            }\n            RequestData::FormData(form) => {\n                serde_json::json!({\n                    \"form_fields\": form,\n                    \"field_count\": form.len(),\n                    \"processed\": true,\n                })\n            }\n            RequestData::Binary(data) => {\n                serde_json::json!({\n                    \"binary_size\": data.len(),\n                    \"processed\": true,\n                    \"checksum\": format!(\"{:x}\", md5::compute(data)),\n                })\n            }\n            RequestData::Empty => {\n                serde_json::json!({\n                    \"message\": \"Empty data processed\",\n                    \"processed\": true,\n                })\n            }\n        };\n\n        Ok(Some(ResponseData::Json(processed_data)))\n    }\n\n    fn handle_put_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate PUT processing (update operation)\n        let response_data = serde_json::json!({\n            \"message\": \"Resource updated successfully\",\n            \"request_id\": request.id,\n            \"updated_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            \"data_size\": match &request.data {\n                RequestData::Json(v) => v.to_string().len(),\n                RequestData::Binary(d) => d.len(),\n                RequestData::Text(t) => t.len(),\n                RequestData::FormData(f) => f.values().map(|v| v.len()).sum::<usize>(),\n                RequestData::Empty => 0,\n            },\n        });\n\n        Ok(Some(ResponseData::Json(response_data)))\n    }\n\n    fn handle_delete_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate DELETE processing\n        let response_data = serde_json::json!({\n            \"message\": \"Resource deleted successfully\",\n            \"request_id\": request.id,\n            \"deleted_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n        });\n\n        Ok(Some(ResponseData::Json(response_data)))\n    }\n\n    fn handle_patch_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate PATCH processing (partial update)\n        let response_data = serde_json::json!({\n            \"message\": \"Resource partially updated\",\n            \"request_id\": request.id,\n            \"patched_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            \"patch_data\": &request.data,\n        });\n\n        Ok(Some(ResponseData::Json(response_data)))\n    }\n\n    fn handle_options_request(_request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // CORS preflight response\n        Ok(Some(ResponseData::Json(serde_json::json!({\n            \"allowed_methods\": [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"HEAD\", \"OPTIONS\"],\n            \"allowed_headers\": [\"Content-Type\", \"Authorization\", \"X-Request-Id\"],\n            \"max_age\": 86400,\n        }))))\n    }\n\n    fn estimate_response_size(response: &ServiceResponse) -> usize {\n        let base_size = std::mem::size_of::<ServiceResponse>();\n        let headers_size = response.headers.iter()\n            .map(|(k, v)| k.len() + v.len())\n            .sum::<usize>();\n\n        let data_size = match &response.data {\n            Some(ResponseData::Json(value)) => value.to_string().len(),\n            Some(ResponseData::Binary(data)) => data.len(),\n            Some(ResponseData::Text(text)) => text.len(),\n            Some(ResponseData::Stream(url)) => url.len(),\n            None => 0,\n        };\n\n        base_size + headers_size + data_size + response.id.len()\n    }\n}\n\n/// Main service orchestrator\npub struct ComplexService {\n    config: ServiceConfig,\n    workers: Vec<Worker>,\n    cache: Arc<LruCache<String, ServiceResponse>>,\n    request_queue: Arc<Mutex<Vec<ServiceRequest>>>,\n    response_store: Arc<Mutex<HashMap<String, ServiceResponse>>>,\n    worker_handles: Vec<thread::JoinHandle<()>>,\n    request_counter: Arc<Mutex<u64>>,\n    service_metrics: Arc<Mutex<ServiceMetrics>>,\n}\n\n#[derive(Debug, Default, Clone)]\npub struct ServiceMetrics {\n    pub total_requests: u64,\n    pub successful_requests: u64,\n    pub failed_requests: u64,\n    pub average_response_time: Duration,\n    pub total_response_time: Duration,\n    pub cache_hit_rate: f64,\n    pub active_workers: usize,\n    pub queue_size: usize,\n}\n\nimpl ComplexService {\n    pub fn new(config: ServiceConfig) -> Result<Self, ServiceError> {\n        Self::validate_config(&config)?;\n\n        let cache = Arc::new(LruCache::new(\n            config.cache_size,\n            Duration::from_secs(300), // 5 minute TTL\n        ));\n\n        let request_queue = Arc::new(Mutex::new(Vec::new()));\n        let response_store = Arc::new(Mutex::new(HashMap::new()));\n\n        let mut workers = Vec::new();\n        for i in 0..config.worker_threads {\n            let worker = Worker::new(\n                i,\n                config.clone(),\n                Arc::clone(&cache),\n                Arc::clone(&request_queue),\n                Arc::clone(&response_store),\n            );\n            workers.push(worker);\n        }\n\n        Ok(Self {\n            config,\n            workers,\n            cache,\n            request_queue,\n            response_store,\n            worker_handles: Vec::new(),\n            request_counter: Arc::new(Mutex::new(0)),\n            service_metrics: Arc::new(Mutex::new(ServiceMetrics::default())),\n        })\n    }\n\n    fn validate_config(config: &ServiceConfig) -> Result<(), ServiceError> {\n        if config.max_connections == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"max_connections must be greater than 0\".to_string()\n            ));\n        }\n\n        if config.worker_threads == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"worker_threads must be greater than 0\".to_string()\n            ));\n        }\n\n        if config.cache_size == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"cache_size must be greater than 0\".to_string()\n            ));\n        }\n\n        if config.timeout.as_secs() == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"timeout must be greater than 0\".to_string()\n            ));\n        }\n\n        Ok(())\n    }\n\n    pub fn start(&mut self) -> Result<(), ServiceError> {\n        if !self.worker_handles.is_empty() {\n            return Err(ServiceError::ConfigurationError(\n                \"Service is already running\".to_string()\n            ));\n        }\n\n        for worker in &self.workers {\n            let handle = worker.start()?;\n            self.worker_handles.push(handle);\n        }\n\n        if self.config.enable_logging {\n            println!(\"ComplexService started with {} workers\", self.config.worker_threads);\n        }\n\n        Ok(())\n    }\n\n    pub fn stop(&mut self) -> Result<(), ServiceError> {\n        // Stop all workers\n        for worker in &self.workers {\n            worker.stop();\n        }\n\n        // Wait for all worker threads to finish\n        while let Some(handle) = self.worker_handles.pop() {\n            if let Err(_) = handle.join() {\n                return Err(ServiceError::WorkerPanic);\n            }\n        }\n\n        if self.config.enable_logging {\n            println!(\"ComplexService stopped\");\n        }\n\n        Ok(())\n    }\n\n    pub fn submit_request(&self, mut request: ServiceRequest) -> Result<String, ServiceError> {\n        // Generate request ID if not provided\n        if request.id.is_empty() {\n            let mut counter = self.request_counter.lock().unwrap();\n            *counter += 1;\n            request.id = format!(\"req_{:08x}\", *counter);\n        }\n\n        // Validate request\n        Self::validate_request_limits(&request, &self.config)?;\n\n        // Add to queue\n        {\n            let mut queue = self.request_queue.lock().unwrap();\n            if queue.len() >= self.config.max_connections {\n                return Err(ServiceError::CacheFull); // Queue full, reusing error type\n            }\n\n            // Insert based on priority\n            let insert_pos = queue.iter().position(|r| r.priority < request.priority)\n                .unwrap_or(queue.len());\n            queue.insert(insert_pos, request.clone());\n        }\n\n        // Update metrics\n        {\n            let mut metrics = self.service_metrics.lock().unwrap();\n            metrics.total_requests += 1;\n            metrics.queue_size = self.request_queue.lock().unwrap().len();\n        }\n\n        Ok(request.id)\n    }\n\n    fn validate_request_limits(request: &ServiceRequest, config: &ServiceConfig) -> Result<(), ServiceError> {\n        // Implement rate limiting and validation logic here\n        let data_size = match &request.data {\n            RequestData::Json(value) => value.to_string().len(),\n            RequestData::Binary(data) => data.len(),\n            RequestData::Text(text) => text.len(),\n            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>()\n            }\n            RequestData::Empty => 0,\n        };\n\n        // Example size limit: 50MB\n        if data_size > 50_000_000 {\n            return Err(ServiceError::InvalidInput(\n                \"Request data exceeds maximum size limit\".to_string()\n            ));\n        }\n\n        Ok(())\n    }\n\n    pub fn get_response(&self, request_id: &str) -> Option<ServiceResponse> {\n        let mut store = self.response_store.lock().unwrap();\n        store.remove(request_id)\n    }\n\n    pub fn wait_for_response(&self, request_id: &str, timeout: Duration) -> Result<ServiceResponse, ServiceError> {\n        let start = Instant::now();\n\n        loop {\n            if let Some(response) = self.get_response(request_id) {\n                // Update success metrics\n                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.successful_requests += 1;\n                    let response_time = start.elapsed();\n                    metrics.total_response_time += response_time;\n                    metrics.average_response_time =\n                        metrics.total_response_time / metrics.successful_requests as u32;\n                }\n                return Ok(response);\n            }\n\n            if start.elapsed() > timeout {\n                // Update failure metrics\n                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.failed_requests += 1;\n                }\n                return Err(ServiceError::Timeout);\n            }\n\n            thread::sleep(Duration::from_millis(10));\n        }\n    }\n\n    pub fn metrics(&self) -> ServiceMetrics {\n        let mut metrics = self.service_metrics.lock().unwrap().clone();\n        metrics.active_workers = self.worker_handles.len();\n        metrics.queue_size = self.request_queue.lock().unwrap().len();\n\n        let cache_stats = self.cache.stats();\n        metrics.cache_hit_rate = cache_stats.hit_rate();\n\n        metrics\n    }\n\n    pub fn worker_metrics(&self) -> Vec<WorkerMetrics> {\n        self.workers.iter().map(|w| w.metrics()).collect()\n    }\n\n    pub fn cache_stats(&self) -> CacheStats {\n        self.cache.stats()\n    }\n\n    pub fn clear_cache(&self) {\n        self.cache.clear();\n    }\n\n    pub fn health_check(&self) -> Result<serde_json::Value, ServiceError> {\n        let metrics = self.metrics();\n        let cache_stats = self.cache_stats();\n        let worker_metrics = self.worker_metrics();\n\n        Ok(serde_json::json!({\n            \"status\": \"healthy\",\n            \"service_metrics\": {\n                \"total_requests\": metrics.total_requests,\n                \"successful_requests\": metrics.successful_requests,\n                \"failed_requests\": metrics.failed_requests,\n                \"average_response_time_ms\": metrics.average_response_time.as_millis(),\n                \"cache_hit_rate\": metrics.cache_hit_rate,\n                \"active_workers\": metrics.active_workers,\n                \"queue_size\": metrics.queue_size,\n            },\n            \"cache_stats\": {\n                \"hits\": cache_stats.hits,\n                \"misses\": cache_stats.misses,\n                \"evictions\": cache_stats.evictions,\n                \"size\": cache_stats.size,\n                \"capacity\": cache_stats.capacity,\n                \"hit_rate\": cache_stats.hit_rate(),\n            },\n            \"worker_metrics\": worker_metrics,\n            \"config\": {\n                \"max_connections\": self.config.max_connections,\n                \"timeout_secs\": self.config.timeout.as_secs(),\n                \"retry_count\": self.config.retry_count,\n                \"cache_size\": self.config.cache_size,\n                \"worker_threads\": self.config.worker_threads,\n            }\n        }))\n    }\n}",
      "content_length": 33308,
      "difficulty": "Some(Zen)",
      "end_line": 997,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 1
    },
    {
      "code_content": "impl Worker {\n    pub fn new(\n        id: usize,\n        config: ServiceConfig,\n        cache: Arc<LruCache<String, ServiceResponse>>,\n        request_queue: Arc<Mutex<Vec<ServiceRequest>>>,\n        response_sender: Arc<Mutex<HashMap<String, ServiceResponse>>>,\n    ) -> Self {\n        Self {\n            id,\n            config,\n            cache,\n            request_queue,\n            response_sender,\n            is_running: Arc::new(Mutex::new(false)),\n            metrics: Arc::new(Mutex::new(WorkerMetrics::default())),\n        }\n    }\n\n    pub fn start(&self) -> Result<thread::JoinHandle<()>, ServiceError> {\n        let id = self.id;\n        let config = self.config.clone();\n        let cache = Arc::clone(&self.cache);",
      "content_length": 729,
      "difficulty": "Some(Hard)",
      "end_line": 387,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 365
    },
    {
      "code_content": "impl Worker {\n    pub fn new(\n        id: usize,\n        config: ServiceConfig,\n        cache: Arc<LruCache<String, ServiceResponse>>,\n        request_queue: Arc<Mutex<Vec<ServiceRequest>>>,\n        response_sender: Arc<Mutex<HashMap<String, ServiceResponse>>>,\n    ) -> Self {\n        Self {\n            id,\n            config,\n            cache,\n            request_queue,\n            response_sender,\n            is_running: Arc::new(Mutex::new(false)),\n            metrics: Arc::new(Mutex::new(WorkerMetrics::default())),\n        }\n    }\n\n    pub fn start(&self) -> Result<thread::JoinHandle<()>, ServiceError> {\n        let id = self.id;\n        let config = self.config.clone();\n        let cache = Arc::clone(&self.cache);\n        let request_queue = Arc::clone(&self.request_queue);\n        let response_sender = Arc::clone(&self.response_sender);\n        let is_running = Arc::clone(&self.is_running);\n        let metrics = Arc::clone(&self.metrics);\n\n        {\n            let mut running = is_running.lock().unwrap();\n            *running = true;\n        }\n\n        let handle = thread::spawn(move || {\n            let mut local_metrics = WorkerMetrics::default();\n\n            loop {\n                let should_continue = {\n                    let running = is_running.lock().unwrap();\n                    *running\n                };\n\n                if !should_continue {\n                    break;\n                }\n\n                // Get next request\n                let request = {\n                    let mut queue = request_queue.lock().unwrap();\n                    queue.pop()\n                };\n\n                if let Some(req) = request {\n                    let start_time = Instant::now();\n\n                    // Check cache first\n                    let cached_response = cache.get(&req.id);\n\n                    let response = if let Some(cached) = cached_response {\n                        local_metrics.cache_hits += 1;\n                        cached\n                    } else {\n                        local_metrics.cache_misses += 1;\n\n                        // Process request\n                        match Self::process_request(&req, &config, id) {\n                            Ok(resp) => {\n                                // Cache the response\n                                let response_size = Self::estimate_response_size(&resp);\n                                if let Err(e) = cache.put(req.id.clone(), resp.clone(), response_size) {\n                                    if config.enable_logging {\n                                        eprintln!(\"Worker {}: Failed to cache response: {:?}\", id, e);\n                                    }\n                                }\n                                resp\n                            }\n                            Err(e) => {\n                                local_metrics.errors_encountered += 1;\n                                ServiceResponse {\n                                    id: req.id.clone(),\n                                    status: ResponseStatus::InternalError,\n                                    data: Some(ResponseData::Text(format!(\"Error: {}\", e))),\n                                    headers: HashMap::new(),\n                                    processing_time: start_time.elapsed(),\n                                    worker_id: id,\n                                }\n                            }\n                        }\n                    };\n\n                    let processing_time = start_time.elapsed();\n                    local_metrics.requests_processed += 1;\n                    local_metrics.total_processing_time += processing_time;\n                    local_metrics.average_processing_time =\n                        local_metrics.total_processing_time / local_metrics.requests_processed as u32;\n\n                    // Send response\n                    {\n                        let mut sender = response_sender.lock().unwrap();\n                        sender.insert(req.id.clone(), response);\n                    }\n                } else {\n                    // No requests available, sleep briefly\n                    thread::sleep(Duration::from_millis(10));\n                }\n\n                // Update metrics periodically\n                if local_metrics.requests_processed % 100 == 0 {\n                    let mut global_metrics = metrics.lock().unwrap();\n                    *global_metrics = local_metrics.clone();\n                }\n            }\n\n            // Final metrics update\n            let mut global_metrics = metrics.lock().unwrap();\n            *global_metrics = local_metrics;\n        });\n\n        Ok(handle)\n    }\n\n    pub fn stop(&self) {\n        let mut running = self.is_running.lock().unwrap();\n        *running = false;\n    }\n\n    pub fn metrics(&self) -> WorkerMetrics {\n        self.metrics.lock().unwrap().clone()\n    }\n\n    fn process_request(\n        request: &ServiceRequest,\n        config: &ServiceConfig,\n        worker_id: usize,\n    ) -> Result<ServiceResponse, ServiceError> {\n        // Simulate processing time based on request complexity\n        let processing_delay = Self::calculate_processing_delay(&request);\n        thread::sleep(processing_delay);\n\n        // Validate request\n        Self::validate_request(request)?;\n\n        // Process based on method\n        let data = match &request.method {\n            RequestMethod::Get => Self::handle_get_request(request)?,\n            RequestMethod::Post => Self::handle_post_request(request)?,\n            RequestMethod::Put => Self::handle_put_request(request)?,\n            RequestMethod::Delete => Self::handle_delete_request(request)?,\n            RequestMethod::Patch => Self::handle_patch_request(request)?,\n            RequestMethod::Head => None,\n            RequestMethod::Options => Self::handle_options_request(request)?,\n        };\n\n        // Create response headers\n        let mut headers = HashMap::new();\n        headers.insert(\"Content-Type\".to_string(), \"application/json\".to_string());\n        headers.insert(\"X-Worker-Id\".to_string(), worker_id.to_string());\n        headers.insert(\"X-Request-Id\".to_string(), request.id.clone());\n        headers.insert(\"X-Processing-Time\".to_string(), processing_delay.as_millis().to_string());\n\n        Ok(ServiceResponse {\n            id: request.id.clone(),\n            status: ResponseStatus::Success,\n            data,\n            headers,\n            processing_time: processing_delay,\n            worker_id,\n        })\n    }\n\n    fn calculate_processing_delay(request: &ServiceRequest) -> Duration {\n        let base_delay = Duration::from_millis(10);\n        let priority_multiplier = match request.priority {\n            Priority::Critical => 0.5,\n            Priority::High => 0.75,\n            Priority::Normal => 1.0,\n            Priority::Low => 1.5,\n        };\n\n        let data_size_factor = match &request.data {\n            RequestData::Json(value) => value.to_string().len() as f64 / 1000.0,\n            RequestData::Binary(data) => data.len() as f64 / 1000.0,\n            RequestData::Text(text) => text.len() as f64 / 1000.0,\n            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>() as f64 / 1000.0\n            }\n            RequestData::Empty => 0.0,\n        };\n\n        let total_multiplier = priority_multiplier * (1.0 + data_size_factor);\n        Duration::from_millis((base_delay.as_millis() as f64 * total_multiplier) as u64)\n    }\n\n    fn validate_request(request: &ServiceRequest) -> Result<(), ServiceError> {\n        if request.id.is_empty() {\n            return Err(ServiceError::InvalidInput(\"Request ID cannot be empty\".to_string()));\n        }\n\n        if request.id.len() > 255 {\n            return Err(ServiceError::InvalidInput(\"Request ID too long\".to_string()));\n        }\n\n        // Validate data size\n        let data_size = match &request.data {\n            RequestData::Json(value) => value.to_string().len(),\n            RequestData::Binary(data) => data.len(),\n            RequestData::Text(text) => text.len(),\n            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>()\n            }\n            RequestData::Empty => 0,\n        };\n\n        if data_size > 10_000_000 { // 10MB limit\n            return Err(ServiceError::InvalidInput(\"Request data too large\".to_string()));\n        }\n\n        Ok(())\n    }\n\n    fn handle_get_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate GET processing\n        let response_data = serde_json::json!({\n            \"message\": \"GET request processed successfully\",\n            \"request_id\": request.id,\n            \"timestamp\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            \"headers\": request.headers,\n        });\n\n        Ok(Some(ResponseData::Json(response_data)))\n    }\n\n    fn handle_post_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate POST processing with data validation\n        let processed_data = match &request.data {\n            RequestData::Json(value) => {\n                // Simulate JSON processing\n                let mut result = value.clone();\n                if let Some(obj) = result.as_object_mut() {\n                    obj.insert(\"processed\".to_string(), serde_json::Value::Bool(true));\n                    obj.insert(\"processor_id\".to_string(), serde_json::Value::String(request.id.clone()));\n                }\n                result\n            }\n            RequestData::Text(text) => {\n                serde_json::json!({\n                    \"original_text\": text,\n                    \"processed\": true,\n                    \"length\": text.len(),\n                    \"word_count\": text.split_whitespace().count(),\n                })\n            }\n            RequestData::FormData(form) => {\n                serde_json::json!({\n                    \"form_fields\": form,\n                    \"field_count\": form.len(),\n                    \"processed\": true,\n                })\n            }\n            RequestData::Binary(data) => {\n                serde_json::json!({\n                    \"binary_size\": data.len(),\n                    \"processed\": true,\n                    \"checksum\": format!(\"{:x}\", md5::compute(data)),\n                })\n            }\n            RequestData::Empty => {\n                serde_json::json!({\n                    \"message\": \"Empty data processed\",\n                    \"processed\": true,\n                })\n            }\n        };\n\n        Ok(Some(ResponseData::Json(processed_data)))\n    }\n\n    fn handle_put_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate PUT processing (update operation)\n        let response_data = serde_json::json!({\n            \"message\": \"Resource updated successfully\",\n            \"request_id\": request.id,\n            \"updated_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            \"data_size\": match &request.data {\n                RequestData::Json(v) => v.to_string().len(),\n                RequestData::Binary(d) => d.len(),\n                RequestData::Text(t) => t.len(),\n                RequestData::FormData(f) => f.values().map(|v| v.len()).sum::<usize>(),\n                RequestData::Empty => 0,\n            },\n        });\n\n        Ok(Some(ResponseData::Json(response_data)))\n    }\n\n    fn handle_delete_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate DELETE processing\n        let response_data = serde_json::json!({\n            \"message\": \"Resource deleted successfully\",\n            \"request_id\": request.id,\n            \"deleted_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n        });\n\n        Ok(Some(ResponseData::Json(response_data)))\n    }\n\n    fn handle_patch_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate PATCH processing (partial update)\n        let response_data = serde_json::json!({\n            \"message\": \"Resource partially updated\",\n            \"request_id\": request.id,\n            \"patched_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            \"patch_data\": &request.data,\n        });\n\n        Ok(Some(ResponseData::Json(response_data)))\n    }\n\n    fn handle_options_request(_request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // CORS preflight response\n        Ok(Some(ResponseData::Json(serde_json::json!({\n            \"allowed_methods\": [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"HEAD\", \"OPTIONS\"],\n            \"allowed_headers\": [\"Content-Type\", \"Authorization\", \"X-Request-Id\"],\n            \"max_age\": 86400,\n        }))))\n    }\n\n    fn estimate_response_size(response: &ServiceResponse) -> usize {\n        let base_size = std::mem::size_of::<ServiceResponse>();\n        let headers_size = response.headers.iter()\n            .map(|(k, v)| k.len() + v.len())\n            .sum::<usize>();\n\n        let data_size = match &response.data {\n            Some(ResponseData::Json(value)) => value.to_string().len(),\n            Some(ResponseData::Binary(data)) => data.len(),\n            Some(ResponseData::Text(text)) => text.len(),\n            Some(ResponseData::Stream(url)) => url.len(),\n            None => 0,\n        };\n\n        base_size + headers_size + data_size + response.id.len()\n    }\n}",
      "content_length": 13784,
      "difficulty": "Some(Wild)",
      "end_line": 720,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 365
    },
    {
      "code_content": "impl ComplexService {\n    pub fn new(config: ServiceConfig) -> Result<Self, ServiceError> {\n        Self::validate_config(&config)?;\n\n        let cache = Arc::new(LruCache::new(\n            config.cache_size,\n            Duration::from_secs(300), // 5 minute TTL\n        ));",
      "content_length": 274,
      "difficulty": "Some(Normal)",
      "end_line": 754,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 746
    },
    {
      "code_content": "impl ComplexService {\n    pub fn new(config: ServiceConfig) -> Result<Self, ServiceError> {\n        Self::validate_config(&config)?;\n\n        let cache = Arc::new(LruCache::new(\n            config.cache_size,\n            Duration::from_secs(300), // 5 minute TTL\n        ));\n\n        let request_queue = Arc::new(Mutex::new(Vec::new()));\n        let response_store = Arc::new(Mutex::new(HashMap::new()));\n\n        let mut workers = Vec::new();\n        for i in 0..config.worker_threads {\n            let worker = Worker::new(\n                i,\n                config.clone(),\n                Arc::clone(&cache),\n                Arc::clone(&request_queue),\n                Arc::clone(&response_store),\n            );\n            workers.push(worker);\n        }",
      "content_length": 760,
      "difficulty": "Some(Hard)",
      "end_line": 769,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 746
    },
    {
      "code_content": "impl ComplexService {\n    pub fn new(config: ServiceConfig) -> Result<Self, ServiceError> {\n        Self::validate_config(&config)?;\n\n        let cache = Arc::new(LruCache::new(\n            config.cache_size,\n            Duration::from_secs(300), // 5 minute TTL\n        ));\n\n        let request_queue = Arc::new(Mutex::new(Vec::new()));\n        let response_store = Arc::new(Mutex::new(HashMap::new()));\n\n        let mut workers = Vec::new();\n        for i in 0..config.worker_threads {\n            let worker = Worker::new(\n                i,\n                config.clone(),\n                Arc::clone(&cache),\n                Arc::clone(&request_queue),\n                Arc::clone(&response_store),\n            );\n            workers.push(worker);\n        }\n\n        Ok(Self {\n            config,\n            workers,\n            cache,\n            request_queue,\n            response_store,\n            worker_handles: Vec::new(),\n            request_counter: Arc::new(Mutex::new(0)),\n            service_metrics: Arc::new(Mutex::new(ServiceMetrics::default())),\n        })\n    }\n\n    fn validate_config(config: &ServiceConfig) -> Result<(), ServiceError> {\n        if config.max_connections == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"max_connections must be greater than 0\".to_string()\n            ));\n        }\n\n        if config.worker_threads == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"worker_threads must be greater than 0\".to_string()\n            ));\n        }\n\n        if config.cache_size == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"cache_size must be greater than 0\".to_string()\n            ));\n        }\n\n        if config.timeout.as_secs() == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"timeout must be greater than 0\".to_string()\n            ));\n        }\n\n        Ok(())\n    }\n\n    pub fn start(&mut self) -> Result<(), ServiceError> {\n        if !self.worker_handles.is_empty() {\n            return Err(ServiceError::ConfigurationError(\n                \"Service is already running\".to_string()\n            ));\n        }\n\n        for worker in &self.workers {\n            let handle = worker.start()?;\n            self.worker_handles.push(handle);\n        }\n\n        if self.config.enable_logging {\n            println!(\"ComplexService started with {} workers\", self.config.worker_threads);\n        }\n\n        Ok(())\n    }\n\n    pub fn stop(&mut self) -> Result<(), ServiceError> {\n        // Stop all workers\n        for worker in &self.workers {\n            worker.stop();\n        }\n\n        // Wait for all worker threads to finish\n        while let Some(handle) = self.worker_handles.pop() {\n            if let Err(_) = handle.join() {\n                return Err(ServiceError::WorkerPanic);\n            }\n        }\n\n        if self.config.enable_logging {\n            println!(\"ComplexService stopped\");\n        }\n\n        Ok(())\n    }\n\n    pub fn submit_request(&self, mut request: ServiceRequest) -> Result<String, ServiceError> {\n        // Generate request ID if not provided\n        if request.id.is_empty() {\n            let mut counter = self.request_counter.lock().unwrap();\n            *counter += 1;\n            request.id = format!(\"req_{:08x}\", *counter);\n        }\n\n        // Validate request\n        Self::validate_request_limits(&request, &self.config)?;\n\n        // Add to queue\n        {\n            let mut queue = self.request_queue.lock().unwrap();\n            if queue.len() >= self.config.max_connections {\n                return Err(ServiceError::CacheFull); // Queue full, reusing error type\n            }\n\n            // Insert based on priority\n            let insert_pos = queue.iter().position(|r| r.priority < request.priority)\n                .unwrap_or(queue.len());\n            queue.insert(insert_pos, request.clone());\n        }\n\n        // Update metrics\n        {\n            let mut metrics = self.service_metrics.lock().unwrap();\n            metrics.total_requests += 1;\n            metrics.queue_size = self.request_queue.lock().unwrap().len();\n        }\n\n        Ok(request.id)\n    }\n\n    fn validate_request_limits(request: &ServiceRequest, config: &ServiceConfig) -> Result<(), ServiceError> {\n        // Implement rate limiting and validation logic here\n        let data_size = match &request.data {\n            RequestData::Json(value) => value.to_string().len(),\n            RequestData::Binary(data) => data.len(),\n            RequestData::Text(text) => text.len(),\n            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>()\n            }\n            RequestData::Empty => 0,\n        };\n\n        // Example size limit: 50MB\n        if data_size > 50_000_000 {\n            return Err(ServiceError::InvalidInput(\n                \"Request data exceeds maximum size limit\".to_string()\n            ));\n        }\n\n        Ok(())\n    }\n\n    pub fn get_response(&self, request_id: &str) -> Option<ServiceResponse> {\n        let mut store = self.response_store.lock().unwrap();\n        store.remove(request_id)\n    }\n\n    pub fn wait_for_response(&self, request_id: &str, timeout: Duration) -> Result<ServiceResponse, ServiceError> {\n        let start = Instant::now();\n\n        loop {\n            if let Some(response) = self.get_response(request_id) {\n                // Update success metrics\n                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.successful_requests += 1;\n                    let response_time = start.elapsed();\n                    metrics.total_response_time += response_time;\n                    metrics.average_response_time =\n                        metrics.total_response_time / metrics.successful_requests as u32;\n                }\n                return Ok(response);\n            }\n\n            if start.elapsed() > timeout {\n                // Update failure metrics\n                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.failed_requests += 1;\n                }\n                return Err(ServiceError::Timeout);\n            }\n\n            thread::sleep(Duration::from_millis(10));\n        }\n    }\n\n    pub fn metrics(&self) -> ServiceMetrics {\n        let mut metrics = self.service_metrics.lock().unwrap().clone();\n        metrics.active_workers = self.worker_handles.len();\n        metrics.queue_size = self.request_queue.lock().unwrap().len();\n\n        let cache_stats = self.cache.stats();\n        metrics.cache_hit_rate = cache_stats.hit_rate();\n\n        metrics\n    }\n\n    pub fn worker_metrics(&self) -> Vec<WorkerMetrics> {\n        self.workers.iter().map(|w| w.metrics()).collect()\n    }\n\n    pub fn cache_stats(&self) -> CacheStats {\n        self.cache.stats()\n    }\n\n    pub fn clear_cache(&self) {\n        self.cache.clear();\n    }\n\n    pub fn health_check(&self) -> Result<serde_json::Value, ServiceError> {\n        let metrics = self.metrics();\n        let cache_stats = self.cache_stats();\n        let worker_metrics = self.worker_metrics();\n\n        Ok(serde_json::json!({\n            \"status\": \"healthy\",\n            \"service_metrics\": {\n                \"total_requests\": metrics.total_requests,\n                \"successful_requests\": metrics.successful_requests,\n                \"failed_requests\": metrics.failed_requests,\n                \"average_response_time_ms\": metrics.average_response_time.as_millis(),\n                \"cache_hit_rate\": metrics.cache_hit_rate,\n                \"active_workers\": metrics.active_workers,\n                \"queue_size\": metrics.queue_size,\n            },\n            \"cache_stats\": {\n                \"hits\": cache_stats.hits,\n                \"misses\": cache_stats.misses,\n                \"evictions\": cache_stats.evictions,\n                \"size\": cache_stats.size,\n                \"capacity\": cache_stats.capacity,\n                \"hit_rate\": cache_stats.hit_rate(),\n            },\n            \"worker_metrics\": worker_metrics,\n            \"config\": {\n                \"max_connections\": self.config.max_connections,\n                \"timeout_secs\": self.config.timeout.as_secs(),\n                \"retry_count\": self.config.retry_count,\n                \"cache_size\": self.config.cache_size,\n                \"worker_threads\": self.config.worker_threads,\n            }\n        }))\n    }\n}",
      "content_length": 8457,
      "difficulty": "Some(Wild)",
      "end_line": 997,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 746
    },
    {
      "code_content": "    pub fn start(&self) -> Result<thread::JoinHandle<()>, ServiceError> {\n        let id = self.id;",
      "content_length": 99,
      "difficulty": "Some(Easy)",
      "end_line": 385,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 384
    },
    {
      "code_content": "    pub fn start(&self) -> Result<thread::JoinHandle<()>, ServiceError> {\n        let id = self.id;\n        let config = self.config.clone();\n        let cache = Arc::clone(&self.cache);\n        let request_queue = Arc::clone(&self.request_queue);",
      "content_length": 247,
      "difficulty": "Some(Normal)",
      "end_line": 388,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 384
    },
    {
      "code_content": "    pub fn start(&self) -> Result<thread::JoinHandle<()>, ServiceError> {\n        let id = self.id;\n        let config = self.config.clone();\n        let cache = Arc::clone(&self.cache);\n        let request_queue = Arc::clone(&self.request_queue);\n        let response_sender = Arc::clone(&self.response_sender);\n        let is_running = Arc::clone(&self.is_running);\n        let metrics = Arc::clone(&self.metrics);\n\n        {\n            let mut running = is_running.lock().unwrap();\n            *running = true;\n        }\n\n        let handle = thread::spawn(move || {\n            let mut local_metrics = WorkerMetrics::default();",
      "content_length": 632,
      "difficulty": "Some(Hard)",
      "end_line": 400,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 384
    },
    {
      "code_content": "    pub fn start(&self) -> Result<thread::JoinHandle<()>, ServiceError> {\n        let id = self.id;\n        let config = self.config.clone();\n        let cache = Arc::clone(&self.cache);\n        let request_queue = Arc::clone(&self.request_queue);\n        let response_sender = Arc::clone(&self.response_sender);\n        let is_running = Arc::clone(&self.is_running);\n        let metrics = Arc::clone(&self.metrics);\n\n        {\n            let mut running = is_running.lock().unwrap();\n            *running = true;\n        }\n\n        let handle = thread::spawn(move || {\n            let mut local_metrics = WorkerMetrics::default();\n\n            loop {\n                let should_continue = {\n                    let running = is_running.lock().unwrap();\n                    *running\n                };\n\n                if !should_continue {\n                    break;\n                }\n\n                // Get next request\n                let request = {\n                    let mut queue = request_queue.lock().unwrap();\n                    queue.pop()\n                };\n\n                if let Some(req) = request {\n                    let start_time = Instant::now();\n\n                    // Check cache first\n                    let cached_response = cache.get(&req.id);\n\n                    let response = if let Some(cached) = cached_response {\n                        local_metrics.cache_hits += 1;\n                        cached\n                    } else {\n                        local_metrics.cache_misses += 1;\n\n                        // Process request\n                        match Self::process_request(&req, &config, id) {\n                            Ok(resp) => {\n                                // Cache the response\n                                let response_size = Self::estimate_response_size(&resp);\n                                if let Err(e) = cache.put(req.id.clone(), resp.clone(), response_size) {\n                                    if config.enable_logging {\n                                        eprintln!(\"Worker {}: Failed to cache response: {:?}\", id, e);\n                                    }\n                                }\n                                resp\n                            }\n                            Err(e) => {\n                                local_metrics.errors_encountered += 1;\n                                ServiceResponse {\n                                    id: req.id.clone(),\n                                    status: ResponseStatus::InternalError,\n                                    data: Some(ResponseData::Text(format!(\"Error: {}\", e))),\n                                    headers: HashMap::new(),\n                                    processing_time: start_time.elapsed(),\n                                    worker_id: id,\n                                }\n                            }\n                        }\n                    };\n\n                    let processing_time = start_time.elapsed();\n                    local_metrics.requests_processed += 1;\n                    local_metrics.total_processing_time += processing_time;\n                    local_metrics.average_processing_time =\n                        local_metrics.total_processing_time / local_metrics.requests_processed as u32;\n\n                    // Send response\n                    {\n                        let mut sender = response_sender.lock().unwrap();\n                        sender.insert(req.id.clone(), response);\n                    }\n                } else {\n                    // No requests available, sleep briefly\n                    thread::sleep(Duration::from_millis(10));\n                }\n\n                // Update metrics periodically\n                if local_metrics.requests_processed % 100 == 0 {\n                    let mut global_metrics = metrics.lock().unwrap();\n                    *global_metrics = local_metrics.clone();\n                }\n            }\n\n            // Final metrics update\n            let mut global_metrics = metrics.lock().unwrap();\n            *global_metrics = local_metrics;\n        });\n\n        Ok(handle)\n    }",
      "content_length": 4128,
      "difficulty": "Some(Wild)",
      "end_line": 484,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 384
    },
    {
      "code_content": "    fn handle_post_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {",
      "content_length": 100,
      "difficulty": "Some(Easy)",
      "end_line": 600,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 600
    },
    {
      "code_content": "    fn handle_post_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate POST processing with data validation\n        let processed_data = match &request.data {\n            RequestData::Json(value) => {\n                // Simulate JSON processing\n                let mut result = value.clone();",
      "content_length": 342,
      "difficulty": "Some(Normal)",
      "end_line": 605,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 600
    },
    {
      "code_content": "    fn handle_post_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate POST processing with data validation\n        let processed_data = match &request.data {\n            RequestData::Json(value) => {\n                // Simulate JSON processing\n                let mut result = value.clone();\n                if let Some(obj) = result.as_object_mut() {\n                    obj.insert(\"processed\".to_string(), serde_json::Value::Bool(true));\n                    obj.insert(\"processor_id\".to_string(), serde_json::Value::String(request.id.clone()));\n                }\n                result\n            }",
      "content_length": 652,
      "difficulty": "Some(Hard)",
      "end_line": 611,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 600
    },
    {
      "code_content": "    fn handle_post_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate POST processing with data validation\n        let processed_data = match &request.data {\n            RequestData::Json(value) => {\n                // Simulate JSON processing\n                let mut result = value.clone();\n                if let Some(obj) = result.as_object_mut() {\n                    obj.insert(\"processed\".to_string(), serde_json::Value::Bool(true));\n                    obj.insert(\"processor_id\".to_string(), serde_json::Value::String(request.id.clone()));\n                }\n                result\n            }\n            RequestData::Text(text) => {\n                serde_json::json!({\n                    \"original_text\": text,\n                    \"processed\": true,\n                    \"length\": text.len(),\n                    \"word_count\": text.split_whitespace().count(),\n                })\n            }\n            RequestData::FormData(form) => {\n                serde_json::json!({\n                    \"form_fields\": form,\n                    \"field_count\": form.len(),\n                    \"processed\": true,\n                })\n            }\n            RequestData::Binary(data) => {\n                serde_json::json!({\n                    \"binary_size\": data.len(),\n                    \"processed\": true,\n                    \"checksum\": format!(\"{:x}\", md5::compute(data)),\n                })\n            }\n            RequestData::Empty => {\n                serde_json::json!({\n                    \"message\": \"Empty data processed\",\n                    \"processed\": true,\n                })\n            }\n        };\n\n        Ok(Some(ResponseData::Json(processed_data)))\n    }",
      "content_length": 1731,
      "difficulty": "Some(Wild)",
      "end_line": 643,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 600
    },
    {
      "code_content": "                    let response = if let Some(cached) = cached_response {\n                        local_metrics.cache_hits += 1;",
      "content_length": 129,
      "difficulty": "Some(Easy)",
      "end_line": 424,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 423
    },
    {
      "code_content": "                    let response = if let Some(cached) = cached_response {\n                        local_metrics.cache_hits += 1;\n                        cached\n                    } else {\n                        local_metrics.cache_misses += 1;",
      "content_length": 246,
      "difficulty": "Some(Normal)",
      "end_line": 428,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 423
    },
    {
      "code_content": "                    let response = if let Some(cached) = cached_response {\n                        local_metrics.cache_hits += 1;\n                        cached\n                    } else {\n                        local_metrics.cache_misses += 1;\n\n                        // Process request\n                        match Self::process_request(&req, &config, id) {\n                            Ok(resp) => {\n                                // Cache the response\n                                let response_size = Self::estimate_response_size(&resp);\n                                if let Err(e) = cache.put(req.id.clone(), resp.clone(), response_size) {\n                                    if config.enable_logging {\n                                        eprintln!(\"Worker {}: Failed to cache response: {:?}\", id, e);\n                                    }\n                                }\n                                resp\n                            }\n                            Err(e) => {\n                                local_metrics.errors_encountered += 1;",
      "content_length": 1069,
      "difficulty": "Some(Hard)",
      "end_line": 442,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 423
    },
    {
      "code_content": "                    let response = if let Some(cached) = cached_response {\n                        local_metrics.cache_hits += 1;\n                        cached\n                    } else {\n                        local_metrics.cache_misses += 1;\n\n                        // Process request\n                        match Self::process_request(&req, &config, id) {\n                            Ok(resp) => {\n                                // Cache the response\n                                let response_size = Self::estimate_response_size(&resp);\n                                if let Err(e) = cache.put(req.id.clone(), resp.clone(), response_size) {\n                                    if config.enable_logging {\n                                        eprintln!(\"Worker {}: Failed to cache response: {:?}\", id, e);\n                                    }\n                                }\n                                resp\n                            }\n                            Err(e) => {\n                                local_metrics.errors_encountered += 1;\n                                ServiceResponse {\n                                    id: req.id.clone(),\n                                    status: ResponseStatus::InternalError,\n                                    data: Some(ResponseData::Text(format!(\"Error: {}\", e))),\n                                    headers: HashMap::new(),\n                                    processing_time: start_time.elapsed(),\n                                    worker_id: id,\n                                }\n                            }\n                        }\n                    }",
      "content_length": 1642,
      "difficulty": "Some(Wild)",
      "end_line": 453,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 423
    },
    {
      "code_content": "    fn process_request(\n        request: &ServiceRequest,\n        config: &ServiceConfig,\n        worker_id: usize,\n    ) -> Result<ServiceResponse, ServiceError> {\n        // Simulate processing time based on request complexity\n        let processing_delay = Self::calculate_processing_delay(&request);",
      "content_length": 303,
      "difficulty": "Some(Normal)",
      "end_line": 501,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 495
    },
    {
      "code_content": "    fn process_request(\n        request: &ServiceRequest,\n        config: &ServiceConfig,\n        worker_id: usize,\n    ) -> Result<ServiceResponse, ServiceError> {\n        // Simulate processing time based on request complexity\n        let processing_delay = Self::calculate_processing_delay(&request);\n        thread::sleep(processing_delay);\n\n        // Validate request\n        Self::validate_request(request)?;",
      "content_length": 415,
      "difficulty": "Some(Hard)",
      "end_line": 506,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 495
    },
    {
      "code_content": "    fn process_request(\n        request: &ServiceRequest,\n        config: &ServiceConfig,\n        worker_id: usize,\n    ) -> Result<ServiceResponse, ServiceError> {\n        // Simulate processing time based on request complexity\n        let processing_delay = Self::calculate_processing_delay(&request);\n        thread::sleep(processing_delay);\n\n        // Validate request\n        Self::validate_request(request)?;\n\n        // Process based on method\n        let data = match &request.method {\n            RequestMethod::Get => Self::handle_get_request(request)?,\n            RequestMethod::Post => Self::handle_post_request(request)?,\n            RequestMethod::Put => Self::handle_put_request(request)?,\n            RequestMethod::Delete => Self::handle_delete_request(request)?,\n            RequestMethod::Patch => Self::handle_patch_request(request)?,\n            RequestMethod::Head => None,\n            RequestMethod::Options => Self::handle_options_request(request)?,\n        };\n\n        // Create response headers\n        let mut headers = HashMap::new();\n        headers.insert(\"Content-Type\".to_string(), \"application/json\".to_string());\n        headers.insert(\"X-Worker-Id\".to_string(), worker_id.to_string());\n        headers.insert(\"X-Request-Id\".to_string(), request.id.clone());\n        headers.insert(\"X-Processing-Time\".to_string(), processing_delay.as_millis().to_string());\n\n        Ok(ServiceResponse {\n            id: request.id.clone(),\n            status: ResponseStatus::Success,\n            data,\n            headers,\n            processing_time: processing_delay,\n            worker_id,\n        })\n    }",
      "content_length": 1630,
      "difficulty": "Some(Wild)",
      "end_line": 533,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 495
    },
    {
      "code_content": "    ) -> Result<ServiceResponse, ServiceError> {",
      "content_length": 48,
      "difficulty": "Some(Easy)",
      "end_line": 499,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 499
    },
    {
      "code_content": "    ) -> Result<ServiceResponse, ServiceError> {\n        // Simulate processing time based on request complexity\n        let processing_delay = Self::calculate_processing_delay(&request);\n        thread::sleep(processing_delay);\n\n        // Validate request\n        Self::validate_request(request)?;",
      "content_length": 299,
      "difficulty": "Some(Normal)",
      "end_line": 506,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 499
    },
    {
      "code_content": "    ) -> Result<ServiceResponse, ServiceError> {\n        // Simulate processing time based on request complexity\n        let processing_delay = Self::calculate_processing_delay(&request);\n        thread::sleep(processing_delay);\n\n        // Validate request\n        Self::validate_request(request)?;\n\n        // Process based on method\n        let data = match &request.method {\n            RequestMethod::Get => Self::handle_get_request(request)?,\n            RequestMethod::Post => Self::handle_post_request(request)?,\n            RequestMethod::Put => Self::handle_put_request(request)?,\n            RequestMethod::Delete => Self::handle_delete_request(request)?,\n            RequestMethod::Patch => Self::handle_patch_request(request)?,\n            RequestMethod::Head => None,\n            RequestMethod::Options => Self::handle_options_request(request)?,\n        };\n\n        // Create response headers\n        let mut headers = HashMap::new();\n        headers.insert(\"Content-Type\".to_string(), \"application/json\".to_string());\n        headers.insert(\"X-Worker-Id\".to_string(), worker_id.to_string());\n        headers.insert(\"X-Request-Id\".to_string(), request.id.clone());\n        headers.insert(\"X-Processing-Time\".to_string(), processing_delay.as_millis().to_string());\n\n        Ok(ServiceResponse {\n            id: request.id.clone(),\n            status: ResponseStatus::Success,\n            data,\n            headers,\n            processing_time: processing_delay,\n            worker_id,\n        })\n    }",
      "content_length": 1514,
      "difficulty": "Some(Wild)",
      "end_line": 533,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 499
    },
    {
      "code_content": "        let processed_data = match &request.data {\n            RequestData::Json(value) => {\n                // Simulate JSON processing\n                let mut result = value.clone();",
      "content_length": 184,
      "difficulty": "Some(Easy)",
      "end_line": 605,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 602
    },
    {
      "code_content": "        let processed_data = match &request.data {\n            RequestData::Json(value) => {\n                // Simulate JSON processing\n                let mut result = value.clone();\n                if let Some(obj) = result.as_object_mut() {\n                    obj.insert(\"processed\".to_string(), serde_json::Value::Bool(true));",
      "content_length": 332,
      "difficulty": "Some(Normal)",
      "end_line": 607,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 602
    },
    {
      "code_content": "        let processed_data = match &request.data {\n            RequestData::Json(value) => {\n                // Simulate JSON processing\n                let mut result = value.clone();\n                if let Some(obj) = result.as_object_mut() {\n                    obj.insert(\"processed\".to_string(), serde_json::Value::Bool(true));\n                    obj.insert(\"processor_id\".to_string(), serde_json::Value::String(request.id.clone()));\n                }\n                result\n            }\n            RequestData::Text(text) => {\n                serde_json::json!({\n                    \"original_text\": text,\n                    \"processed\": true,\n                    \"length\": text.len(),\n                    \"word_count\": text.split_whitespace().count(),\n                })\n            }",
      "content_length": 795,
      "difficulty": "Some(Hard)",
      "end_line": 619,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 602
    },
    {
      "code_content": "        let processed_data = match &request.data {\n            RequestData::Json(value) => {\n                // Simulate JSON processing\n                let mut result = value.clone();\n                if let Some(obj) = result.as_object_mut() {\n                    obj.insert(\"processed\".to_string(), serde_json::Value::Bool(true));\n                    obj.insert(\"processor_id\".to_string(), serde_json::Value::String(request.id.clone()));\n                }\n                result\n            }\n            RequestData::Text(text) => {\n                serde_json::json!({\n                    \"original_text\": text,\n                    \"processed\": true,\n                    \"length\": text.len(),\n                    \"word_count\": text.split_whitespace().count(),\n                })\n            }\n            RequestData::FormData(form) => {\n                serde_json::json!({\n                    \"form_fields\": form,\n                    \"field_count\": form.len(),\n                    \"processed\": true,\n                })\n            }\n            RequestData::Binary(data) => {\n                serde_json::json!({\n                    \"binary_size\": data.len(),\n                    \"processed\": true,\n                    \"checksum\": format!(\"{:x}\", md5::compute(data)),\n                })\n            }\n            RequestData::Empty => {\n                serde_json::json!({\n                    \"message\": \"Empty data processed\",\n                    \"processed\": true,\n                })\n            }\n        }",
      "content_length": 1512,
      "difficulty": "Some(Wild)",
      "end_line": 640,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 602
    },
    {
      "code_content": "    pub fn health_check(&self) -> Result<serde_json::Value, ServiceError> {\n        let metrics = self.metrics();",
      "content_length": 113,
      "difficulty": "Some(Easy)",
      "end_line": 964,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 963
    },
    {
      "code_content": "    pub fn health_check(&self) -> Result<serde_json::Value, ServiceError> {\n        let metrics = self.metrics();\n        let cache_stats = self.cache_stats();\n        let worker_metrics = self.worker_metrics();",
      "content_length": 211,
      "difficulty": "Some(Normal)",
      "end_line": 967,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 963
    },
    {
      "code_content": "    pub fn health_check(&self) -> Result<serde_json::Value, ServiceError> {\n        let metrics = self.metrics();\n        let cache_stats = self.cache_stats();\n        let worker_metrics = self.worker_metrics();\n\n        Ok(serde_json::json!({\n            \"status\": \"healthy\",\n            \"service_metrics\": {\n                \"total_requests\": metrics.total_requests,\n                \"successful_requests\": metrics.successful_requests,\n                \"failed_requests\": metrics.failed_requests,\n                \"average_response_time_ms\": metrics.average_response_time.as_millis(),\n                \"cache_hit_rate\": metrics.cache_hit_rate,\n                \"active_workers\": metrics.active_workers,\n                \"queue_size\": metrics.queue_size,\n            },\n            \"cache_stats\": {\n                \"hits\": cache_stats.hits,\n                \"misses\": cache_stats.misses,\n                \"evictions\": cache_stats.evictions,\n                \"size\": cache_stats.size,\n                \"capacity\": cache_stats.capacity,\n                \"hit_rate\": cache_stats.hit_rate(),\n            },\n            \"worker_metrics\": worker_metrics,\n            \"config\": {\n                \"max_connections\": self.config.max_connections,\n                \"timeout_secs\": self.config.timeout.as_secs(),\n                \"retry_count\": self.config.retry_count,\n                \"cache_size\": self.config.cache_size,\n                \"worker_threads\": self.config.worker_threads,\n            }\n        }))\n    }",
      "content_length": 1492,
      "difficulty": "Some(Wild)",
      "end_line": 996,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 963
    },
    {
      "code_content": "                    } else {\n                        local_metrics.cache_misses += 1;",
      "content_length": 85,
      "difficulty": "Some(Easy)",
      "end_line": 428,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 426
    },
    {
      "code_content": "                    } else {\n                        local_metrics.cache_misses += 1;\n\n                        // Process request\n                        match Self::process_request(&req, &config, id) {\n                            Ok(resp) => {\n                                // Cache the response\n                                let response_size = Self::estimate_response_size(&resp);",
      "content_length": 387,
      "difficulty": "Some(Normal)",
      "end_line": 433,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 426
    },
    {
      "code_content": "                    } else {\n                        local_metrics.cache_misses += 1;\n\n                        // Process request\n                        match Self::process_request(&req, &config, id) {\n                            Ok(resp) => {\n                                // Cache the response\n                                let response_size = Self::estimate_response_size(&resp);\n                                if let Err(e) = cache.put(req.id.clone(), resp.clone(), response_size) {\n                                    if config.enable_logging {\n                                        eprintln!(\"Worker {}: Failed to cache response: {:?}\", id, e);\n                                    }\n                                }\n                                resp\n                            }\n                            Err(e) => {\n                                local_metrics.errors_encountered += 1;",
      "content_length": 908,
      "difficulty": "Some(Hard)",
      "end_line": 442,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 426
    },
    {
      "code_content": "                    } else {\n                        local_metrics.cache_misses += 1;\n\n                        // Process request\n                        match Self::process_request(&req, &config, id) {\n                            Ok(resp) => {\n                                // Cache the response\n                                let response_size = Self::estimate_response_size(&resp);\n                                if let Err(e) = cache.put(req.id.clone(), resp.clone(), response_size) {\n                                    if config.enable_logging {\n                                        eprintln!(\"Worker {}: Failed to cache response: {:?}\", id, e);\n                                    }\n                                }\n                                resp\n                            }\n                            Err(e) => {\n                                local_metrics.errors_encountered += 1;\n                                ServiceResponse {\n                                    id: req.id.clone(),\n                                    status: ResponseStatus::InternalError,\n                                    data: Some(ResponseData::Text(format!(\"Error: {}\", e))),\n                                    headers: HashMap::new(),\n                                    processing_time: start_time.elapsed(),\n                                    worker_id: id,\n                                }\n                            }\n                        }\n                    }",
      "content_length": 1481,
      "difficulty": "Some(Wild)",
      "end_line": 453,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 426
    },
    {
      "code_content": "                        match Self::process_request(&req, &config, id) {",
      "content_length": 72,
      "difficulty": "Some(Easy)",
      "end_line": 430,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 430
    },
    {
      "code_content": "                        match Self::process_request(&req, &config, id) {\n                            Ok(resp) => {\n                                // Cache the response\n                                let response_size = Self::estimate_response_size(&resp);",
      "content_length": 257,
      "difficulty": "Some(Normal)",
      "end_line": 433,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 430
    },
    {
      "code_content": "                        match Self::process_request(&req, &config, id) {\n                            Ok(resp) => {\n                                // Cache the response\n                                let response_size = Self::estimate_response_size(&resp);\n                                if let Err(e) = cache.put(req.id.clone(), resp.clone(), response_size) {\n                                    if config.enable_logging {\n                                        eprintln!(\"Worker {}: Failed to cache response: {:?}\", id, e);\n                                    }\n                                }\n                                resp\n                            }\n                            Err(e) => {\n                                local_metrics.errors_encountered += 1;",
      "content_length": 778,
      "difficulty": "Some(Hard)",
      "end_line": 442,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 430
    },
    {
      "code_content": "                        match Self::process_request(&req, &config, id) {\n                            Ok(resp) => {\n                                // Cache the response\n                                let response_size = Self::estimate_response_size(&resp);\n                                if let Err(e) = cache.put(req.id.clone(), resp.clone(), response_size) {\n                                    if config.enable_logging {\n                                        eprintln!(\"Worker {}: Failed to cache response: {:?}\", id, e);\n                                    }\n                                }\n                                resp\n                            }\n                            Err(e) => {\n                                local_metrics.errors_encountered += 1;\n                                ServiceResponse {\n                                    id: req.id.clone(),\n                                    status: ResponseStatus::InternalError,\n                                    data: Some(ResponseData::Text(format!(\"Error: {}\", e))),\n                                    headers: HashMap::new(),\n                                    processing_time: start_time.elapsed(),\n                                    worker_id: id,\n                                }\n                            }\n                        }",
      "content_length": 1329,
      "difficulty": "Some(Wild)",
      "end_line": 452,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 430
    },
    {
      "code_content": "        Ok(serde_json::json!({",
      "content_length": 30,
      "difficulty": "Some(Easy)",
      "end_line": 968,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 968
    },
    {
      "code_content": "        Ok(serde_json::json!({\n            \"status\": \"healthy\",\n            \"service_metrics\": {\n                \"total_requests\": metrics.total_requests,\n                \"successful_requests\": metrics.successful_requests,\n                \"failed_requests\": metrics.failed_requests,\n                \"average_response_time_ms\": metrics.average_response_time.as_millis(),\n                \"cache_hit_rate\": metrics.cache_hit_rate,\n                \"active_workers\": metrics.active_workers,\n                \"queue_size\": metrics.queue_size,\n            },\n            \"cache_stats\": {\n                \"hits\": cache_stats.hits,\n                \"misses\": cache_stats.misses,\n                \"evictions\": cache_stats.evictions,\n                \"size\": cache_stats.size,\n                \"capacity\": cache_stats.capacity,\n                \"hit_rate\": cache_stats.hit_rate(),\n            },\n            \"worker_metrics\": worker_metrics,\n            \"config\": {\n                \"max_connections\": self.config.max_connections,\n                \"timeout_secs\": self.config.timeout.as_secs(),\n                \"retry_count\": self.config.retry_count,\n                \"cache_size\": self.config.cache_size,\n                \"worker_threads\": self.config.worker_threads,\n            }\n        }))",
      "content_length": 1273,
      "difficulty": "Some(Wild)",
      "end_line": 995,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 968
    },
    {
      "code_content": "    pub fn submit_request(&self, mut request: ServiceRequest) -> Result<String, ServiceError> {",
      "content_length": 95,
      "difficulty": "Some(Easy)",
      "end_line": 849,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 849
    },
    {
      "code_content": "    pub fn submit_request(&self, mut request: ServiceRequest) -> Result<String, ServiceError> {\n        // Generate request ID if not provided\n        if request.id.is_empty() {\n            let mut counter = self.request_counter.lock().unwrap();\n            *counter += 1;",
      "content_length": 272,
      "difficulty": "Some(Normal)",
      "end_line": 853,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 849
    },
    {
      "code_content": "    pub fn submit_request(&self, mut request: ServiceRequest) -> Result<String, ServiceError> {\n        // Generate request ID if not provided\n        if request.id.is_empty() {\n            let mut counter = self.request_counter.lock().unwrap();\n            *counter += 1;\n            request.id = format!(\"req_{:08x}\", *counter);\n        }\n\n        // Validate request\n        Self::validate_request_limits(&request, &self.config)?;\n\n        // Add to queue\n        {\n            let mut queue = self.request_queue.lock().unwrap();\n            if queue.len() >= self.config.max_connections {\n                return Err(ServiceError::CacheFull); // Queue full, reusing error type\n            }\n\n            // Insert based on priority\n            let insert_pos = queue.iter().position(|r| r.priority < request.priority)\n                .unwrap_or(queue.len());",
      "content_length": 861,
      "difficulty": "Some(Hard)",
      "end_line": 869,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 849
    },
    {
      "code_content": "    pub fn submit_request(&self, mut request: ServiceRequest) -> Result<String, ServiceError> {\n        // Generate request ID if not provided\n        if request.id.is_empty() {\n            let mut counter = self.request_counter.lock().unwrap();\n            *counter += 1;\n            request.id = format!(\"req_{:08x}\", *counter);\n        }\n\n        // Validate request\n        Self::validate_request_limits(&request, &self.config)?;\n\n        // Add to queue\n        {\n            let mut queue = self.request_queue.lock().unwrap();\n            if queue.len() >= self.config.max_connections {\n                return Err(ServiceError::CacheFull); // Queue full, reusing error type\n            }\n\n            // Insert based on priority\n            let insert_pos = queue.iter().position(|r| r.priority < request.priority)\n                .unwrap_or(queue.len());\n            queue.insert(insert_pos, request.clone());\n        }\n\n        // Update metrics\n        {\n            let mut metrics = self.service_metrics.lock().unwrap();\n            metrics.total_requests += 1;\n            metrics.queue_size = self.request_queue.lock().unwrap().len();\n        }\n\n        Ok(request.id)\n    }",
      "content_length": 1187,
      "difficulty": "Some(Wild)",
      "end_line": 881,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 849
    },
    {
      "code_content": "    pub fn wait_for_response(&self, request_id: &str, timeout: Duration) -> Result<ServiceResponse, ServiceError> {",
      "content_length": 115,
      "difficulty": "Some(Easy)",
      "end_line": 910,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 910
    },
    {
      "code_content": "    pub fn wait_for_response(&self, request_id: &str, timeout: Duration) -> Result<ServiceResponse, ServiceError> {\n        let start = Instant::now();",
      "content_length": 151,
      "difficulty": "Some(Normal)",
      "end_line": 912,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 910
    },
    {
      "code_content": "    pub fn wait_for_response(&self, request_id: &str, timeout: Duration) -> Result<ServiceResponse, ServiceError> {\n        let start = Instant::now();\n\n        loop {\n            if let Some(response) = self.get_response(request_id) {\n                // Update success metrics\n                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.successful_requests += 1;\n                    let response_time = start.elapsed();\n                    metrics.total_response_time += response_time;\n                    metrics.average_response_time =\n                        metrics.total_response_time / metrics.successful_requests as u32;\n                }\n                return Ok(response);\n            }",
      "content_length": 759,
      "difficulty": "Some(Hard)",
      "end_line": 926,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 910
    },
    {
      "code_content": "    pub fn wait_for_response(&self, request_id: &str, timeout: Duration) -> Result<ServiceResponse, ServiceError> {\n        let start = Instant::now();\n\n        loop {\n            if let Some(response) = self.get_response(request_id) {\n                // Update success metrics\n                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.successful_requests += 1;\n                    let response_time = start.elapsed();\n                    metrics.total_response_time += response_time;\n                    metrics.average_response_time =\n                        metrics.total_response_time / metrics.successful_requests as u32;\n                }\n                return Ok(response);\n            }\n\n            if start.elapsed() > timeout {\n                // Update failure metrics\n                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.failed_requests += 1;\n                }\n                return Err(ServiceError::Timeout);\n            }\n\n            thread::sleep(Duration::from_millis(10));\n        }\n    }",
      "content_length": 1143,
      "difficulty": "Some(Wild)",
      "end_line": 938,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 910
    },
    {
      "code_content": "    pub fn put(&self, key: K, value: V, size: usize) -> Result<(), ServiceError> {",
      "content_length": 82,
      "difficulty": "Some(Easy)",
      "end_line": 257,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 257
    },
    {
      "code_content": "    pub fn put(&self, key: K, value: V, size: usize) -> Result<(), ServiceError> {\n        let mut data = self.data.write().unwrap();\n        let mut current_size = self.current_size.lock().unwrap();\n        let mut stats = self.stats.lock().unwrap();",
      "content_length": 251,
      "difficulty": "Some(Normal)",
      "end_line": 261,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 257
    },
    {
      "code_content": "    pub fn put(&self, key: K, value: V, size: usize) -> Result<(), ServiceError> {\n        let mut data = self.data.write().unwrap();\n        let mut current_size = self.current_size.lock().unwrap();\n        let mut stats = self.stats.lock().unwrap();\n\n        // Check if we need to evict entries\n        while *current_size + size > self.capacity && !data.is_empty() {\n            if let Err(_) = self.evict_lru(&mut data, &mut *current_size, &mut stats) {\n                return Err(ServiceError::CacheFull);\n            }\n        }\n\n        if *current_size + size > self.capacity {\n            return Err(ServiceError::CacheFull);\n        }\n\n        // Remove old entry if exists\n        if let Some(old_entry) = data.remove(&key) {\n            *current_size -= old_entry.size;",
      "content_length": 782,
      "difficulty": "Some(Hard)",
      "end_line": 275,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 257
    },
    {
      "code_content": "    pub fn put(&self, key: K, value: V, size: usize) -> Result<(), ServiceError> {\n        let mut data = self.data.write().unwrap();\n        let mut current_size = self.current_size.lock().unwrap();\n        let mut stats = self.stats.lock().unwrap();\n\n        // Check if we need to evict entries\n        while *current_size + size > self.capacity && !data.is_empty() {\n            if let Err(_) = self.evict_lru(&mut data, &mut *current_size, &mut stats) {\n                return Err(ServiceError::CacheFull);\n            }\n        }\n\n        if *current_size + size > self.capacity {\n            return Err(ServiceError::CacheFull);\n        }\n\n        // Remove old entry if exists\n        if let Some(old_entry) = data.remove(&key) {\n            *current_size -= old_entry.size;\n            self.remove_from_access_order(&key);\n        }\n\n        // Insert new entry\n        let entry = CacheEntry::new(value, size);\n        data.insert(key.clone(), entry);\n        *current_size += size;\n        stats.size = data.len();\n\n        self.add_to_front(key);\n        Ok(())\n    }",
      "content_length": 1079,
      "difficulty": "Some(Wild)",
      "end_line": 287,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 257
    },
    {
      "code_content": "    pub fn new(config: ServiceConfig) -> Result<Self, ServiceError> {\n        Self::validate_config(&config)?;",
      "content_length": 110,
      "difficulty": "Some(Easy)",
      "end_line": 749,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 747
    },
    {
      "code_content": "    pub fn new(config: ServiceConfig) -> Result<Self, ServiceError> {\n        Self::validate_config(&config)?;\n\n        let cache = Arc::new(LruCache::new(\n            config.cache_size,\n            Duration::from_secs(300), // 5 minute TTL\n        ));",
      "content_length": 252,
      "difficulty": "Some(Normal)",
      "end_line": 754,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 747
    },
    {
      "code_content": "    pub fn new(config: ServiceConfig) -> Result<Self, ServiceError> {\n        Self::validate_config(&config)?;\n\n        let cache = Arc::new(LruCache::new(\n            config.cache_size,\n            Duration::from_secs(300), // 5 minute TTL\n        ));\n\n        let request_queue = Arc::new(Mutex::new(Vec::new()));\n        let response_store = Arc::new(Mutex::new(HashMap::new()));\n\n        let mut workers = Vec::new();\n        for i in 0..config.worker_threads {\n            let worker = Worker::new(\n                i,\n                config.clone(),\n                Arc::clone(&cache),\n                Arc::clone(&request_queue),\n                Arc::clone(&response_store),\n            );\n            workers.push(worker);\n        }",
      "content_length": 738,
      "difficulty": "Some(Hard)",
      "end_line": 769,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 747
    },
    {
      "code_content": "    pub fn new(config: ServiceConfig) -> Result<Self, ServiceError> {\n        Self::validate_config(&config)?;\n\n        let cache = Arc::new(LruCache::new(\n            config.cache_size,\n            Duration::from_secs(300), // 5 minute TTL\n        ));\n\n        let request_queue = Arc::new(Mutex::new(Vec::new()));\n        let response_store = Arc::new(Mutex::new(HashMap::new()));\n\n        let mut workers = Vec::new();\n        for i in 0..config.worker_threads {\n            let worker = Worker::new(\n                i,\n                config.clone(),\n                Arc::clone(&cache),\n                Arc::clone(&request_queue),\n                Arc::clone(&response_store),\n            );\n            workers.push(worker);\n        }\n\n        Ok(Self {\n            config,\n            workers,\n            cache,\n            request_queue,\n            response_store,\n            worker_handles: Vec::new(),\n            request_counter: Arc::new(Mutex::new(0)),\n            service_metrics: Arc::new(Mutex::new(ServiceMetrics::default())),\n        })\n    }",
      "content_length": 1061,
      "difficulty": "Some(Wild)",
      "end_line": 780,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 747
    },
    {
      "code_content": "        loop {\n            if let Some(response) = self.get_response(request_id) {\n                // Update success metrics\n                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.successful_requests += 1;\n                    let response_time = start.elapsed();",
      "content_length": 329,
      "difficulty": "Some(Normal)",
      "end_line": 919,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 913
    },
    {
      "code_content": "        loop {\n            if let Some(response) = self.get_response(request_id) {\n                // Update success metrics\n                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.successful_requests += 1;\n                    let response_time = start.elapsed();\n                    metrics.total_response_time += response_time;\n                    metrics.average_response_time =\n                        metrics.total_response_time / metrics.successful_requests as u32;\n                }\n                return Ok(response);\n            }\n\n            if start.elapsed() > timeout {\n                // Update failure metrics\n                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.failed_requests += 1;\n                }\n                return Err(ServiceError::Timeout);\n            }",
      "content_length": 919,
      "difficulty": "Some(Hard)",
      "end_line": 935,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 913
    },
    {
      "code_content": "        loop {\n            if let Some(response) = self.get_response(request_id) {\n                // Update success metrics\n                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.successful_requests += 1;\n                    let response_time = start.elapsed();\n                    metrics.total_response_time += response_time;\n                    metrics.average_response_time =\n                        metrics.total_response_time / metrics.successful_requests as u32;\n                }\n                return Ok(response);\n            }\n\n            if start.elapsed() > timeout {\n                // Update failure metrics\n                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.failed_requests += 1;\n                }\n                return Err(ServiceError::Timeout);\n            }\n\n            thread::sleep(Duration::from_millis(10));\n        }",
      "content_length": 984,
      "difficulty": "Some(Wild)",
      "end_line": 937,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 913
    },
    {
      "code_content": "    fn calculate_processing_delay(request: &ServiceRequest) -> Duration {",
      "content_length": 73,
      "difficulty": "Some(Easy)",
      "end_line": 535,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 535
    },
    {
      "code_content": "    fn calculate_processing_delay(request: &ServiceRequest) -> Duration {\n        let base_delay = Duration::from_millis(10);",
      "content_length": 125,
      "difficulty": "Some(Normal)",
      "end_line": 536,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 535
    },
    {
      "code_content": "    fn calculate_processing_delay(request: &ServiceRequest) -> Duration {\n        let base_delay = Duration::from_millis(10);\n        let priority_multiplier = match request.priority {\n            Priority::Critical => 0.5,\n            Priority::High => 0.75,\n            Priority::Normal => 1.0,\n            Priority::Low => 1.5,\n        };",
      "content_length": 341,
      "difficulty": "Some(Hard)",
      "end_line": 543,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 535
    },
    {
      "code_content": "    fn calculate_processing_delay(request: &ServiceRequest) -> Duration {\n        let base_delay = Duration::from_millis(10);\n        let priority_multiplier = match request.priority {\n            Priority::Critical => 0.5,\n            Priority::High => 0.75,\n            Priority::Normal => 1.0,\n            Priority::Low => 1.5,\n        };\n\n        let data_size_factor = match &request.data {\n            RequestData::Json(value) => value.to_string().len() as f64 / 1000.0,\n            RequestData::Binary(data) => data.len() as f64 / 1000.0,\n            RequestData::Text(text) => text.len() as f64 / 1000.0,\n            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>() as f64 / 1000.0\n            }\n            RequestData::Empty => 0.0,\n        };\n\n        let total_multiplier = priority_multiplier * (1.0 + data_size_factor);\n        Duration::from_millis((base_delay.as_millis() as f64 * total_multiplier) as u64)\n    }",
      "content_length": 974,
      "difficulty": "Some(Wild)",
      "end_line": 556,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 535
    },
    {
      "code_content": "impl std::fmt::Display for ServiceError {",
      "content_length": 41,
      "difficulty": "Some(Easy)",
      "end_line": 51,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 51
    },
    {
      "code_content": "impl std::fmt::Display for ServiceError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            ServiceError::ConnectionFailed(msg) => write!(f, \"Connection failed: {}\", msg),\n            ServiceError::Timeout => write!(f, \"Operation timed out\"),\n            ServiceError::InvalidInput(msg) => write!(f, \"Invalid input: {}\", msg),\n            ServiceError::CacheFull => write!(f, \"Cache is full\"),\n            ServiceError::WorkerPanic => write!(f, \"Worker thread panicked\"),\n            ServiceError::ConfigurationError(msg) => write!(f, \"Configuration error: {}\", msg),\n            ServiceError::NetworkError { code, message } => {\n                write!(f, \"Network error {}: {}\", code, message)\n            }\n            ServiceError::ParseError { line, column, details } => {\n                write!(f, \"Parse error at {}:{}: {}\", line, column, details)\n            }\n        }\n    }\n}",
      "content_length": 941,
      "difficulty": "Some(Wild)",
      "end_line": 68,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 51
    },
    {
      "code_content": "    fn validate_request(request: &ServiceRequest) -> Result<(), ServiceError> {",
      "content_length": 79,
      "difficulty": "Some(Easy)",
      "end_line": 558,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 558
    },
    {
      "code_content": "    fn validate_request(request: &ServiceRequest) -> Result<(), ServiceError> {\n        if request.id.is_empty() {\n            return Err(ServiceError::InvalidInput(\"Request ID cannot be empty\".to_string()));\n        }",
      "content_length": 218,
      "difficulty": "Some(Normal)",
      "end_line": 562,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 558
    },
    {
      "code_content": "    fn validate_request(request: &ServiceRequest) -> Result<(), ServiceError> {\n        if request.id.is_empty() {\n            return Err(ServiceError::InvalidInput(\"Request ID cannot be empty\".to_string()));\n        }\n\n        if request.id.len() > 255 {\n            return Err(ServiceError::InvalidInput(\"Request ID too long\".to_string()));\n        }\n\n        // Validate data size\n        let data_size = match &request.data {\n            RequestData::Json(value) => value.to_string().len(),\n            RequestData::Binary(data) => data.len(),\n            RequestData::Text(text) => text.len(),\n            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>()\n            }",
      "content_length": 719,
      "difficulty": "Some(Hard)",
      "end_line": 574,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 558
    },
    {
      "code_content": "    fn validate_request(request: &ServiceRequest) -> Result<(), ServiceError> {\n        if request.id.is_empty() {\n            return Err(ServiceError::InvalidInput(\"Request ID cannot be empty\".to_string()));\n        }\n\n        if request.id.len() > 255 {\n            return Err(ServiceError::InvalidInput(\"Request ID too long\".to_string()));\n        }\n\n        // Validate data size\n        let data_size = match &request.data {\n            RequestData::Json(value) => value.to_string().len(),\n            RequestData::Binary(data) => data.len(),\n            RequestData::Text(text) => text.len(),\n            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>()\n            }\n            RequestData::Empty => 0,\n        };\n\n        if data_size > 10_000_000 { // 10MB limit\n            return Err(ServiceError::InvalidInput(\"Request data too large\".to_string()));\n        }\n\n        Ok(())\n    }",
      "content_length": 940,
      "difficulty": "Some(Wild)",
      "end_line": 583,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 558
    },
    {
      "code_content": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "content_length": 72,
      "difficulty": "Some(Easy)",
      "end_line": 52,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 52
    },
    {
      "code_content": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            ServiceError::ConnectionFailed(msg) => write!(f, \"Connection failed: {}\", msg),\n            ServiceError::Timeout => write!(f, \"Operation timed out\"),\n            ServiceError::InvalidInput(msg) => write!(f, \"Invalid input: {}\", msg),\n            ServiceError::CacheFull => write!(f, \"Cache is full\"),\n            ServiceError::WorkerPanic => write!(f, \"Worker thread panicked\"),\n            ServiceError::ConfigurationError(msg) => write!(f, \"Configuration error: {}\", msg),\n            ServiceError::NetworkError { code, message } => {\n                write!(f, \"Network error {}: {}\", code, message)\n            }\n            ServiceError::ParseError { line, column, details } => {\n                write!(f, \"Parse error at {}:{}: {}\", line, column, details)\n            }\n        }\n    }",
      "content_length": 897,
      "difficulty": "Some(Wild)",
      "end_line": 67,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 52
    },
    {
      "code_content": "    fn handle_put_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate PUT processing (update operation)",
      "content_length": 153,
      "difficulty": "Some(Easy)",
      "end_line": 646,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 645
    },
    {
      "code_content": "    fn handle_put_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate PUT processing (update operation)",
      "content_length": 153,
      "difficulty": "Some(Normal)",
      "end_line": 646,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 645
    },
    {
      "code_content": "    fn handle_put_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate PUT processing (update operation)\n        let response_data = serde_json::json!({\n            \"message\": \"Resource updated successfully\",\n            \"request_id\": request.id,\n            \"updated_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()",
      "content_length": 431,
      "difficulty": "Some(Hard)",
      "end_line": 652,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 645
    },
    {
      "code_content": "    fn handle_put_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate PUT processing (update operation)\n        let response_data = serde_json::json!({\n            \"message\": \"Resource updated successfully\",\n            \"request_id\": request.id,\n            \"updated_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            \"data_size\": match &request.data {\n                RequestData::Json(v) => v.to_string().len(),\n                RequestData::Binary(d) => d.len(),\n                RequestData::Text(t) => t.len(),\n                RequestData::FormData(f) => f.values().map(|v| v.len()).sum::<usize>(),\n                RequestData::Empty => 0,\n            },\n        });\n\n        Ok(Some(ResponseData::Json(response_data)))\n    }",
      "content_length": 882,
      "difficulty": "Some(Wild)",
      "end_line": 664,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 645
    },
    {
      "code_content": "    fn validate_config(config: &ServiceConfig) -> Result<(), ServiceError> {",
      "content_length": 76,
      "difficulty": "Some(Easy)",
      "end_line": 782,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 782
    },
    {
      "code_content": "    fn validate_config(config: &ServiceConfig) -> Result<(), ServiceError> {\n        if config.max_connections == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"max_connections must be greater than 0\".to_string()\n            ));\n        }",
      "content_length": 269,
      "difficulty": "Some(Normal)",
      "end_line": 788,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 782
    },
    {
      "code_content": "    fn validate_config(config: &ServiceConfig) -> Result<(), ServiceError> {\n        if config.max_connections == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"max_connections must be greater than 0\".to_string()\n            ));\n        }\n\n        if config.worker_threads == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"worker_threads must be greater than 0\".to_string()\n            ));\n        }\n\n        if config.cache_size == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"cache_size must be greater than 0\".to_string()\n            ));\n        }",
      "content_length": 645,
      "difficulty": "Some(Hard)",
      "end_line": 800,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 782
    },
    {
      "code_content": "    fn validate_config(config: &ServiceConfig) -> Result<(), ServiceError> {\n        if config.max_connections == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"max_connections must be greater than 0\".to_string()\n            ));\n        }\n\n        if config.worker_threads == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"worker_threads must be greater than 0\".to_string()\n            ));\n        }\n\n        if config.cache_size == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"cache_size must be greater than 0\".to_string()\n            ));\n        }\n\n        if config.timeout.as_secs() == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"timeout must be greater than 0\".to_string()\n            ));\n        }\n\n        Ok(())\n    }",
      "content_length": 855,
      "difficulty": "Some(Wild)",
      "end_line": 808,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 782
    },
    {
      "code_content": "        match self {\n            ServiceError::ConnectionFailed(msg) => write!(f, \"Connection failed: {}\", msg),\n            ServiceError::Timeout => write!(f, \"Operation timed out\"),\n            ServiceError::InvalidInput(msg) => write!(f, \"Invalid input: {}\", msg),\n            ServiceError::CacheFull => write!(f, \"Cache is full\"),\n            ServiceError::WorkerPanic => write!(f, \"Worker thread panicked\"),\n            ServiceError::ConfigurationError(msg) => write!(f, \"Configuration error: {}\", msg),\n            ServiceError::NetworkError { code, message } => {\n                write!(f, \"Network error {}: {}\", code, message)\n            }",
      "content_length": 649,
      "difficulty": "Some(Hard)",
      "end_line": 62,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 53
    },
    {
      "code_content": "        match self {\n            ServiceError::ConnectionFailed(msg) => write!(f, \"Connection failed: {}\", msg),\n            ServiceError::Timeout => write!(f, \"Operation timed out\"),\n            ServiceError::InvalidInput(msg) => write!(f, \"Invalid input: {}\", msg),\n            ServiceError::CacheFull => write!(f, \"Cache is full\"),\n            ServiceError::WorkerPanic => write!(f, \"Worker thread panicked\"),\n            ServiceError::ConfigurationError(msg) => write!(f, \"Configuration error: {}\", msg),\n            ServiceError::NetworkError { code, message } => {\n                write!(f, \"Network error {}: {}\", code, message)\n            }\n            ServiceError::ParseError { line, column, details } => {\n                write!(f, \"Parse error at {}:{}: {}\", line, column, details)\n            }\n        }",
      "content_length": 818,
      "difficulty": "Some(Wild)",
      "end_line": 66,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 53
    },
    {
      "code_content": "    fn validate_request_limits(request: &ServiceRequest, config: &ServiceConfig) -> Result<(), ServiceError> {",
      "content_length": 110,
      "difficulty": "Some(Easy)",
      "end_line": 883,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 883
    },
    {
      "code_content": "    fn validate_request_limits(request: &ServiceRequest, config: &ServiceConfig) -> Result<(), ServiceError> {",
      "content_length": 110,
      "difficulty": "Some(Normal)",
      "end_line": 883,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 883
    },
    {
      "code_content": "    fn validate_request_limits(request: &ServiceRequest, config: &ServiceConfig) -> Result<(), ServiceError> {\n        // Implement rate limiting and validation logic here\n        let data_size = match &request.data {\n            RequestData::Json(value) => value.to_string().len(),\n            RequestData::Binary(data) => data.len(),\n            RequestData::Text(text) => text.len(),\n            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>()\n            }\n            RequestData::Empty => 0,\n        };\n\n        // Example size limit: 50MB\n        if data_size > 50_000_000 {\n            return Err(ServiceError::InvalidInput(\n                \"Request data exceeds maximum size limit\".to_string()\n            ));\n        }\n\n        Ok(())\n    }",
      "content_length": 797,
      "difficulty": "Some(Hard)",
      "end_line": 903,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 883
    },
    {
      "code_content": "    fn validate_request_limits(request: &ServiceRequest, config: &ServiceConfig) -> Result<(), ServiceError> {\n        // Implement rate limiting and validation logic here\n        let data_size = match &request.data {\n            RequestData::Json(value) => value.to_string().len(),\n            RequestData::Binary(data) => data.len(),\n            RequestData::Text(text) => text.len(),\n            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>()\n            }\n            RequestData::Empty => 0,\n        };\n\n        // Example size limit: 50MB\n        if data_size > 50_000_000 {\n            return Err(ServiceError::InvalidInput(\n                \"Request data exceeds maximum size limit\".to_string()\n            ));\n        }\n\n        Ok(())\n    }",
      "content_length": 797,
      "difficulty": "Some(Wild)",
      "end_line": 903,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 883
    },
    {
      "code_content": "    fn evict_lru(&self, data: &mut HashMap<K, CacheEntry<V>>, current_size: &mut usize, stats: &mut CacheStats) -> Result<(), ServiceError> {",
      "content_length": 141,
      "difficulty": "Some(Easy)",
      "end_line": 289,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 289
    },
    {
      "code_content": "    fn evict_lru(&self, data: &mut HashMap<K, CacheEntry<V>>, current_size: &mut usize, stats: &mut CacheStats) -> Result<(), ServiceError> {\n        let access_order = self.access_order.lock().unwrap();",
      "content_length": 203,
      "difficulty": "Some(Normal)",
      "end_line": 290,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 289
    },
    {
      "code_content": "    fn evict_lru(&self, data: &mut HashMap<K, CacheEntry<V>>, current_size: &mut usize, stats: &mut CacheStats) -> Result<(), ServiceError> {\n        let access_order = self.access_order.lock().unwrap();\n        if let Some(lru_key) = access_order.last() {\n            if let Some(entry) = data.remove(lru_key) {\n                *current_size -= entry.size;\n                stats.evictions += 1;\n                stats.size = data.len();\n                drop(access_order);\n                self.remove_from_access_order(lru_key);\n                Ok(())\n            } else {\n                Err(ServiceError::CacheFull)\n            }\n        } else {\n            Err(ServiceError::CacheFull)\n        }\n    }",
      "content_length": 705,
      "difficulty": "Some(Hard)",
      "end_line": 305,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 289
    },
    {
      "code_content": "    fn evict_lru(&self, data: &mut HashMap<K, CacheEntry<V>>, current_size: &mut usize, stats: &mut CacheStats) -> Result<(), ServiceError> {\n        let access_order = self.access_order.lock().unwrap();\n        if let Some(lru_key) = access_order.last() {\n            if let Some(entry) = data.remove(lru_key) {\n                *current_size -= entry.size;\n                stats.evictions += 1;\n                stats.size = data.len();\n                drop(access_order);\n                self.remove_from_access_order(lru_key);\n                Ok(())\n            } else {\n                Err(ServiceError::CacheFull)\n            }\n        } else {\n            Err(ServiceError::CacheFull)\n        }\n    }",
      "content_length": 705,
      "difficulty": "Some(Wild)",
      "end_line": 305,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 289
    },
    {
      "code_content": "        let response_data = serde_json::json!({",
      "content_length": 47,
      "difficulty": "Some(Easy)",
      "end_line": 647,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 647
    },
    {
      "code_content": "        let response_data = serde_json::json!({\n            \"message\": \"Resource updated successfully\",\n            \"request_id\": request.id,\n            \"updated_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()",
      "content_length": 277,
      "difficulty": "Some(Normal)",
      "end_line": 652,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 647
    },
    {
      "code_content": "        let response_data = serde_json::json!({\n            \"message\": \"Resource updated successfully\",\n            \"request_id\": request.id,\n            \"updated_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            \"data_size\": match &request.data {\n                RequestData::Json(v) => v.to_string().len(),\n                RequestData::Binary(d) => d.len(),\n                RequestData::Text(t) => t.len(),\n                RequestData::FormData(f) => f.values().map(|v| v.len()).sum::<usize>(),\n                RequestData::Empty => 0,\n            },\n        })",
      "content_length": 668,
      "difficulty": "Some(Hard)",
      "end_line": 661,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 647
    },
    {
      "code_content": "        let response_data = serde_json::json!({\n            \"message\": \"Resource updated successfully\",\n            \"request_id\": request.id,\n            \"updated_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            \"data_size\": match &request.data {\n                RequestData::Json(v) => v.to_string().len(),\n                RequestData::Binary(d) => d.len(),\n                RequestData::Text(t) => t.len(),\n                RequestData::FormData(f) => f.values().map(|v| v.len()).sum::<usize>(),\n                RequestData::Empty => 0,\n            },\n        })",
      "content_length": 668,
      "difficulty": "Some(Wild)",
      "end_line": 661,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 647
    },
    {
      "code_content": "    fn estimate_response_size(response: &ServiceResponse) -> usize {",
      "content_length": 68,
      "difficulty": "Some(Easy)",
      "end_line": 704,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 704
    },
    {
      "code_content": "    fn estimate_response_size(response: &ServiceResponse) -> usize {\n        let base_size = std::mem::size_of::<ServiceResponse>();\n        let headers_size = response.headers.iter()\n            .map(|(k, v)| k.len() + v.len())\n            .sum::<usize>();",
      "content_length": 257,
      "difficulty": "Some(Normal)",
      "end_line": 709,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 704
    },
    {
      "code_content": "    fn estimate_response_size(response: &ServiceResponse) -> usize {\n        let base_size = std::mem::size_of::<ServiceResponse>();\n        let headers_size = response.headers.iter()\n            .map(|(k, v)| k.len() + v.len())\n            .sum::<usize>();\n\n        let data_size = match &response.data {\n            Some(ResponseData::Json(value)) => value.to_string().len(),\n            Some(ResponseData::Binary(data)) => data.len(),\n            Some(ResponseData::Text(text)) => text.len(),\n            Some(ResponseData::Stream(url)) => url.len(),\n            None => 0,\n        };\n\n        base_size + headers_size + data_size + response.id.len()\n    }",
      "content_length": 659,
      "difficulty": "Some(Hard)",
      "end_line": 719,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 704
    },
    {
      "code_content": "    fn estimate_response_size(response: &ServiceResponse) -> usize {\n        let base_size = std::mem::size_of::<ServiceResponse>();\n        let headers_size = response.headers.iter()\n            .map(|(k, v)| k.len() + v.len())\n            .sum::<usize>();\n\n        let data_size = match &response.data {\n            Some(ResponseData::Json(value)) => value.to_string().len(),\n            Some(ResponseData::Binary(data)) => data.len(),\n            Some(ResponseData::Text(text)) => text.len(),\n            Some(ResponseData::Stream(url)) => url.len(),\n            None => 0,\n        };\n\n        base_size + headers_size + data_size + response.id.len()\n    }",
      "content_length": 659,
      "difficulty": "Some(Wild)",
      "end_line": 719,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 704
    },
    {
      "code_content": "    pub fn get(&self, key: &K) -> Option<V> {\n        let mut data = self.data.write().unwrap();",
      "content_length": 96,
      "difficulty": "Some(Easy)",
      "end_line": 236,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 235
    },
    {
      "code_content": "    pub fn get(&self, key: &K) -> Option<V> {\n        let mut data = self.data.write().unwrap();\n        let mut stats = self.stats.lock().unwrap();\n\n        if let Some(entry) = data.get_mut(key) {\n            if entry.is_expired(self.ttl) {\n                data.remove(key);",
      "content_length": 276,
      "difficulty": "Some(Normal)",
      "end_line": 241,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 235
    },
    {
      "code_content": "    pub fn get(&self, key: &K) -> Option<V> {\n        let mut data = self.data.write().unwrap();\n        let mut stats = self.stats.lock().unwrap();\n\n        if let Some(entry) = data.get_mut(key) {\n            if entry.is_expired(self.ttl) {\n                data.remove(key);\n                self.remove_from_access_order(key);\n                stats.misses += 1;\n                None\n            } else {\n                let value = entry.access().clone();\n                self.move_to_front(key);\n                stats.hits += 1;\n                Some(value)\n            }\n        } else {\n            stats.misses += 1;\n            None\n        }\n    }",
      "content_length": 654,
      "difficulty": "Some(Hard)",
      "end_line": 255,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 235
    },
    {
      "code_content": "    pub fn get(&self, key: &K) -> Option<V> {\n        let mut data = self.data.write().unwrap();\n        let mut stats = self.stats.lock().unwrap();\n\n        if let Some(entry) = data.get_mut(key) {\n            if entry.is_expired(self.ttl) {\n                data.remove(key);\n                self.remove_from_access_order(key);\n                stats.misses += 1;\n                None\n            } else {\n                let value = entry.access().clone();\n                self.move_to_front(key);\n                stats.hits += 1;\n                Some(value)\n            }\n        } else {\n            stats.misses += 1;\n            None\n        }\n    }",
      "content_length": 654,
      "difficulty": "Some(Wild)",
      "end_line": 255,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 235
    },
    {
      "code_content": "                            Err(e) => {\n                                local_metrics.errors_encountered += 1;",
      "content_length": 110,
      "difficulty": "Some(Easy)",
      "end_line": 442,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 441
    },
    {
      "code_content": "                            Err(e) => {\n                                local_metrics.errors_encountered += 1;\n                                ServiceResponse {\n                                    id: req.id.clone(),\n                                    status: ResponseStatus::InternalError,\n                                    data: Some(ResponseData::Text(format!(\"Error: {}\", e))),\n                                    headers: HashMap::new(),\n                                    processing_time: start_time.elapsed(),\n                                    worker_id: id,\n                                }\n                            }",
      "content_length": 635,
      "difficulty": "Some(Hard)",
      "end_line": 451,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 441
    },
    {
      "code_content": "                            Err(e) => {\n                                local_metrics.errors_encountered += 1;\n                                ServiceResponse {\n                                    id: req.id.clone(),\n                                    status: ResponseStatus::InternalError,\n                                    data: Some(ResponseData::Text(format!(\"Error: {}\", e))),\n                                    headers: HashMap::new(),\n                                    processing_time: start_time.elapsed(),\n                                    worker_id: id,\n                                }\n                            }",
      "content_length": 635,
      "difficulty": "Some(Wild)",
      "end_line": 451,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 441
    },
    {
      "code_content": "                            Ok(resp) => {\n                                // Cache the response\n                                let response_size = Self::estimate_response_size(&resp);",
      "content_length": 184,
      "difficulty": "Some(Easy)",
      "end_line": 433,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 431
    },
    {
      "code_content": "                            Ok(resp) => {\n                                // Cache the response\n                                let response_size = Self::estimate_response_size(&resp);\n                                if let Err(e) = cache.put(req.id.clone(), resp.clone(), response_size) {\n                                    if config.enable_logging {\n                                        eprintln!(\"Worker {}: Failed to cache response: {:?}\", id, e);\n                                    }\n                                }\n                                resp\n                            }",
      "content_length": 594,
      "difficulty": "Some(Hard)",
      "end_line": 440,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 431
    },
    {
      "code_content": "                            Ok(resp) => {\n                                // Cache the response\n                                let response_size = Self::estimate_response_size(&resp);\n                                if let Err(e) = cache.put(req.id.clone(), resp.clone(), response_size) {\n                                    if config.enable_logging {\n                                        eprintln!(\"Worker {}: Failed to cache response: {:?}\", id, e);\n                                    }\n                                }\n                                resp\n                            }",
      "content_length": 594,
      "difficulty": "Some(Wild)",
      "end_line": 440,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 431
    },
    {
      "code_content": "            if let Some(response) = self.get_response(request_id) {",
      "content_length": 67,
      "difficulty": "Some(Easy)",
      "end_line": 914,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 914
    },
    {
      "code_content": "            if let Some(response) = self.get_response(request_id) {\n                // Update success metrics\n                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.successful_requests += 1;\n                    let response_time = start.elapsed();",
      "content_length": 314,
      "difficulty": "Some(Normal)",
      "end_line": 919,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 914
    },
    {
      "code_content": "            if let Some(response) = self.get_response(request_id) {\n                // Update success metrics\n                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.successful_requests += 1;\n                    let response_time = start.elapsed();\n                    metrics.total_response_time += response_time;\n                    metrics.average_response_time =\n                        metrics.total_response_time / metrics.successful_requests as u32;\n                }\n                return Ok(response);\n            }",
      "content_length": 591,
      "difficulty": "Some(Hard)",
      "end_line": 925,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 914
    },
    {
      "code_content": "            if let Some(response) = self.get_response(request_id) {\n                // Update success metrics\n                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.successful_requests += 1;\n                    let response_time = start.elapsed();\n                    metrics.total_response_time += response_time;\n                    metrics.average_response_time =\n                        metrics.total_response_time / metrics.successful_requests as u32;\n                }\n                return Ok(response);\n            }",
      "content_length": 591,
      "difficulty": "Some(Wild)",
      "end_line": 925,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 914
    },
    {
      "code_content": "    fn handle_patch_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate PATCH processing (partial update)",
      "content_length": 155,
      "difficulty": "Some(Easy)",
      "end_line": 681,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 680
    },
    {
      "code_content": "    fn handle_patch_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate PATCH processing (partial update)",
      "content_length": 155,
      "difficulty": "Some(Normal)",
      "end_line": 681,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 680
    },
    {
      "code_content": "    fn handle_patch_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate PATCH processing (partial update)\n        let response_data = serde_json::json!({\n            \"message\": \"Resource partially updated\",\n            \"request_id\": request.id,\n            \"patched_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            \"patch_data\": &request.data,\n        });\n\n        Ok(Some(ResponseData::Json(response_data)))\n    }",
      "content_length": 570,
      "difficulty": "Some(Hard)",
      "end_line": 693,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 680
    },
    {
      "code_content": "    fn handle_patch_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate PATCH processing (partial update)\n        let response_data = serde_json::json!({\n            \"message\": \"Resource partially updated\",\n            \"request_id\": request.id,\n            \"patched_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            \"patch_data\": &request.data,\n        });\n\n        Ok(Some(ResponseData::Json(response_data)))\n    }",
      "content_length": 570,
      "difficulty": "Some(Wild)",
      "end_line": 693,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 680
    },
    {
      "code_content": "    fn handle_get_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {",
      "content_length": 99,
      "difficulty": "Some(Easy)",
      "end_line": 585,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 585
    },
    {
      "code_content": "    fn handle_get_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {",
      "content_length": 99,
      "difficulty": "Some(Normal)",
      "end_line": 585,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 585
    },
    {
      "code_content": "    fn handle_get_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate GET processing\n        let response_data = serde_json::json!({\n            \"message\": \"GET request processed successfully\",\n            \"request_id\": request.id,\n            \"timestamp\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            \"headers\": request.headers,\n        });\n\n        Ok(Some(ResponseData::Json(response_data)))\n    }",
      "content_length": 555,
      "difficulty": "Some(Hard)",
      "end_line": 598,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 585
    },
    {
      "code_content": "    fn handle_get_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate GET processing\n        let response_data = serde_json::json!({\n            \"message\": \"GET request processed successfully\",\n            \"request_id\": request.id,\n            \"timestamp\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            \"headers\": request.headers,\n        });\n\n        Ok(Some(ResponseData::Json(response_data)))\n    }",
      "content_length": 555,
      "difficulty": "Some(Wild)",
      "end_line": 598,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 585
    },
    {
      "code_content": "    pub fn start(&mut self) -> Result<(), ServiceError> {",
      "content_length": 57,
      "difficulty": "Some(Easy)",
      "end_line": 810,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 810
    },
    {
      "code_content": "    pub fn start(&mut self) -> Result<(), ServiceError> {\n        if !self.worker_handles.is_empty() {\n            return Err(ServiceError::ConfigurationError(\n                \"Service is already running\".to_string()\n            ));\n        }",
      "content_length": 242,
      "difficulty": "Some(Normal)",
      "end_line": 816,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 810
    },
    {
      "code_content": "    pub fn start(&mut self) -> Result<(), ServiceError> {\n        if !self.worker_handles.is_empty() {\n            return Err(ServiceError::ConfigurationError(\n                \"Service is already running\".to_string()\n            ));\n        }\n\n        for worker in &self.workers {\n            let handle = worker.start()?;\n            self.worker_handles.push(handle);\n        }\n\n        if self.config.enable_logging {\n            println!(\"ComplexService started with {} workers\", self.config.worker_threads);\n        }\n\n        Ok(())\n    }",
      "content_length": 544,
      "difficulty": "Some(Hard)",
      "end_line": 827,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 810
    },
    {
      "code_content": "    pub fn start(&mut self) -> Result<(), ServiceError> {\n        if !self.worker_handles.is_empty() {\n            return Err(ServiceError::ConfigurationError(\n                \"Service is already running\".to_string()\n            ));\n        }\n\n        for worker in &self.workers {\n            let handle = worker.start()?;\n            self.worker_handles.push(handle);\n        }\n\n        if self.config.enable_logging {\n            println!(\"ComplexService started with {} workers\", self.config.worker_threads);\n        }\n\n        Ok(())\n    }",
      "content_length": 544,
      "difficulty": "Some(Wild)",
      "end_line": 827,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 810
    },
    {
      "code_content": "        let data = match &request.method {",
      "content_length": 42,
      "difficulty": "Some(Easy)",
      "end_line": 508,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 508
    },
    {
      "code_content": "        let data = match &request.method {\n            RequestMethod::Get => Self::handle_get_request(request)?,\n            RequestMethod::Post => Self::handle_post_request(request)?,\n            RequestMethod::Put => Self::handle_put_request(request)?,\n            RequestMethod::Delete => Self::handle_delete_request(request)?,\n            RequestMethod::Patch => Self::handle_patch_request(request)?,\n            RequestMethod::Head => None,\n            RequestMethod::Options => Self::handle_options_request(request)?,\n        }",
      "content_length": 533,
      "difficulty": "Some(Hard)",
      "end_line": 516,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 508
    },
    {
      "code_content": "        let data = match &request.method {\n            RequestMethod::Get => Self::handle_get_request(request)?,\n            RequestMethod::Post => Self::handle_post_request(request)?,\n            RequestMethod::Put => Self::handle_put_request(request)?,\n            RequestMethod::Delete => Self::handle_delete_request(request)?,\n            RequestMethod::Patch => Self::handle_patch_request(request)?,\n            RequestMethod::Head => None,\n            RequestMethod::Options => Self::handle_options_request(request)?,\n        }",
      "content_length": 533,
      "difficulty": "Some(Wild)",
      "end_line": 516,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 508
    },
    {
      "code_content": "    pub fn new(\n        id: usize,\n        config: ServiceConfig,\n        cache: Arc<LruCache<String, ServiceResponse>>,\n        request_queue: Arc<Mutex<Vec<ServiceRequest>>>,\n        response_sender: Arc<Mutex<HashMap<String, ServiceResponse>>>,\n    ) -> Self {\n        Self {\n            id,\n            config,\n            cache,\n            request_queue,\n            response_sender,\n            is_running: Arc::new(Mutex::new(false)),\n            metrics: Arc::new(Mutex::new(WorkerMetrics::default())),\n        }\n    }",
      "content_length": 527,
      "difficulty": "Some(Hard)",
      "end_line": 382,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 366
    },
    {
      "code_content": "    pub fn new(\n        id: usize,\n        config: ServiceConfig,\n        cache: Arc<LruCache<String, ServiceResponse>>,\n        request_queue: Arc<Mutex<Vec<ServiceRequest>>>,\n        response_sender: Arc<Mutex<HashMap<String, ServiceResponse>>>,\n    ) -> Self {\n        Self {\n            id,\n            config,\n            cache,\n            request_queue,\n            response_sender,\n            is_running: Arc::new(Mutex::new(false)),\n            metrics: Arc::new(Mutex::new(WorkerMetrics::default())),\n        }\n    }",
      "content_length": 527,
      "difficulty": "Some(Wild)",
      "end_line": 382,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 366
    },
    {
      "code_content": "    fn handle_delete_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {",
      "content_length": 102,
      "difficulty": "Some(Easy)",
      "end_line": 666,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 666
    },
    {
      "code_content": "    fn handle_delete_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {",
      "content_length": 102,
      "difficulty": "Some(Normal)",
      "end_line": 666,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 666
    },
    {
      "code_content": "    fn handle_delete_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate DELETE processing\n        let response_data = serde_json::json!({\n            \"message\": \"Resource deleted successfully\",\n            \"request_id\": request.id,\n            \"deleted_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n        });\n\n        Ok(Some(ResponseData::Json(response_data)))\n    }",
      "content_length": 517,
      "difficulty": "Some(Hard)",
      "end_line": 678,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 666
    },
    {
      "code_content": "    fn handle_delete_request(request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // Simulate DELETE processing\n        let response_data = serde_json::json!({\n            \"message\": \"Resource deleted successfully\",\n            \"request_id\": request.id,\n            \"deleted_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n        });\n\n        Ok(Some(ResponseData::Json(response_data)))\n    }",
      "content_length": 517,
      "difficulty": "Some(Wild)",
      "end_line": 678,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 666
    },
    {
      "code_content": "    pub fn stop(&mut self) -> Result<(), ServiceError> {\n        // Stop all workers\n        for worker in &self.workers {\n            worker.stop();\n        }",
      "content_length": 159,
      "difficulty": "Some(Easy)",
      "end_line": 834,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 829
    },
    {
      "code_content": "    pub fn stop(&mut self) -> Result<(), ServiceError> {\n        // Stop all workers\n        for worker in &self.workers {\n            worker.stop();\n        }\n\n        // Wait for all worker threads to finish\n        while let Some(handle) = self.worker_handles.pop() {\n            if let Err(_) = handle.join() {\n                return Err(ServiceError::WorkerPanic);\n            }\n        }",
      "content_length": 393,
      "difficulty": "Some(Normal)",
      "end_line": 841,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 829
    },
    {
      "code_content": "    pub fn stop(&mut self) -> Result<(), ServiceError> {\n        // Stop all workers\n        for worker in &self.workers {\n            worker.stop();\n        }\n\n        // Wait for all worker threads to finish\n        while let Some(handle) = self.worker_handles.pop() {\n            if let Err(_) = handle.join() {\n                return Err(ServiceError::WorkerPanic);\n            }\n        }\n\n        if self.config.enable_logging {\n            println!(\"ComplexService stopped\");\n        }\n\n        Ok(())\n    }",
      "content_length": 514,
      "difficulty": "Some(Hard)",
      "end_line": 847,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 829
    },
    {
      "code_content": "    pub fn stop(&mut self) -> Result<(), ServiceError> {\n        // Stop all workers\n        for worker in &self.workers {\n            worker.stop();\n        }\n\n        // Wait for all worker threads to finish\n        while let Some(handle) = self.worker_handles.pop() {\n            if let Err(_) = handle.join() {\n                return Err(ServiceError::WorkerPanic);\n            }\n        }\n\n        if self.config.enable_logging {\n            println!(\"ComplexService stopped\");\n        }\n\n        Ok(())\n    }",
      "content_length": 514,
      "difficulty": "Some(Wild)",
      "end_line": 847,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 829
    },
    {
      "code_content": "        if let Some(entry) = data.get_mut(key) {\n            if entry.is_expired(self.ttl) {\n                data.remove(key);",
      "content_length": 126,
      "difficulty": "Some(Easy)",
      "end_line": 241,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 239
    },
    {
      "code_content": "        if let Some(entry) = data.get_mut(key) {\n            if entry.is_expired(self.ttl) {\n                data.remove(key);\n                self.remove_from_access_order(key);\n                stats.misses += 1;\n                None\n            } else {\n                let value = entry.access().clone();\n                self.move_to_front(key);",
      "content_length": 348,
      "difficulty": "Some(Normal)",
      "end_line": 247,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 239
    },
    {
      "code_content": "        if let Some(entry) = data.get_mut(key) {\n            if entry.is_expired(self.ttl) {\n                data.remove(key);\n                self.remove_from_access_order(key);\n                stats.misses += 1;\n                None\n            } else {\n                let value = entry.access().clone();\n                self.move_to_front(key);\n                stats.hits += 1;\n                Some(value)\n            }\n        } else {\n            stats.misses += 1;\n            None\n        }",
      "content_length": 498,
      "difficulty": "Some(Hard)",
      "end_line": 254,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 239
    },
    {
      "code_content": "        if let Some(entry) = data.get_mut(key) {\n            if entry.is_expired(self.ttl) {\n                data.remove(key);\n                self.remove_from_access_order(key);\n                stats.misses += 1;\n                None\n            } else {\n                let value = entry.access().clone();\n                self.move_to_front(key);\n                stats.hits += 1;\n                Some(value)\n            }\n        } else {\n            stats.misses += 1;\n            None\n        }",
      "content_length": 498,
      "difficulty": "Some(Wild)",
      "end_line": 254,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 239
    },
    {
      "code_content": "        if let Some(lru_key) = access_order.last() {",
      "content_length": 52,
      "difficulty": "Some(Easy)",
      "end_line": 291,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 291
    },
    {
      "code_content": "        if let Some(lru_key) = access_order.last() {\n            if let Some(entry) = data.remove(lru_key) {\n                *current_size -= entry.size;\n                stats.evictions += 1;\n                stats.size = data.len();\n                drop(access_order);",
      "content_length": 268,
      "difficulty": "Some(Normal)",
      "end_line": 296,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 291
    },
    {
      "code_content": "        if let Some(lru_key) = access_order.last() {\n            if let Some(entry) = data.remove(lru_key) {\n                *current_size -= entry.size;\n                stats.evictions += 1;\n                stats.size = data.len();\n                drop(access_order);\n                self.remove_from_access_order(lru_key);\n                Ok(())\n            } else {\n                Err(ServiceError::CacheFull)\n            }\n        } else {\n            Err(ServiceError::CacheFull)\n        }",
      "content_length": 495,
      "difficulty": "Some(Hard)",
      "end_line": 304,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 291
    },
    {
      "code_content": "        if let Some(lru_key) = access_order.last() {\n            if let Some(entry) = data.remove(lru_key) {\n                *current_size -= entry.size;\n                stats.evictions += 1;\n                stats.size = data.len();\n                drop(access_order);\n                self.remove_from_access_order(lru_key);\n                Ok(())\n            } else {\n                Err(ServiceError::CacheFull)\n            }\n        } else {\n            Err(ServiceError::CacheFull)\n        }",
      "content_length": 495,
      "difficulty": "Some(Wild)",
      "end_line": 304,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 291
    },
    {
      "code_content": "        {\n            let mut queue = self.request_queue.lock().unwrap();",
      "content_length": 73,
      "difficulty": "Some(Easy)",
      "end_line": 862,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 861
    },
    {
      "code_content": "        {\n            let mut queue = self.request_queue.lock().unwrap();\n            if queue.len() >= self.config.max_connections {\n                return Err(ServiceError::CacheFull); // Queue full, reusing error type\n            }\n\n            // Insert based on priority\n            let insert_pos = queue.iter().position(|r| r.priority < request.priority)",
      "content_length": 361,
      "difficulty": "Some(Normal)",
      "end_line": 868,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 861
    },
    {
      "code_content": "        {\n            let mut queue = self.request_queue.lock().unwrap();\n            if queue.len() >= self.config.max_connections {\n                return Err(ServiceError::CacheFull); // Queue full, reusing error type\n            }\n\n            // Insert based on priority\n            let insert_pos = queue.iter().position(|r| r.priority < request.priority)\n                .unwrap_or(queue.len());\n            queue.insert(insert_pos, request.clone());\n        }",
      "content_length": 467,
      "difficulty": "Some(Hard)",
      "end_line": 871,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 861
    },
    {
      "code_content": "        {\n            let mut queue = self.request_queue.lock().unwrap();\n            if queue.len() >= self.config.max_connections {\n                return Err(ServiceError::CacheFull); // Queue full, reusing error type\n            }\n\n            // Insert based on priority\n            let insert_pos = queue.iter().position(|r| r.priority < request.priority)\n                .unwrap_or(queue.len());\n            queue.insert(insert_pos, request.clone());\n        }",
      "content_length": 467,
      "difficulty": "Some(Wild)",
      "end_line": 871,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 861
    },
    {
      "code_content": "        let data_size_factor = match &request.data {",
      "content_length": 52,
      "difficulty": "Some(Easy)",
      "end_line": 544,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 544
    },
    {
      "code_content": "        let data_size_factor = match &request.data {\n            RequestData::Json(value) => value.to_string().len() as f64 / 1000.0,\n            RequestData::Binary(data) => data.len() as f64 / 1000.0,\n            RequestData::Text(text) => text.len() as f64 / 1000.0,\n            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>() as f64 / 1000.0\n            }\n            RequestData::Empty => 0.0,\n        }",
      "content_length": 455,
      "difficulty": "Some(Hard)",
      "end_line": 552,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 544
    },
    {
      "code_content": "        let data_size_factor = match &request.data {\n            RequestData::Json(value) => value.to_string().len() as f64 / 1000.0,\n            RequestData::Binary(data) => data.len() as f64 / 1000.0,\n            RequestData::Text(text) => text.len() as f64 / 1000.0,\n            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>() as f64 / 1000.0\n            }\n            RequestData::Empty => 0.0,\n        }",
      "content_length": 455,
      "difficulty": "Some(Wild)",
      "end_line": 552,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 544
    },
    {
      "code_content": "            RequestData::Json(value) => {\n                // Simulate JSON processing\n                let mut result = value.clone();",
      "content_length": 133,
      "difficulty": "Some(Easy)",
      "end_line": 605,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 603
    },
    {
      "code_content": "            RequestData::Json(value) => {\n                // Simulate JSON processing\n                let mut result = value.clone();\n                if let Some(obj) = result.as_object_mut() {\n                    obj.insert(\"processed\".to_string(), serde_json::Value::Bool(true));",
      "content_length": 281,
      "difficulty": "Some(Normal)",
      "end_line": 607,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 603
    },
    {
      "code_content": "            RequestData::Json(value) => {\n                // Simulate JSON processing\n                let mut result = value.clone();\n                if let Some(obj) = result.as_object_mut() {\n                    obj.insert(\"processed\".to_string(), serde_json::Value::Bool(true));\n                    obj.insert(\"processor_id\".to_string(), serde_json::Value::String(request.id.clone()));\n                }\n                result\n            }",
      "content_length": 443,
      "difficulty": "Some(Hard)",
      "end_line": 611,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 603
    },
    {
      "code_content": "            RequestData::Json(value) => {\n                // Simulate JSON processing\n                let mut result = value.clone();\n                if let Some(obj) = result.as_object_mut() {\n                    obj.insert(\"processed\".to_string(), serde_json::Value::Bool(true));\n                    obj.insert(\"processor_id\".to_string(), serde_json::Value::String(request.id.clone()));\n                }\n                result\n            }",
      "content_length": 443,
      "difficulty": "Some(Wild)",
      "end_line": 611,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 603
    },
    {
      "code_content": "        if let Some(lru_key) = access_order.last() {",
      "content_length": 52,
      "difficulty": "Some(Easy)",
      "end_line": 291,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 291
    },
    {
      "code_content": "        if let Some(lru_key) = access_order.last() {\n            if let Some(entry) = data.remove(lru_key) {\n                *current_size -= entry.size;\n                stats.evictions += 1;\n                stats.size = data.len();\n                drop(access_order);",
      "content_length": 268,
      "difficulty": "Some(Normal)",
      "end_line": 296,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 291
    },
    {
      "code_content": "        if let Some(lru_key) = access_order.last() {\n            if let Some(entry) = data.remove(lru_key) {\n                *current_size -= entry.size;\n                stats.evictions += 1;\n                stats.size = data.len();\n                drop(access_order);\n                self.remove_from_access_order(lru_key);\n                Ok(())\n            } else {\n                Err(ServiceError::CacheFull)\n            }\n        }",
      "content_length": 437,
      "difficulty": "Some(Hard)",
      "end_line": 302,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 291
    },
    {
      "code_content": "        if let Some(lru_key) = access_order.last() {\n            if let Some(entry) = data.remove(lru_key) {\n                *current_size -= entry.size;\n                stats.evictions += 1;\n                stats.size = data.len();\n                drop(access_order);\n                self.remove_from_access_order(lru_key);\n                Ok(())\n            } else {\n                Err(ServiceError::CacheFull)\n            }\n        }",
      "content_length": 437,
      "difficulty": "Some(Wild)",
      "end_line": 302,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 291
    },
    {
      "code_content": "        if let Some(entry) = data.get_mut(key) {\n            if entry.is_expired(self.ttl) {\n                data.remove(key);",
      "content_length": 126,
      "difficulty": "Some(Easy)",
      "end_line": 241,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 239
    },
    {
      "code_content": "        if let Some(entry) = data.get_mut(key) {\n            if entry.is_expired(self.ttl) {\n                data.remove(key);\n                self.remove_from_access_order(key);\n                stats.misses += 1;\n                None\n            } else {\n                let value = entry.access().clone();\n                self.move_to_front(key);",
      "content_length": 348,
      "difficulty": "Some(Normal)",
      "end_line": 247,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 239
    },
    {
      "code_content": "        if let Some(entry) = data.get_mut(key) {\n            if entry.is_expired(self.ttl) {\n                data.remove(key);\n                self.remove_from_access_order(key);\n                stats.misses += 1;\n                None\n            } else {\n                let value = entry.access().clone();\n                self.move_to_front(key);\n                stats.hits += 1;\n                Some(value)\n            }\n        }",
      "content_length": 433,
      "difficulty": "Some(Hard)",
      "end_line": 251,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 239
    },
    {
      "code_content": "        if let Some(entry) = data.get_mut(key) {\n            if entry.is_expired(self.ttl) {\n                data.remove(key);\n                self.remove_from_access_order(key);\n                stats.misses += 1;\n                None\n            } else {\n                let value = entry.access().clone();\n                self.move_to_front(key);\n                stats.hits += 1;\n                Some(value)\n            }\n        }",
      "content_length": 433,
      "difficulty": "Some(Wild)",
      "end_line": 251,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 239
    },
    {
      "code_content": "                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.successful_requests += 1;",
      "content_length": 147,
      "difficulty": "Some(Easy)",
      "end_line": 918,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 916
    },
    {
      "code_content": "                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.successful_requests += 1;\n                    let response_time = start.elapsed();\n                    metrics.total_response_time += response_time;",
      "content_length": 270,
      "difficulty": "Some(Normal)",
      "end_line": 920,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 916
    },
    {
      "code_content": "                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.successful_requests += 1;\n                    let response_time = start.elapsed();\n                    metrics.total_response_time += response_time;\n                    metrics.average_response_time =\n                        metrics.total_response_time / metrics.successful_requests as u32;\n                }",
      "content_length": 430,
      "difficulty": "Some(Hard)",
      "end_line": 923,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 916
    },
    {
      "code_content": "                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.successful_requests += 1;\n                    let response_time = start.elapsed();\n                    metrics.total_response_time += response_time;\n                    metrics.average_response_time =\n                        metrics.total_response_time / metrics.successful_requests as u32;\n                }",
      "content_length": 430,
      "difficulty": "Some(Wild)",
      "end_line": 923,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 916
    },
    {
      "code_content": "    fn handle_options_request(_request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {",
      "content_length": 104,
      "difficulty": "Some(Easy)",
      "end_line": 695,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 695
    },
    {
      "code_content": "    fn handle_options_request(_request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {",
      "content_length": 104,
      "difficulty": "Some(Normal)",
      "end_line": 695,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 695
    },
    {
      "code_content": "    fn handle_options_request(_request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // CORS preflight response\n        Ok(Some(ResponseData::Json(serde_json::json!({\n            \"allowed_methods\": [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"HEAD\", \"OPTIONS\"],\n            \"allowed_headers\": [\"Content-Type\", \"Authorization\", \"X-Request-Id\"],\n            \"max_age\": 86400,\n        }))))\n    }",
      "content_length": 419,
      "difficulty": "Some(Hard)",
      "end_line": 702,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 695
    },
    {
      "code_content": "    fn handle_options_request(_request: &ServiceRequest) -> Result<Option<ResponseData>, ServiceError> {\n        // CORS preflight response\n        Ok(Some(ResponseData::Json(serde_json::json!({\n            \"allowed_methods\": [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"HEAD\", \"OPTIONS\"],\n            \"allowed_headers\": [\"Content-Type\", \"Authorization\", \"X-Request-Id\"],\n            \"max_age\": 86400,\n        }))))\n    }",
      "content_length": 419,
      "difficulty": "Some(Wild)",
      "end_line": 702,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 695
    },
    {
      "code_content": "pub struct ComplexService {",
      "content_length": 27,
      "difficulty": "Some(Easy)",
      "end_line": 723,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 723
    },
    {
      "code_content": "pub struct ComplexService {\n    config: ServiceConfig,\n    workers: Vec<Worker>,\n    cache: Arc<LruCache<String, ServiceResponse>>,\n    request_queue: Arc<Mutex<Vec<ServiceRequest>>>,\n    response_store: Arc<Mutex<HashMap<String, ServiceResponse>>>,\n    worker_handles: Vec<thread::JoinHandle<()>>,\n    request_counter: Arc<Mutex<u64>>,\n    service_metrics: Arc<Mutex<ServiceMetrics>>,\n}",
      "content_length": 387,
      "difficulty": "Some(Hard)",
      "end_line": 732,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 723
    },
    {
      "code_content": "pub struct ComplexService {\n    config: ServiceConfig,\n    workers: Vec<Worker>,\n    cache: Arc<LruCache<String, ServiceResponse>>,\n    request_queue: Arc<Mutex<Vec<ServiceRequest>>>,\n    response_store: Arc<Mutex<HashMap<String, ServiceResponse>>>,\n    worker_handles: Vec<thread::JoinHandle<()>>,\n    request_counter: Arc<Mutex<u64>>,\n    service_metrics: Arc<Mutex<ServiceMetrics>>,\n}",
      "content_length": 387,
      "difficulty": "Some(Wild)",
      "end_line": 732,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 723
    },
    {
      "code_content": "        let data_size = match &request.data {",
      "content_length": 45,
      "difficulty": "Some(Easy)",
      "end_line": 568,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 568
    },
    {
      "code_content": "        let data_size = match &request.data {\n            RequestData::Json(value) => value.to_string().len(),\n            RequestData::Binary(data) => data.len(),\n            RequestData::Text(text) => text.len(),\n            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>()\n            }\n            RequestData::Empty => 0,\n        }",
      "content_length": 382,
      "difficulty": "Some(Hard)",
      "end_line": 576,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 568
    },
    {
      "code_content": "        let data_size = match &request.data {\n            RequestData::Json(value) => value.to_string().len(),\n            RequestData::Binary(data) => data.len(),\n            RequestData::Text(text) => text.len(),\n            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>()\n            }\n            RequestData::Empty => 0,\n        }",
      "content_length": 382,
      "difficulty": "Some(Wild)",
      "end_line": 576,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 568
    },
    {
      "code_content": "        let data_size = match &request.data {",
      "content_length": 45,
      "difficulty": "Some(Easy)",
      "end_line": 885,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 885
    },
    {
      "code_content": "        let data_size = match &request.data {\n            RequestData::Json(value) => value.to_string().len(),\n            RequestData::Binary(data) => data.len(),\n            RequestData::Text(text) => text.len(),\n            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>()\n            }\n            RequestData::Empty => 0,\n        }",
      "content_length": 382,
      "difficulty": "Some(Hard)",
      "end_line": 893,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 885
    },
    {
      "code_content": "        let data_size = match &request.data {\n            RequestData::Json(value) => value.to_string().len(),\n            RequestData::Binary(data) => data.len(),\n            RequestData::Text(text) => text.len(),\n            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>()\n            }\n            RequestData::Empty => 0,\n        }",
      "content_length": 382,
      "difficulty": "Some(Wild)",
      "end_line": 893,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 885
    },
    {
      "code_content": "    pub fn metrics(&self) -> ServiceMetrics {\n        let mut metrics = self.service_metrics.lock().unwrap().clone();",
      "content_length": 117,
      "difficulty": "Some(Easy)",
      "end_line": 941,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 940
    },
    {
      "code_content": "    pub fn metrics(&self) -> ServiceMetrics {\n        let mut metrics = self.service_metrics.lock().unwrap().clone();\n        metrics.active_workers = self.worker_handles.len();",
      "content_length": 177,
      "difficulty": "Some(Normal)",
      "end_line": 942,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 940
    },
    {
      "code_content": "    pub fn metrics(&self) -> ServiceMetrics {\n        let mut metrics = self.service_metrics.lock().unwrap().clone();\n        metrics.active_workers = self.worker_handles.len();\n        metrics.queue_size = self.request_queue.lock().unwrap().len();\n\n        let cache_stats = self.cache.stats();\n        metrics.cache_hit_rate = cache_stats.hit_rate();\n\n        metrics\n    }",
      "content_length": 375,
      "difficulty": "Some(Hard)",
      "end_line": 949,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 940
    },
    {
      "code_content": "    pub fn metrics(&self) -> ServiceMetrics {\n        let mut metrics = self.service_metrics.lock().unwrap().clone();\n        metrics.active_workers = self.worker_handles.len();\n        metrics.queue_size = self.request_queue.lock().unwrap().len();\n\n        let cache_stats = self.cache.stats();\n        metrics.cache_hit_rate = cache_stats.hit_rate();\n\n        metrics\n    }",
      "content_length": 375,
      "difficulty": "Some(Wild)",
      "end_line": 949,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 940
    },
    {
      "code_content": "            if entry.is_expired(self.ttl) {\n                data.remove(key);\n                self.remove_from_access_order(key);\n                stats.misses += 1;",
      "content_length": 164,
      "difficulty": "Some(Easy)",
      "end_line": 243,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 240
    },
    {
      "code_content": "            if entry.is_expired(self.ttl) {\n                data.remove(key);\n                self.remove_from_access_order(key);\n                stats.misses += 1;\n                None\n            } else {\n                let value = entry.access().clone();\n                self.move_to_front(key);\n                stats.hits += 1;\n                Some(value)\n            }",
      "content_length": 374,
      "difficulty": "Some(Normal)",
      "end_line": 250,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 240
    },
    {
      "code_content": "            if entry.is_expired(self.ttl) {\n                data.remove(key);\n                self.remove_from_access_order(key);\n                stats.misses += 1;\n                None\n            } else {\n                let value = entry.access().clone();\n                self.move_to_front(key);\n                stats.hits += 1;\n                Some(value)\n            }",
      "content_length": 374,
      "difficulty": "Some(Hard)",
      "end_line": 250,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 240
    },
    {
      "code_content": "            if entry.is_expired(self.ttl) {\n                data.remove(key);\n                self.remove_from_access_order(key);\n                stats.misses += 1;\n                None\n            } else {\n                let value = entry.access().clone();\n                self.move_to_front(key);\n                stats.hits += 1;\n                Some(value)\n            }",
      "content_length": 374,
      "difficulty": "Some(Wild)",
      "end_line": 250,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 240
    },
    {
      "code_content": "            if let Some(entry) = data.remove(lru_key) {\n                *current_size -= entry.size;\n                stats.evictions += 1;",
      "content_length": 138,
      "difficulty": "Some(Easy)",
      "end_line": 294,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 292
    },
    {
      "code_content": "            if let Some(entry) = data.remove(lru_key) {\n                *current_size -= entry.size;\n                stats.evictions += 1;\n                stats.size = data.len();\n                drop(access_order);\n                self.remove_from_access_order(lru_key);\n                Ok(())",
      "content_length": 294,
      "difficulty": "Some(Normal)",
      "end_line": 298,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 292
    },
    {
      "code_content": "            if let Some(entry) = data.remove(lru_key) {\n                *current_size -= entry.size;\n                stats.evictions += 1;\n                stats.size = data.len();\n                drop(access_order);\n                self.remove_from_access_order(lru_key);\n                Ok(())\n            } else {\n                Err(ServiceError::CacheFull)\n            }",
      "content_length": 374,
      "difficulty": "Some(Hard)",
      "end_line": 301,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 292
    },
    {
      "code_content": "            if let Some(entry) = data.remove(lru_key) {\n                *current_size -= entry.size;\n                stats.evictions += 1;\n                stats.size = data.len();\n                drop(access_order);\n                self.remove_from_access_order(lru_key);\n                Ok(())\n            } else {\n                Err(ServiceError::CacheFull)\n            }",
      "content_length": 374,
      "difficulty": "Some(Wild)",
      "end_line": 301,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 292
    },
    {
      "code_content": "    pub fn clear(&self) {\n        let mut data = self.data.write().unwrap();",
      "content_length": 76,
      "difficulty": "Some(Easy)",
      "end_line": 332,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 331
    },
    {
      "code_content": "    pub fn clear(&self) {\n        let mut data = self.data.write().unwrap();\n        let mut access_order = self.access_order.lock().unwrap();\n        let mut current_size = self.current_size.lock().unwrap();",
      "content_length": 208,
      "difficulty": "Some(Normal)",
      "end_line": 334,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 331
    },
    {
      "code_content": "    pub fn clear(&self) {\n        let mut data = self.data.write().unwrap();\n        let mut access_order = self.access_order.lock().unwrap();\n        let mut current_size = self.current_size.lock().unwrap();\n        let mut stats = self.stats.lock().unwrap();\n\n        data.clear();\n        access_order.clear();\n        *current_size = 0;\n        stats.size = 0;\n    }",
      "content_length": 370,
      "difficulty": "Some(Hard)",
      "end_line": 341,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 331
    },
    {
      "code_content": "    pub fn clear(&self) {\n        let mut data = self.data.write().unwrap();\n        let mut access_order = self.access_order.lock().unwrap();\n        let mut current_size = self.current_size.lock().unwrap();\n        let mut stats = self.stats.lock().unwrap();\n\n        data.clear();\n        access_order.clear();\n        *current_size = 0;\n        stats.size = 0;\n    }",
      "content_length": 370,
      "difficulty": "Some(Wild)",
      "end_line": 341,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 331
    },
    {
      "code_content": "        let response_data = serde_json::json!({",
      "content_length": 47,
      "difficulty": "Some(Easy)",
      "end_line": 587,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 587
    },
    {
      "code_content": "        let response_data = serde_json::json!({\n            \"message\": \"GET request processed successfully\",\n            \"request_id\": request.id,\n            \"timestamp\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()",
      "content_length": 281,
      "difficulty": "Some(Normal)",
      "end_line": 592,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 587
    },
    {
      "code_content": "        let response_data = serde_json::json!({\n            \"message\": \"GET request processed successfully\",\n            \"request_id\": request.id,\n            \"timestamp\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            \"headers\": request.headers,\n        })",
      "content_length": 360,
      "difficulty": "Some(Hard)",
      "end_line": 595,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 587
    },
    {
      "code_content": "        let response_data = serde_json::json!({\n            \"message\": \"GET request processed successfully\",\n            \"request_id\": request.id,\n            \"timestamp\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            \"headers\": request.headers,\n        })",
      "content_length": 360,
      "difficulty": "Some(Wild)",
      "end_line": 595,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 587
    },
    {
      "code_content": "    pub fn new(capacity: usize, ttl: Duration) -> Self {",
      "content_length": 56,
      "difficulty": "Some(Easy)",
      "end_line": 224,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 224
    },
    {
      "code_content": "    pub fn new(capacity: usize, ttl: Duration) -> Self {\n        Self {\n            capacity,\n            data: Arc::new(RwLock::new(HashMap::new())),\n            access_order: Arc::new(Mutex::new(Vec::new())),\n            current_size: Arc::new(Mutex::new(0)),\n            ttl,\n            stats: Arc::new(Mutex::new(CacheStats::default())),\n        }\n    }",
      "content_length": 358,
      "difficulty": "Some(Hard)",
      "end_line": 233,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 224
    },
    {
      "code_content": "    pub fn new(capacity: usize, ttl: Duration) -> Self {\n        Self {\n            capacity,\n            data: Arc::new(RwLock::new(HashMap::new())),\n            access_order: Arc::new(Mutex::new(Vec::new())),\n            current_size: Arc::new(Mutex::new(0)),\n            ttl,\n            stats: Arc::new(Mutex::new(CacheStats::default())),\n        }\n    }",
      "content_length": 358,
      "difficulty": "Some(Wild)",
      "end_line": 233,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 224
    },
    {
      "code_content": "        let response_data = serde_json::json!({",
      "content_length": 47,
      "difficulty": "Some(Easy)",
      "end_line": 682,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 682
    },
    {
      "code_content": "        let response_data = serde_json::json!({\n            \"message\": \"Resource partially updated\",\n            \"request_id\": request.id,\n            \"patched_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()",
      "content_length": 274,
      "difficulty": "Some(Normal)",
      "end_line": 687,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 682
    },
    {
      "code_content": "        let response_data = serde_json::json!({\n            \"message\": \"Resource partially updated\",\n            \"request_id\": request.id,\n            \"patched_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            \"patch_data\": &request.data,\n        })",
      "content_length": 354,
      "difficulty": "Some(Hard)",
      "end_line": 690,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 682
    },
    {
      "code_content": "        let response_data = serde_json::json!({\n            \"message\": \"Resource partially updated\",\n            \"request_id\": request.id,\n            \"patched_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            \"patch_data\": &request.data,\n        })",
      "content_length": 354,
      "difficulty": "Some(Wild)",
      "end_line": 690,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 682
    },
    {
      "code_content": "                                if let Err(e) = cache.put(req.id.clone(), resp.clone(), response_size) {",
      "content_length": 104,
      "difficulty": "Some(Easy)",
      "end_line": 434,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 434
    },
    {
      "code_content": "                                if let Err(e) = cache.put(req.id.clone(), resp.clone(), response_size) {\n                                    if config.enable_logging {\n                                        eprintln!(\"Worker {}: Failed to cache response: {:?}\", id, e);\n                                    }\n                                }",
      "content_length": 342,
      "difficulty": "Some(Normal)",
      "end_line": 438,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 434
    },
    {
      "code_content": "                                if let Err(e) = cache.put(req.id.clone(), resp.clone(), response_size) {\n                                    if config.enable_logging {\n                                        eprintln!(\"Worker {}: Failed to cache response: {:?}\", id, e);\n                                    }\n                                }",
      "content_length": 342,
      "difficulty": "Some(Wild)",
      "end_line": 438,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 434
    },
    {
      "code_content": "        let data_size = match &response.data {",
      "content_length": 46,
      "difficulty": "Some(Easy)",
      "end_line": 710,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 710
    },
    {
      "code_content": "        let data_size = match &response.data {\n            Some(ResponseData::Json(value)) => value.to_string().len(),\n            Some(ResponseData::Binary(data)) => data.len(),\n            Some(ResponseData::Text(text)) => text.len(),\n            Some(ResponseData::Stream(url)) => url.len(),\n            None => 0,\n        }",
      "content_length": 327,
      "difficulty": "Some(Hard)",
      "end_line": 716,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 710
    },
    {
      "code_content": "        let data_size = match &response.data {\n            Some(ResponseData::Json(value)) => value.to_string().len(),\n            Some(ResponseData::Binary(data)) => data.len(),\n            Some(ResponseData::Text(text)) => text.len(),\n            Some(ResponseData::Stream(url)) => url.len(),\n            None => 0,\n        }",
      "content_length": 327,
      "difficulty": "Some(Wild)",
      "end_line": 716,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 710
    },
    {
      "code_content": "        let response_data = serde_json::json!({",
      "content_length": 47,
      "difficulty": "Some(Easy)",
      "end_line": 668,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 668
    },
    {
      "code_content": "        let response_data = serde_json::json!({\n            \"message\": \"Resource deleted successfully\",\n            \"request_id\": request.id,\n            \"deleted_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()",
      "content_length": 277,
      "difficulty": "Some(Normal)",
      "end_line": 673,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 668
    },
    {
      "code_content": "        let response_data = serde_json::json!({\n            \"message\": \"Resource deleted successfully\",\n            \"request_id\": request.id,\n            \"deleted_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n        })",
      "content_length": 316,
      "difficulty": "Some(Hard)",
      "end_line": 675,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 668
    },
    {
      "code_content": "        let response_data = serde_json::json!({\n            \"message\": \"Resource deleted successfully\",\n            \"request_id\": request.id,\n            \"deleted_at\": std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n        })",
      "content_length": 316,
      "difficulty": "Some(Wild)",
      "end_line": 675,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 668
    },
    {
      "code_content": "        for i in 0..config.worker_threads {",
      "content_length": 43,
      "difficulty": "Some(Easy)",
      "end_line": 759,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 759
    },
    {
      "code_content": "        for i in 0..config.worker_threads {\n            let worker = Worker::new(\n                i,\n                config.clone(),\n                Arc::clone(&cache),\n                Arc::clone(&request_queue),\n                Arc::clone(&response_store),\n            );\n            workers.push(worker);\n        }",
      "content_length": 316,
      "difficulty": "Some(Normal)",
      "end_line": 768,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 759
    },
    {
      "code_content": "        for i in 0..config.worker_threads {\n            let worker = Worker::new(\n                i,\n                config.clone(),\n                Arc::clone(&cache),\n                Arc::clone(&request_queue),\n                Arc::clone(&response_store),\n            );\n            workers.push(worker);\n        }",
      "content_length": 316,
      "difficulty": "Some(Wild)",
      "end_line": 768,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 759
    },
    {
      "code_content": "        Ok(Self {\n            config,\n            workers,\n            cache,\n            request_queue,\n            response_store,\n            worker_handles: Vec::new(),\n            request_counter: Arc::new(Mutex::new(0)),\n            service_metrics: Arc::new(Mutex::new(ServiceMetrics::default())),\n        })",
      "content_length": 315,
      "difficulty": "Some(Normal)",
      "end_line": 779,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 770
    },
    {
      "code_content": "        Ok(Self {\n            config,\n            workers,\n            cache,\n            request_queue,\n            response_store,\n            worker_handles: Vec::new(),\n            request_counter: Arc::new(Mutex::new(0)),\n            service_metrics: Arc::new(Mutex::new(ServiceMetrics::default())),\n        })",
      "content_length": 315,
      "difficulty": "Some(Hard)",
      "end_line": 779,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 770
    },
    {
      "code_content": "        Ok(Self {\n            config,\n            workers,\n            cache,\n            request_queue,\n            response_store,\n            worker_handles: Vec::new(),\n            request_counter: Arc::new(Mutex::new(0)),\n            service_metrics: Arc::new(Mutex::new(ServiceMetrics::default())),\n        })",
      "content_length": 315,
      "difficulty": "Some(Wild)",
      "end_line": 779,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 770
    },
    {
      "code_content": "            if start.elapsed() > timeout {\n                // Update failure metrics\n                {\n                    let mut metrics = self.service_metrics.lock().unwrap();",
      "content_length": 178,
      "difficulty": "Some(Easy)",
      "end_line": 930,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 927
    },
    {
      "code_content": "            if start.elapsed() > timeout {\n                // Update failure metrics\n                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.failed_requests += 1;\n                }\n                return Err(ServiceError::Timeout);\n            }",
      "content_length": 311,
      "difficulty": "Some(Normal)",
      "end_line": 934,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 927
    },
    {
      "code_content": "            if start.elapsed() > timeout {\n                // Update failure metrics\n                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.failed_requests += 1;\n                }\n                return Err(ServiceError::Timeout);\n            }",
      "content_length": 311,
      "difficulty": "Some(Wild)",
      "end_line": 934,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 927
    },
    {
      "code_content": "            if let Some(entry) = data.remove(lru_key) {\n                *current_size -= entry.size;\n                stats.evictions += 1;",
      "content_length": 138,
      "difficulty": "Some(Easy)",
      "end_line": 294,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 292
    },
    {
      "code_content": "            if let Some(entry) = data.remove(lru_key) {\n                *current_size -= entry.size;\n                stats.evictions += 1;\n                stats.size = data.len();\n                drop(access_order);\n                self.remove_from_access_order(lru_key);\n                Ok(())\n            }",
      "content_length": 308,
      "difficulty": "Some(Normal)",
      "end_line": 299,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 292
    },
    {
      "code_content": "            if let Some(entry) = data.remove(lru_key) {\n                *current_size -= entry.size;\n                stats.evictions += 1;\n                stats.size = data.len();\n                drop(access_order);\n                self.remove_from_access_order(lru_key);\n                Ok(())\n            }",
      "content_length": 308,
      "difficulty": "Some(Wild)",
      "end_line": 299,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 292
    },
    {
      "code_content": "pub struct Worker {\n    id: usize,\n    config: ServiceConfig,\n    cache: Arc<LruCache<String, ServiceResponse>>,\n    request_queue: Arc<Mutex<Vec<ServiceRequest>>>,\n    response_sender: Arc<Mutex<HashMap<String, ServiceResponse>>>,\n    is_running: Arc<Mutex<bool>>,\n    metrics: Arc<Mutex<WorkerMetrics>>,\n}",
      "content_length": 307,
      "difficulty": "Some(Hard)",
      "end_line": 353,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 345
    },
    {
      "code_content": "pub struct Worker {\n    id: usize,\n    config: ServiceConfig,\n    cache: Arc<LruCache<String, ServiceResponse>>,\n    request_queue: Arc<Mutex<Vec<ServiceRequest>>>,\n    response_sender: Arc<Mutex<HashMap<String, ServiceResponse>>>,\n    is_running: Arc<Mutex<bool>>,\n    metrics: Arc<Mutex<WorkerMetrics>>,\n}",
      "content_length": 307,
      "difficulty": "Some(Wild)",
      "end_line": 353,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 345
    },
    {
      "code_content": "            RequestData::Text(text) => {",
      "content_length": 40,
      "difficulty": "Some(Easy)",
      "end_line": 612,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 612
    },
    {
      "code_content": "            RequestData::Text(text) => {\n                serde_json::json!({\n                    \"original_text\": text,\n                    \"processed\": true,\n                    \"length\": text.len(),\n                    \"word_count\": text.split_whitespace().count(),\n                })\n            }",
      "content_length": 300,
      "difficulty": "Some(Normal)",
      "end_line": 619,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 612
    },
    {
      "code_content": "            RequestData::Text(text) => {\n                serde_json::json!({\n                    \"original_text\": text,\n                    \"processed\": true,\n                    \"length\": text.len(),\n                    \"word_count\": text.split_whitespace().count(),\n                })\n            }",
      "content_length": 300,
      "difficulty": "Some(Wild)",
      "end_line": 619,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 612
    },
    {
      "code_content": "impl Default for ServiceConfig {",
      "content_length": 32,
      "difficulty": "Some(Easy)",
      "end_line": 25,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 25
    },
    {
      "code_content": "impl Default for ServiceConfig {\n    fn default() -> Self {\n        Self {\n            max_connections: 100,\n            timeout: Duration::from_secs(30),\n            retry_count: 3,\n            enable_logging: true,\n            cache_size: 1000,\n            worker_threads: 4,\n        }\n    }\n}",
      "content_length": 295,
      "difficulty": "Some(Normal)",
      "end_line": 36,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 25
    },
    {
      "code_content": "impl Default for ServiceConfig {\n    fn default() -> Self {\n        Self {\n            max_connections: 100,\n            timeout: Duration::from_secs(30),\n            retry_count: 3,\n            enable_logging: true,\n            cache_size: 1000,\n            worker_threads: 4,\n        }\n    }\n}",
      "content_length": 295,
      "difficulty": "Some(Wild)",
      "end_line": 36,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 25
    },
    {
      "code_content": "pub struct ServiceMetrics {",
      "content_length": 27,
      "difficulty": "Some(Easy)",
      "end_line": 735,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 735
    },
    {
      "code_content": "pub struct ServiceMetrics {\n    pub total_requests: u64,\n    pub successful_requests: u64,\n    pub failed_requests: u64,\n    pub average_response_time: Duration,\n    pub total_response_time: Duration,\n    pub cache_hit_rate: f64,\n    pub active_workers: usize,\n    pub queue_size: usize,\n}",
      "content_length": 289,
      "difficulty": "Some(Hard)",
      "end_line": 744,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 735
    },
    {
      "code_content": "pub struct ServiceMetrics {\n    pub total_requests: u64,\n    pub successful_requests: u64,\n    pub failed_requests: u64,\n    pub average_response_time: Duration,\n    pub total_response_time: Duration,\n    pub cache_hit_rate: f64,\n    pub active_workers: usize,\n    pub queue_size: usize,\n}",
      "content_length": 289,
      "difficulty": "Some(Wild)",
      "end_line": 744,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 735
    },
    {
      "code_content": "pub struct LruCache<K, V>",
      "content_length": 25,
      "difficulty": "Some(Easy)",
      "end_line": 187,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 187
    },
    {
      "code_content": "pub struct LruCache<K, V>\nwhere\n    K: Clone + Eq + std::hash::Hash,\n    V: Clone,\n{\n    capacity: usize,\n    data: Arc<RwLock<HashMap<K, CacheEntry<V>>>>,\n    access_order: Arc<Mutex<Vec<K>>>,\n    current_size: Arc<Mutex<usize>>,\n    ttl: Duration,\n    stats: Arc<Mutex<CacheStats>>,\n}",
      "content_length": 286,
      "difficulty": "Some(Hard)",
      "end_line": 198,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 187
    },
    {
      "code_content": "pub struct LruCache<K, V>\nwhere\n    K: Clone + Eq + std::hash::Hash,\n    V: Clone,\n{\n    capacity: usize,\n    data: Arc<RwLock<HashMap<K, CacheEntry<V>>>>,\n    access_order: Arc<Mutex<Vec<K>>>,\n    current_size: Arc<Mutex<usize>>,\n    ttl: Duration,\n    stats: Arc<Mutex<CacheStats>>,\n}",
      "content_length": 286,
      "difficulty": "Some(Wild)",
      "end_line": 198,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 187
    },
    {
      "code_content": "    fn move_to_front(&self, key: &K) {\n        let mut access_order = self.access_order.lock().unwrap();",
      "content_length": 104,
      "difficulty": "Some(Easy)",
      "end_line": 308,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 307
    },
    {
      "code_content": "    fn move_to_front(&self, key: &K) {\n        let mut access_order = self.access_order.lock().unwrap();\n        if let Some(pos) = access_order.iter().position(|x| x == key) {\n            let key = access_order.remove(pos);\n            access_order.insert(0, key);\n        }\n    }",
      "content_length": 281,
      "difficulty": "Some(Normal)",
      "end_line": 313,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 307
    },
    {
      "code_content": "    fn move_to_front(&self, key: &K) {\n        let mut access_order = self.access_order.lock().unwrap();\n        if let Some(pos) = access_order.iter().position(|x| x == key) {\n            let key = access_order.remove(pos);\n            access_order.insert(0, key);\n        }\n    }",
      "content_length": 281,
      "difficulty": "Some(Hard)",
      "end_line": 313,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 307
    },
    {
      "code_content": "    fn move_to_front(&self, key: &K) {\n        let mut access_order = self.access_order.lock().unwrap();\n        if let Some(pos) = access_order.iter().position(|x| x == key) {\n            let key = access_order.remove(pos);\n            access_order.insert(0, key);\n        }\n    }",
      "content_length": 281,
      "difficulty": "Some(Wild)",
      "end_line": 313,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 307
    },
    {
      "code_content": "    ) -> Self {\n        Self {\n            id,\n            config,\n            cache,\n            request_queue,\n            response_sender,\n            is_running: Arc::new(Mutex::new(false)),\n            metrics: Arc::new(Mutex::new(WorkerMetrics::default())),\n        }\n    }",
      "content_length": 279,
      "difficulty": "Some(Normal)",
      "end_line": 382,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 372
    },
    {
      "code_content": "    ) -> Self {\n        Self {\n            id,\n            config,\n            cache,\n            request_queue,\n            response_sender,\n            is_running: Arc::new(Mutex::new(false)),\n            metrics: Arc::new(Mutex::new(WorkerMetrics::default())),\n        }\n    }",
      "content_length": 279,
      "difficulty": "Some(Wild)",
      "end_line": 382,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 372
    },
    {
      "code_content": "        Ok(Some(ResponseData::Json(serde_json::json!({",
      "content_length": 54,
      "difficulty": "Some(Easy)",
      "end_line": 697,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 697
    },
    {
      "code_content": "        Ok(Some(ResponseData::Json(serde_json::json!({\n            \"allowed_methods\": [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"HEAD\", \"OPTIONS\"],\n            \"allowed_headers\": [\"Content-Type\", \"Authorization\", \"X-Request-Id\"],\n            \"max_age\": 86400,\n        }))))",
      "content_length": 273,
      "difficulty": "Some(Hard)",
      "end_line": 701,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 697
    },
    {
      "code_content": "        Ok(Some(ResponseData::Json(serde_json::json!({\n            \"allowed_methods\": [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"HEAD\", \"OPTIONS\"],\n            \"allowed_headers\": [\"Content-Type\", \"Authorization\", \"X-Request-Id\"],\n            \"max_age\": 86400,\n        }))))",
      "content_length": 273,
      "difficulty": "Some(Wild)",
      "end_line": 701,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 697
    },
    {
      "code_content": "                if let Some(obj) = result.as_object_mut() {",
      "content_length": 59,
      "difficulty": "Some(Easy)",
      "end_line": 606,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 606
    },
    {
      "code_content": "                if let Some(obj) = result.as_object_mut() {\n                    obj.insert(\"processed\".to_string(), serde_json::Value::Bool(true));\n                    obj.insert(\"processor_id\".to_string(), serde_json::Value::String(request.id.clone()));\n                }",
      "content_length": 272,
      "difficulty": "Some(Normal)",
      "end_line": 609,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 606
    },
    {
      "code_content": "                if let Some(obj) = result.as_object_mut() {\n                    obj.insert(\"processed\".to_string(), serde_json::Value::Bool(true));\n                    obj.insert(\"processor_id\".to_string(), serde_json::Value::String(request.id.clone()));\n                }",
      "content_length": 272,
      "difficulty": "Some(Hard)",
      "end_line": 609,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 606
    },
    {
      "code_content": "                if let Some(obj) = result.as_object_mut() {\n                    obj.insert(\"processed\".to_string(), serde_json::Value::Bool(true));\n                    obj.insert(\"processor_id\".to_string(), serde_json::Value::String(request.id.clone()));\n                }",
      "content_length": 272,
      "difficulty": "Some(Wild)",
      "end_line": 609,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 606
    },
    {
      "code_content": "pub enum ServiceError {",
      "content_length": 23,
      "difficulty": "Some(Easy)",
      "end_line": 40,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 40
    },
    {
      "code_content": "pub enum ServiceError {\n    ConnectionFailed(String),\n    Timeout,\n    InvalidInput(String),\n    CacheFull,\n    WorkerPanic,\n    ConfigurationError(String),\n    NetworkError { code: u16, message: String },\n    ParseError { line: usize, column: usize, details: String },\n}",
      "content_length": 271,
      "difficulty": "Some(Hard)",
      "end_line": 49,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 40
    },
    {
      "code_content": "pub enum ServiceError {\n    ConnectionFailed(String),\n    Timeout,\n    InvalidInput(String),\n    CacheFull,\n    WorkerPanic,\n    ConfigurationError(String),\n    NetworkError { code: u16, message: String },\n    ParseError { line: usize, column: usize, details: String },\n}",
      "content_length": 271,
      "difficulty": "Some(Wild)",
      "end_line": 49,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 40
    },
    {
      "code_content": "            RequestData::Binary(data) => {",
      "content_length": 42,
      "difficulty": "Some(Easy)",
      "end_line": 627,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 627
    },
    {
      "code_content": "            RequestData::Binary(data) => {\n                serde_json::json!({\n                    \"binary_size\": data.len(),\n                    \"processed\": true,\n                    \"checksum\": format!(\"{:x}\", md5::compute(data)),\n                })\n            }",
      "content_length": 266,
      "difficulty": "Some(Normal)",
      "end_line": 633,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 627
    },
    {
      "code_content": "            RequestData::Binary(data) => {\n                serde_json::json!({\n                    \"binary_size\": data.len(),\n                    \"processed\": true,\n                    \"checksum\": format!(\"{:x}\", md5::compute(data)),\n                })\n            }",
      "content_length": 266,
      "difficulty": "Some(Wild)",
      "end_line": 633,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 627
    },
    {
      "code_content": "    fn score(&self) -> f64 {\n        // LFU + LRU hybrid scoring\n        let frequency_score = self.access_count as f64;",
      "content_length": 120,
      "difficulty": "Some(Easy)",
      "end_line": 180,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 178
    },
    {
      "code_content": "    fn score(&self) -> f64 {\n        // LFU + LRU hybrid scoring\n        let frequency_score = self.access_count as f64;\n        let recency_score = 1.0 / (self.last_accessed.elapsed().as_secs_f64() + 1.0);\n        frequency_score * 0.7 + recency_score * 0.3\n    }",
      "content_length": 264,
      "difficulty": "Some(Normal)",
      "end_line": 183,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 178
    },
    {
      "code_content": "    fn score(&self) -> f64 {\n        // LFU + LRU hybrid scoring\n        let frequency_score = self.access_count as f64;\n        let recency_score = 1.0 / (self.last_accessed.elapsed().as_secs_f64() + 1.0);\n        frequency_score * 0.7 + recency_score * 0.3\n    }",
      "content_length": 264,
      "difficulty": "Some(Wild)",
      "end_line": 183,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 178
    },
    {
      "code_content": "    fn default() -> Self {\n        Self {\n            max_connections: 100,\n            timeout: Duration::from_secs(30),\n            retry_count: 3,\n            enable_logging: true,\n            cache_size: 1000,\n            worker_threads: 4,\n        }\n    }",
      "content_length": 260,
      "difficulty": "Some(Normal)",
      "end_line": 35,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 26
    },
    {
      "code_content": "    fn default() -> Self {\n        Self {\n            max_connections: 100,\n            timeout: Duration::from_secs(30),\n            retry_count: 3,\n            enable_logging: true,\n            cache_size: 1000,\n            worker_threads: 4,\n        }\n    }",
      "content_length": 260,
      "difficulty": "Some(Wild)",
      "end_line": 35,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 26
    },
    {
      "code_content": "                serde_json::json!({\n                    \"original_text\": text,\n                    \"processed\": true,\n                    \"length\": text.len(),\n                    \"word_count\": text.split_whitespace().count(),\n                })",
      "content_length": 245,
      "difficulty": "Some(Normal)",
      "end_line": 618,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 613
    },
    {
      "code_content": "                serde_json::json!({\n                    \"original_text\": text,\n                    \"processed\": true,\n                    \"length\": text.len(),\n                    \"word_count\": text.split_whitespace().count(),\n                })",
      "content_length": 245,
      "difficulty": "Some(Wild)",
      "end_line": 618,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 613
    },
    {
      "code_content": "    fn remove_from_access_order(&self, key: &K) {\n        let mut access_order = self.access_order.lock().unwrap();",
      "content_length": 115,
      "difficulty": "Some(Easy)",
      "end_line": 321,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 320
    },
    {
      "code_content": "    fn remove_from_access_order(&self, key: &K) {\n        let mut access_order = self.access_order.lock().unwrap();\n        if let Some(pos) = access_order.iter().position(|x| x == key) {\n            access_order.remove(pos);\n        }\n    }",
      "content_length": 241,
      "difficulty": "Some(Normal)",
      "end_line": 325,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 320
    },
    {
      "code_content": "    fn remove_from_access_order(&self, key: &K) {\n        let mut access_order = self.access_order.lock().unwrap();\n        if let Some(pos) = access_order.iter().position(|x| x == key) {\n            access_order.remove(pos);\n        }\n    }",
      "content_length": 241,
      "difficulty": "Some(Wild)",
      "end_line": 325,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 320
    },
    {
      "code_content": "            RequestData::FormData(form) => {",
      "content_length": 44,
      "difficulty": "Some(Easy)",
      "end_line": 620,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 620
    },
    {
      "code_content": "            RequestData::FormData(form) => {\n                serde_json::json!({\n                    \"form_fields\": form,\n                    \"field_count\": form.len(),\n                    \"processed\": true,\n                })\n            }",
      "content_length": 240,
      "difficulty": "Some(Normal)",
      "end_line": 626,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 620
    },
    {
      "code_content": "            RequestData::FormData(form) => {\n                serde_json::json!({\n                    \"form_fields\": form,\n                    \"field_count\": form.len(),\n                    \"processed\": true,\n                })\n            }",
      "content_length": 240,
      "difficulty": "Some(Wild)",
      "end_line": 626,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 620
    },
    {
      "code_content": "        while *current_size + size > self.capacity && !data.is_empty() {",
      "content_length": 72,
      "difficulty": "Some(Easy)",
      "end_line": 263,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 263
    },
    {
      "code_content": "        while *current_size + size > self.capacity && !data.is_empty() {\n            if let Err(_) = self.evict_lru(&mut data, &mut *current_size, &mut stats) {\n                return Err(ServiceError::CacheFull);\n            }\n        }",
      "content_length": 237,
      "difficulty": "Some(Normal)",
      "end_line": 267,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 263
    },
    {
      "code_content": "        while *current_size + size > self.capacity && !data.is_empty() {\n            if let Err(_) = self.evict_lru(&mut data, &mut *current_size, &mut stats) {\n                return Err(ServiceError::CacheFull);\n            }\n        }",
      "content_length": 237,
      "difficulty": "Some(Wild)",
      "end_line": 267,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 263
    },
    {
      "code_content": "    fn new(data: T, size: usize) -> Self {\n        let now = Instant::now();",
      "content_length": 76,
      "difficulty": "Some(Easy)",
      "end_line": 158,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 157
    },
    {
      "code_content": "    fn new(data: T, size: usize) -> Self {\n        let now = Instant::now();\n        Self {\n            data,\n            created_at: now,\n            access_count: 0,\n            last_accessed: now,\n            size,\n        }\n    }",
      "content_length": 233,
      "difficulty": "Some(Normal)",
      "end_line": 166,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 157
    },
    {
      "code_content": "    fn new(data: T, size: usize) -> Self {\n        let now = Instant::now();\n        Self {\n            data,\n            created_at: now,\n            access_count: 0,\n            last_accessed: now,\n            size,\n        }\n    }",
      "content_length": 233,
      "difficulty": "Some(Wild)",
      "end_line": 166,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 157
    },
    {
      "code_content": "pub struct WorkerMetrics {",
      "content_length": 26,
      "difficulty": "Some(Easy)",
      "end_line": 356,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 356
    },
    {
      "code_content": "pub struct WorkerMetrics {\n    pub requests_processed: u64,\n    pub errors_encountered: u64,\n    pub average_processing_time: Duration,\n    pub total_processing_time: Duration,\n    pub cache_hits: u64,\n    pub cache_misses: u64,\n}",
      "content_length": 230,
      "difficulty": "Some(Normal)",
      "end_line": 363,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 356
    },
    {
      "code_content": "pub struct WorkerMetrics {\n    pub requests_processed: u64,\n    pub errors_encountered: u64,\n    pub average_processing_time: Duration,\n    pub total_processing_time: Duration,\n    pub cache_hits: u64,\n    pub cache_misses: u64,\n}",
      "content_length": 230,
      "difficulty": "Some(Hard)",
      "end_line": 363,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 356
    },
    {
      "code_content": "pub struct WorkerMetrics {\n    pub requests_processed: u64,\n    pub errors_encountered: u64,\n    pub average_processing_time: Duration,\n    pub total_processing_time: Duration,\n    pub cache_hits: u64,\n    pub cache_misses: u64,\n}",
      "content_length": 230,
      "difficulty": "Some(Wild)",
      "end_line": 363,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 356
    },
    {
      "code_content": "        Ok(ServiceResponse {\n            id: request.id.clone(),\n            status: ResponseStatus::Success,\n            data,\n            headers,\n            processing_time: processing_delay,\n            worker_id,\n        })",
      "content_length": 229,
      "difficulty": "Some(Normal)",
      "end_line": 532,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 525
    },
    {
      "code_content": "        Ok(ServiceResponse {\n            id: request.id.clone(),\n            status: ResponseStatus::Success,\n            data,\n            headers,\n            processing_time: processing_delay,\n            worker_id,\n        })",
      "content_length": 229,
      "difficulty": "Some(Wild)",
      "end_line": 532,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 525
    },
    {
      "code_content": "            let worker = Worker::new(",
      "content_length": 37,
      "difficulty": "Some(Easy)",
      "end_line": 760,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 760
    },
    {
      "code_content": "            let worker = Worker::new(\n                i,\n                config.clone(),\n                Arc::clone(&cache),\n                Arc::clone(&request_queue),\n                Arc::clone(&response_store),\n            )",
      "content_length": 227,
      "difficulty": "Some(Normal)",
      "end_line": 766,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 760
    },
    {
      "code_content": "            let worker = Worker::new(\n                i,\n                config.clone(),\n                Arc::clone(&cache),\n                Arc::clone(&request_queue),\n                Arc::clone(&response_store),\n            )",
      "content_length": 227,
      "difficulty": "Some(Wild)",
      "end_line": 766,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 760
    },
    {
      "code_content": "pub struct ServiceResponse {",
      "content_length": 28,
      "difficulty": "Some(Easy)",
      "end_line": 116,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 116
    },
    {
      "code_content": "pub struct ServiceResponse {\n    pub id: String,\n    pub status: ResponseStatus,\n    pub data: Option<ResponseData>,\n    pub headers: HashMap<String, String>,\n    pub processing_time: Duration,\n    pub worker_id: usize,\n}",
      "content_length": 221,
      "difficulty": "Some(Normal)",
      "end_line": 123,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 116
    },
    {
      "code_content": "pub struct ServiceResponse {\n    pub id: String,\n    pub status: ResponseStatus,\n    pub data: Option<ResponseData>,\n    pub headers: HashMap<String, String>,\n    pub processing_time: Duration,\n    pub worker_id: usize,\n}",
      "content_length": 221,
      "difficulty": "Some(Wild)",
      "end_line": 123,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 116
    },
    {
      "code_content": "        let priority_multiplier = match request.priority {",
      "content_length": 58,
      "difficulty": "Some(Easy)",
      "end_line": 537,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 537
    },
    {
      "code_content": "        let priority_multiplier = match request.priority {\n            Priority::Critical => 0.5,\n            Priority::High => 0.75,\n            Priority::Normal => 1.0,\n            Priority::Low => 1.5,\n        }",
      "content_length": 214,
      "difficulty": "Some(Normal)",
      "end_line": 542,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 537
    },
    {
      "code_content": "        let priority_multiplier = match request.priority {\n            Priority::Critical => 0.5,\n            Priority::High => 0.75,\n            Priority::Normal => 1.0,\n            Priority::Low => 1.5,\n        }",
      "content_length": 214,
      "difficulty": "Some(Wild)",
      "end_line": 542,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 537
    },
    {
      "code_content": "                if local_metrics.requests_processed % 100 == 0 {\n                    let mut global_metrics = metrics.lock().unwrap();",
      "content_length": 134,
      "difficulty": "Some(Easy)",
      "end_line": 473,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 472
    },
    {
      "code_content": "                if local_metrics.requests_processed % 100 == 0 {\n                    let mut global_metrics = metrics.lock().unwrap();\n                    *global_metrics = local_metrics.clone();\n                }",
      "content_length": 213,
      "difficulty": "Some(Normal)",
      "end_line": 475,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 472
    },
    {
      "code_content": "                if local_metrics.requests_processed % 100 == 0 {\n                    let mut global_metrics = metrics.lock().unwrap();\n                    *global_metrics = local_metrics.clone();\n                }",
      "content_length": 213,
      "difficulty": "Some(Wild)",
      "end_line": 475,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 472
    },
    {
      "code_content": "impl CacheStats {\n    pub fn hit_rate(&self) -> f64 {\n        if self.hits + self.misses == 0 {\n            0.0\n        } else {\n            self.hits as f64 / (self.hits + self.misses) as f64\n        }\n    }\n}",
      "content_length": 210,
      "difficulty": "Some(Normal)",
      "end_line": 217,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 209
    },
    {
      "code_content": "impl CacheStats {\n    pub fn hit_rate(&self) -> f64 {\n        if self.hits + self.misses == 0 {\n            0.0\n        } else {\n            self.hits as f64 / (self.hits + self.misses) as f64\n        }\n    }\n}",
      "content_length": 210,
      "difficulty": "Some(Wild)",
      "end_line": 217,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 209
    },
    {
      "code_content": "                serde_json::json!({\n                    \"binary_size\": data.len(),\n                    \"processed\": true,\n                    \"checksum\": format!(\"{:x}\", md5::compute(data)),\n                })",
      "content_length": 209,
      "difficulty": "Some(Normal)",
      "end_line": 632,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 628
    },
    {
      "code_content": "                serde_json::json!({\n                    \"binary_size\": data.len(),\n                    \"processed\": true,\n                    \"checksum\": format!(\"{:x}\", md5::compute(data)),\n                })",
      "content_length": 209,
      "difficulty": "Some(Wild)",
      "end_line": 632,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 628
    },
    {
      "code_content": "                                    if config.enable_logging {\n                                        eprintln!(\"Worker {}: Failed to cache response: {:?}\", id, e);\n                                    }",
      "content_length": 203,
      "difficulty": "Some(Easy)",
      "end_line": 437,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 435
    },
    {
      "code_content": "                                    if config.enable_logging {\n                                        eprintln!(\"Worker {}: Failed to cache response: {:?}\", id, e);\n                                    }",
      "content_length": 203,
      "difficulty": "Some(Wild)",
      "end_line": 437,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 435
    },
    {
      "code_content": "        {\n            let mut metrics = self.service_metrics.lock().unwrap();\n            metrics.total_requests += 1;",
      "content_length": 118,
      "difficulty": "Some(Easy)",
      "end_line": 876,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 874
    },
    {
      "code_content": "        {\n            let mut metrics = self.service_metrics.lock().unwrap();\n            metrics.total_requests += 1;\n            metrics.queue_size = self.request_queue.lock().unwrap().len();\n        }",
      "content_length": 203,
      "difficulty": "Some(Normal)",
      "end_line": 878,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 874
    },
    {
      "code_content": "        {\n            let mut metrics = self.service_metrics.lock().unwrap();\n            metrics.total_requests += 1;\n            metrics.queue_size = self.request_queue.lock().unwrap().len();\n        }",
      "content_length": 203,
      "difficulty": "Some(Wild)",
      "end_line": 878,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 874
    },
    {
      "code_content": "pub struct ServiceConfig {",
      "content_length": 26,
      "difficulty": "Some(Easy)",
      "end_line": 16,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 16
    },
    {
      "code_content": "pub struct ServiceConfig {\n    pub max_connections: usize,\n    pub timeout: Duration,\n    pub retry_count: u32,\n    pub enable_logging: bool,\n    pub cache_size: usize,\n    pub worker_threads: usize,\n}",
      "content_length": 201,
      "difficulty": "Some(Normal)",
      "end_line": 23,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 16
    },
    {
      "code_content": "pub struct ServiceConfig {\n    pub max_connections: usize,\n    pub timeout: Duration,\n    pub retry_count: u32,\n    pub enable_logging: bool,\n    pub cache_size: usize,\n    pub worker_threads: usize,\n}",
      "content_length": 201,
      "difficulty": "Some(Wild)",
      "end_line": 23,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 16
    },
    {
      "code_content": "pub struct ServiceRequest {",
      "content_length": 27,
      "difficulty": "Some(Easy)",
      "end_line": 74,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 74
    },
    {
      "code_content": "pub struct ServiceRequest {\n    pub id: String,\n    pub method: RequestMethod,\n    pub data: RequestData,\n    pub headers: HashMap<String, String>,\n    pub timestamp: u64,\n    pub priority: Priority,\n}",
      "content_length": 201,
      "difficulty": "Some(Normal)",
      "end_line": 81,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 74
    },
    {
      "code_content": "pub struct ServiceRequest {\n    pub id: String,\n    pub method: RequestMethod,\n    pub data: RequestData,\n    pub headers: HashMap<String, String>,\n    pub timestamp: u64,\n    pub priority: Priority,\n}",
      "content_length": 201,
      "difficulty": "Some(Wild)",
      "end_line": 81,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 74
    },
    {
      "code_content": "            if entry.is_expired(self.ttl) {\n                data.remove(key);\n                self.remove_from_access_order(key);\n                stats.misses += 1;",
      "content_length": 164,
      "difficulty": "Some(Easy)",
      "end_line": 243,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 240
    },
    {
      "code_content": "            if entry.is_expired(self.ttl) {\n                data.remove(key);\n                self.remove_from_access_order(key);\n                stats.misses += 1;\n                None\n            }",
      "content_length": 199,
      "difficulty": "Some(Normal)",
      "end_line": 245,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 240
    },
    {
      "code_content": "            if entry.is_expired(self.ttl) {\n                data.remove(key);\n                self.remove_from_access_order(key);\n                stats.misses += 1;\n                None\n            }",
      "content_length": 199,
      "difficulty": "Some(Wild)",
      "end_line": 245,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 240
    },
    {
      "code_content": "            RequestData::Empty => {\n                serde_json::json!({\n                    \"message\": \"Empty data processed\",\n                    \"processed\": true,\n                })\n            }",
      "content_length": 198,
      "difficulty": "Some(Easy)",
      "end_line": 639,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 634
    },
    {
      "code_content": "            RequestData::Empty => {\n                serde_json::json!({\n                    \"message\": \"Empty data processed\",\n                    \"processed\": true,\n                })\n            }",
      "content_length": 198,
      "difficulty": "Some(Normal)",
      "end_line": 639,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 634
    },
    {
      "code_content": "            RequestData::Empty => {\n                serde_json::json!({\n                    \"message\": \"Empty data processed\",\n                    \"processed\": true,\n                })\n            }",
      "content_length": 198,
      "difficulty": "Some(Wild)",
      "end_line": 639,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 634
    },
    {
      "code_content": "        if request.id.is_empty() {\n            let mut counter = self.request_counter.lock().unwrap();\n            *counter += 1;",
      "content_length": 129,
      "difficulty": "Some(Easy)",
      "end_line": 853,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 851
    },
    {
      "code_content": "        if request.id.is_empty() {\n            let mut counter = self.request_counter.lock().unwrap();\n            *counter += 1;\n            request.id = format!(\"req_{:08x}\", *counter);\n        }",
      "content_length": 197,
      "difficulty": "Some(Normal)",
      "end_line": 855,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 851
    },
    {
      "code_content": "        if request.id.is_empty() {\n            let mut counter = self.request_counter.lock().unwrap();\n            *counter += 1;\n            request.id = format!(\"req_{:08x}\", *counter);\n        }",
      "content_length": 197,
      "difficulty": "Some(Wild)",
      "end_line": 855,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 851
    },
    {
      "code_content": "        if config.max_connections == 0 {",
      "content_length": 40,
      "difficulty": "Some(Easy)",
      "end_line": 783,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 783
    },
    {
      "code_content": "        if config.max_connections == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"max_connections must be greater than 0\".to_string()\n            ));\n        }",
      "content_length": 192,
      "difficulty": "Some(Normal)",
      "end_line": 787,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 783
    },
    {
      "code_content": "        if config.max_connections == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"max_connections must be greater than 0\".to_string()\n            ));\n        }",
      "content_length": 192,
      "difficulty": "Some(Wild)",
      "end_line": 787,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 783
    },
    {
      "code_content": "    pub fn hit_rate(&self) -> f64 {",
      "content_length": 35,
      "difficulty": "Some(Easy)",
      "end_line": 210,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 210
    },
    {
      "code_content": "    pub fn hit_rate(&self) -> f64 {\n        if self.hits + self.misses == 0 {\n            0.0\n        } else {\n            self.hits as f64 / (self.hits + self.misses) as f64\n        }\n    }",
      "content_length": 190,
      "difficulty": "Some(Normal)",
      "end_line": 216,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 210
    },
    {
      "code_content": "    pub fn hit_rate(&self) -> f64 {\n        if self.hits + self.misses == 0 {\n            0.0\n        } else {\n            self.hits as f64 / (self.hits + self.misses) as f64\n        }\n    }",
      "content_length": 190,
      "difficulty": "Some(Wild)",
      "end_line": 216,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 210
    },
    {
      "code_content": "        if config.worker_threads == 0 {",
      "content_length": 39,
      "difficulty": "Some(Easy)",
      "end_line": 789,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 789
    },
    {
      "code_content": "        if config.worker_threads == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"worker_threads must be greater than 0\".to_string()\n            ));\n        }",
      "content_length": 190,
      "difficulty": "Some(Normal)",
      "end_line": 793,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 789
    },
    {
      "code_content": "        if config.worker_threads == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"worker_threads must be greater than 0\".to_string()\n            ));\n        }",
      "content_length": 190,
      "difficulty": "Some(Wild)",
      "end_line": 793,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 789
    },
    {
      "code_content": "            } else {\n                let value = entry.access().clone();\n                self.move_to_front(key);\n                stats.hits += 1;\n                Some(value)\n            }",
      "content_length": 188,
      "difficulty": "Some(Easy)",
      "end_line": 250,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 245
    },
    {
      "code_content": "            } else {\n                let value = entry.access().clone();\n                self.move_to_front(key);\n                stats.hits += 1;\n                Some(value)\n            }",
      "content_length": 188,
      "difficulty": "Some(Normal)",
      "end_line": 250,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 245
    },
    {
      "code_content": "            } else {\n                let value = entry.access().clone();\n                self.move_to_front(key);\n                stats.hits += 1;\n                Some(value)\n            }",
      "content_length": 188,
      "difficulty": "Some(Wild)",
      "end_line": 250,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 245
    },
    {
      "code_content": "pub enum ResponseStatus {",
      "content_length": 25,
      "difficulty": "Some(Easy)",
      "end_line": 127,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 127
    },
    {
      "code_content": "pub enum ResponseStatus {\n    Success = 200,\n    Created = 201,\n    BadRequest = 400,\n    Unauthorized = 401,\n    NotFound = 404,\n    InternalError = 500,\n    ServiceUnavailable = 503,\n}",
      "content_length": 186,
      "difficulty": "Some(Normal)",
      "end_line": 135,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 127
    },
    {
      "code_content": "pub enum ResponseStatus {\n    Success = 200,\n    Created = 201,\n    BadRequest = 400,\n    Unauthorized = 401,\n    NotFound = 404,\n    InternalError = 500,\n    ServiceUnavailable = 503,\n}",
      "content_length": 186,
      "difficulty": "Some(Wild)",
      "end_line": 135,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 127
    },
    {
      "code_content": "        if config.timeout.as_secs() == 0 {",
      "content_length": 42,
      "difficulty": "Some(Easy)",
      "end_line": 801,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 801
    },
    {
      "code_content": "        if config.timeout.as_secs() == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"timeout must be greater than 0\".to_string()\n            ));\n        }",
      "content_length": 186,
      "difficulty": "Some(Normal)",
      "end_line": 805,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 801
    },
    {
      "code_content": "        if config.timeout.as_secs() == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"timeout must be greater than 0\".to_string()\n            ));\n        }",
      "content_length": 186,
      "difficulty": "Some(Wild)",
      "end_line": 805,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 801
    },
    {
      "code_content": "        if !self.worker_handles.is_empty() {",
      "content_length": 44,
      "difficulty": "Some(Easy)",
      "end_line": 811,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 811
    },
    {
      "code_content": "        if !self.worker_handles.is_empty() {\n            return Err(ServiceError::ConfigurationError(\n                \"Service is already running\".to_string()\n            ));\n        }",
      "content_length": 184,
      "difficulty": "Some(Normal)",
      "end_line": 815,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 811
    },
    {
      "code_content": "        if !self.worker_handles.is_empty() {\n            return Err(ServiceError::ConfigurationError(\n                \"Service is already running\".to_string()\n            ));\n        }",
      "content_length": 184,
      "difficulty": "Some(Wild)",
      "end_line": 815,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 811
    },
    {
      "code_content": "        while let Some(handle) = self.worker_handles.pop() {",
      "content_length": 60,
      "difficulty": "Some(Easy)",
      "end_line": 836,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 836
    },
    {
      "code_content": "        while let Some(handle) = self.worker_handles.pop() {\n            if let Err(_) = handle.join() {\n                return Err(ServiceError::WorkerPanic);\n            }\n        }",
      "content_length": 183,
      "difficulty": "Some(Normal)",
      "end_line": 840,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 836
    },
    {
      "code_content": "        while let Some(handle) = self.worker_handles.pop() {\n            if let Err(_) = handle.join() {\n                return Err(ServiceError::WorkerPanic);\n            }\n        }",
      "content_length": 183,
      "difficulty": "Some(Wild)",
      "end_line": 840,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 836
    },
    {
      "code_content": "                    let response = if let Some(cached) = cached_response {\n                        local_metrics.cache_hits += 1;\n                        cached\n                    }",
      "content_length": 182,
      "difficulty": "Some(Easy)",
      "end_line": 426,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 423
    },
    {
      "code_content": "                    let response = if let Some(cached) = cached_response {\n                        local_metrics.cache_hits += 1;\n                        cached\n                    }",
      "content_length": 182,
      "difficulty": "Some(Normal)",
      "end_line": 426,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 423
    },
    {
      "code_content": "                    let response = if let Some(cached) = cached_response {\n                        local_metrics.cache_hits += 1;\n                        cached\n                    }",
      "content_length": 182,
      "difficulty": "Some(Wild)",
      "end_line": 426,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 423
    },
    {
      "code_content": "                    {\n                        let mut sender = response_sender.lock().unwrap();\n                        sender.insert(req.id.clone(), response);\n                    }",
      "content_length": 182,
      "difficulty": "Some(Easy)",
      "end_line": 465,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 462
    },
    {
      "code_content": "                    {\n                        let mut sender = response_sender.lock().unwrap();\n                        sender.insert(req.id.clone(), response);\n                    }",
      "content_length": 182,
      "difficulty": "Some(Normal)",
      "end_line": 465,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 462
    },
    {
      "code_content": "                    {\n                        let mut sender = response_sender.lock().unwrap();\n                        sender.insert(req.id.clone(), response);\n                    }",
      "content_length": 182,
      "difficulty": "Some(Wild)",
      "end_line": 465,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 462
    },
    {
      "code_content": "        if config.cache_size == 0 {",
      "content_length": 35,
      "difficulty": "Some(Easy)",
      "end_line": 795,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 795
    },
    {
      "code_content": "        if config.cache_size == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"cache_size must be greater than 0\".to_string()\n            ));\n        }",
      "content_length": 182,
      "difficulty": "Some(Normal)",
      "end_line": 799,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 795
    },
    {
      "code_content": "        if config.cache_size == 0 {\n            return Err(ServiceError::ConfigurationError(\n                \"cache_size must be greater than 0\".to_string()\n            ));\n        }",
      "content_length": 182,
      "difficulty": "Some(Wild)",
      "end_line": 799,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 795
    },
    {
      "code_content": "        if data_size > 50_000_000 {",
      "content_length": 35,
      "difficulty": "Some(Easy)",
      "end_line": 896,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 896
    },
    {
      "code_content": "        if data_size > 50_000_000 {\n            return Err(ServiceError::InvalidInput(\n                \"Request data exceeds maximum size limit\".to_string()\n            ));\n        }",
      "content_length": 182,
      "difficulty": "Some(Normal)",
      "end_line": 900,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 896
    },
    {
      "code_content": "        if data_size > 50_000_000 {\n            return Err(ServiceError::InvalidInput(\n                \"Request data exceeds maximum size limit\".to_string()\n            ));\n        }",
      "content_length": 182,
      "difficulty": "Some(Wild)",
      "end_line": 900,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 896
    },
    {
      "code_content": "                serde_json::json!({\n                    \"form_fields\": form,\n                    \"field_count\": form.len(),\n                    \"processed\": true,\n                })",
      "content_length": 181,
      "difficulty": "Some(Easy)",
      "end_line": 625,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 621
    },
    {
      "code_content": "                serde_json::json!({\n                    \"form_fields\": form,\n                    \"field_count\": form.len(),\n                    \"processed\": true,\n                })",
      "content_length": 181,
      "difficulty": "Some(Normal)",
      "end_line": 625,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 621
    },
    {
      "code_content": "                serde_json::json!({\n                    \"form_fields\": form,\n                    \"field_count\": form.len(),\n                    \"processed\": true,\n                })",
      "content_length": 181,
      "difficulty": "Some(Wild)",
      "end_line": 625,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 621
    },
    {
      "code_content": "    pub fn get_response(&self, request_id: &str) -> Option<ServiceResponse> {",
      "content_length": 77,
      "difficulty": "Some(Easy)",
      "end_line": 905,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 905
    },
    {
      "code_content": "    pub fn get_response(&self, request_id: &str) -> Option<ServiceResponse> {\n        let mut store = self.response_store.lock().unwrap();\n        store.remove(request_id)\n    }",
      "content_length": 177,
      "difficulty": "Some(Normal)",
      "end_line": 908,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 905
    },
    {
      "code_content": "    pub fn get_response(&self, request_id: &str) -> Option<ServiceResponse> {\n        let mut store = self.response_store.lock().unwrap();\n        store.remove(request_id)\n    }",
      "content_length": 177,
      "difficulty": "Some(Wild)",
      "end_line": 908,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 905
    },
    {
      "code_content": "        if let Some(pos) = access_order.iter().position(|x| x == key) {\n            let key = access_order.remove(pos);",
      "content_length": 119,
      "difficulty": "Some(Easy)",
      "end_line": 310,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 309
    },
    {
      "code_content": "        if let Some(pos) = access_order.iter().position(|x| x == key) {\n            let key = access_order.remove(pos);\n            access_order.insert(0, key);\n        }",
      "content_length": 170,
      "difficulty": "Some(Normal)",
      "end_line": 312,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 309
    },
    {
      "code_content": "        if let Some(pos) = access_order.iter().position(|x| x == key) {\n            let key = access_order.remove(pos);\n            access_order.insert(0, key);\n        }",
      "content_length": 170,
      "difficulty": "Some(Wild)",
      "end_line": 312,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 309
    },
    {
      "code_content": "                } else {\n                    // No requests available, sleep briefly\n                    thread::sleep(Duration::from_millis(10));\n                }",
      "content_length": 164,
      "difficulty": "Some(Easy)",
      "end_line": 469,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 466
    },
    {
      "code_content": "                } else {\n                    // No requests available, sleep briefly\n                    thread::sleep(Duration::from_millis(10));\n                }",
      "content_length": 164,
      "difficulty": "Some(Wild)",
      "end_line": 469,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 466
    },
    {
      "code_content": "                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.failed_requests += 1;\n                }",
      "content_length": 161,
      "difficulty": "Some(Easy)",
      "end_line": 932,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 929
    },
    {
      "code_content": "                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.failed_requests += 1;\n                }",
      "content_length": 161,
      "difficulty": "Some(Normal)",
      "end_line": 932,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 929
    },
    {
      "code_content": "                {\n                    let mut metrics = self.service_metrics.lock().unwrap();\n                    metrics.failed_requests += 1;\n                }",
      "content_length": 161,
      "difficulty": "Some(Wild)",
      "end_line": 932,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 929
    },
    {
      "code_content": "            if queue.len() >= self.config.max_connections {\n                return Err(ServiceError::CacheFull); // Queue full, reusing error type\n            }",
      "content_length": 160,
      "difficulty": "Some(Easy)",
      "end_line": 865,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 863
    },
    {
      "code_content": "            if queue.len() >= self.config.max_connections {\n                return Err(ServiceError::CacheFull); // Queue full, reusing error type\n            }",
      "content_length": 160,
      "difficulty": "Some(Wild)",
      "end_line": 865,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 863
    },
    {
      "code_content": "            ServiceError::ParseError { line, column, details } => {\n                write!(f, \"Parse error at {}:{}: {}\", line, column, details)",
      "content_length": 144,
      "difficulty": "Some(Easy)",
      "end_line": 64,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 63
    },
    {
      "code_content": "            ServiceError::ParseError { line, column, details } => {\n                write!(f, \"Parse error at {}:{}: {}\", line, column, details)\n            }",
      "content_length": 158,
      "difficulty": "Some(Normal)",
      "end_line": 65,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 63
    },
    {
      "code_content": "            ServiceError::ParseError { line, column, details } => {\n                write!(f, \"Parse error at {}:{}: {}\", line, column, details)\n            }",
      "content_length": 158,
      "difficulty": "Some(Wild)",
      "end_line": 65,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 63
    },
    {
      "code_content": "        if let Some(old_entry) = data.remove(&key) {\n            *current_size -= old_entry.size;",
      "content_length": 97,
      "difficulty": "Some(Easy)",
      "end_line": 275,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 274
    },
    {
      "code_content": "        if let Some(old_entry) = data.remove(&key) {\n            *current_size -= old_entry.size;\n            self.remove_from_access_order(&key);\n        }",
      "content_length": 156,
      "difficulty": "Some(Normal)",
      "end_line": 277,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 274
    },
    {
      "code_content": "        if let Some(old_entry) = data.remove(&key) {\n            *current_size -= old_entry.size;\n            self.remove_from_access_order(&key);\n        }",
      "content_length": 156,
      "difficulty": "Some(Wild)",
      "end_line": 277,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 274
    },
    {
      "code_content": "            if let Err(_) = self.evict_lru(&mut data, &mut *current_size, &mut stats) {\n                return Err(ServiceError::CacheFull);",
      "content_length": 140,
      "difficulty": "Some(Easy)",
      "end_line": 265,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 264
    },
    {
      "code_content": "            if let Err(_) = self.evict_lru(&mut data, &mut *current_size, &mut stats) {\n                return Err(ServiceError::CacheFull);\n            }",
      "content_length": 154,
      "difficulty": "Some(Normal)",
      "end_line": 266,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 264
    },
    {
      "code_content": "            if let Err(_) = self.evict_lru(&mut data, &mut *current_size, &mut stats) {\n                return Err(ServiceError::CacheFull);\n            }",
      "content_length": 154,
      "difficulty": "Some(Wild)",
      "end_line": 266,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 264
    },
    {
      "code_content": "pub enum ResponseData {\n    Json(serde_json::Value),\n    Binary(Vec<u8>),\n    Text(String),\n    Stream(String), // URL or identifier for streaming data\n}",
      "content_length": 153,
      "difficulty": "Some(Easy)",
      "end_line": 144,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 139
    },
    {
      "code_content": "pub enum ResponseData {\n    Json(serde_json::Value),\n    Binary(Vec<u8>),\n    Text(String),\n    Stream(String), // URL or identifier for streaming data\n}",
      "content_length": 153,
      "difficulty": "Some(Normal)",
      "end_line": 144,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 139
    },
    {
      "code_content": "pub enum ResponseData {\n    Json(serde_json::Value),\n    Binary(Vec<u8>),\n    Text(String),\n    Stream(String), // URL or identifier for streaming data\n}",
      "content_length": 153,
      "difficulty": "Some(Wild)",
      "end_line": 144,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 139
    },
    {
      "code_content": "        if data_size > 10_000_000 { // 10MB limit\n            return Err(ServiceError::InvalidInput(\"Request data too large\".to_string()));\n        }",
      "content_length": 149,
      "difficulty": "Some(Easy)",
      "end_line": 580,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 578
    },
    {
      "code_content": "        if data_size > 10_000_000 { // 10MB limit\n            return Err(ServiceError::InvalidInput(\"Request data too large\".to_string()));\n        }",
      "content_length": 149,
      "difficulty": "Some(Normal)",
      "end_line": 580,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 578
    },
    {
      "code_content": "        if data_size > 10_000_000 { // 10MB limit\n            return Err(ServiceError::InvalidInput(\"Request data too large\".to_string()));\n        }",
      "content_length": 149,
      "difficulty": "Some(Wild)",
      "end_line": 580,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 578
    },
    {
      "code_content": "        if self.hits + self.misses == 0 {\n            0.0\n        } else {\n            self.hits as f64 / (self.hits + self.misses) as f64\n        }",
      "content_length": 148,
      "difficulty": "Some(Easy)",
      "end_line": 215,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 211
    },
    {
      "code_content": "        if self.hits + self.misses == 0 {\n            0.0\n        } else {\n            self.hits as f64 / (self.hits + self.misses) as f64\n        }",
      "content_length": 148,
      "difficulty": "Some(Normal)",
      "end_line": 215,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 211
    },
    {
      "code_content": "        if self.hits + self.misses == 0 {\n            0.0\n        } else {\n            self.hits as f64 / (self.hits + self.misses) as f64\n        }",
      "content_length": 148,
      "difficulty": "Some(Wild)",
      "end_line": 215,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 211
    },
    {
      "code_content": "                let should_continue = {\n                    let running = is_running.lock().unwrap();\n                    *running\n                }",
      "content_length": 148,
      "difficulty": "Some(Easy)",
      "end_line": 405,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 402
    },
    {
      "code_content": "                let should_continue = {\n                    let running = is_running.lock().unwrap();\n                    *running\n                }",
      "content_length": 148,
      "difficulty": "Some(Wild)",
      "end_line": 405,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 402
    },
    {
      "code_content": "                let request = {\n                    let mut queue = request_queue.lock().unwrap();\n                    queue.pop()\n                }",
      "content_length": 148,
      "difficulty": "Some(Easy)",
      "end_line": 415,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 412
    },
    {
      "code_content": "                let request = {\n                    let mut queue = request_queue.lock().unwrap();\n                    queue.pop()\n                }",
      "content_length": 148,
      "difficulty": "Some(Wild)",
      "end_line": 415,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 412
    },
    {
      "code_content": "                serde_json::json!({\n                    \"message\": \"Empty data processed\",\n                    \"processed\": true,\n                })",
      "content_length": 148,
      "difficulty": "Some(Easy)",
      "end_line": 638,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 635
    },
    {
      "code_content": "                serde_json::json!({\n                    \"message\": \"Empty data processed\",\n                    \"processed\": true,\n                })",
      "content_length": 148,
      "difficulty": "Some(Wild)",
      "end_line": 638,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 635
    },
    {
      "code_content": "    fn add_to_front(&self, key: K) {\n        let mut access_order = self.access_order.lock().unwrap();",
      "content_length": 102,
      "difficulty": "Some(Easy)",
      "end_line": 316,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 315
    },
    {
      "code_content": "    fn add_to_front(&self, key: K) {\n        let mut access_order = self.access_order.lock().unwrap();\n        access_order.insert(0, key);\n    }",
      "content_length": 145,
      "difficulty": "Some(Normal)",
      "end_line": 318,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 315
    },
    {
      "code_content": "    fn add_to_front(&self, key: K) {\n        let mut access_order = self.access_order.lock().unwrap();\n        access_order.insert(0, key);\n    }",
      "content_length": 145,
      "difficulty": "Some(Wild)",
      "end_line": 318,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 315
    },
    {
      "code_content": "pub enum RequestData {\n    Json(serde_json::Value),\n    Binary(Vec<u8>),\n    Text(String),\n    FormData(HashMap<String, String>),\n    Empty,\n}",
      "content_length": 142,
      "difficulty": "Some(Normal)",
      "end_line": 103,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 97
    },
    {
      "code_content": "pub enum RequestData {\n    Json(serde_json::Value),\n    Binary(Vec<u8>),\n    Text(String),\n    FormData(HashMap<String, String>),\n    Empty,\n}",
      "content_length": 142,
      "difficulty": "Some(Wild)",
      "end_line": 103,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 97
    },
    {
      "code_content": "        if self.config.enable_logging {",
      "content_length": 39,
      "difficulty": "Some(Easy)",
      "end_line": 822,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 822
    },
    {
      "code_content": "        if self.config.enable_logging {\n            println!(\"ComplexService started with {} workers\", self.config.worker_threads);\n        }",
      "content_length": 141,
      "difficulty": "Some(Normal)",
      "end_line": 824,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 822
    },
    {
      "code_content": "        if self.config.enable_logging {\n            println!(\"ComplexService started with {} workers\", self.config.worker_threads);\n        }",
      "content_length": 141,
      "difficulty": "Some(Wild)",
      "end_line": 824,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 822
    },
    {
      "code_content": "            ServiceError::NetworkError { code, message } => {\n                write!(f, \"Network error {}: {}\", code, message)\n            }",
      "content_length": 140,
      "difficulty": "Some(Easy)",
      "end_line": 62,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 60
    },
    {
      "code_content": "            ServiceError::NetworkError { code, message } => {\n                write!(f, \"Network error {}: {}\", code, message)\n            }",
      "content_length": 140,
      "difficulty": "Some(Normal)",
      "end_line": 62,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 60
    },
    {
      "code_content": "            ServiceError::NetworkError { code, message } => {\n                write!(f, \"Network error {}: {}\", code, message)\n            }",
      "content_length": 140,
      "difficulty": "Some(Wild)",
      "end_line": 62,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 60
    },
    {
      "code_content": "            return Err(ServiceError::ConfigurationError(\n                \"max_connections must be greater than 0\".to_string()\n            ))",
      "content_length": 140,
      "difficulty": "Some(Easy)",
      "end_line": 786,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 784
    },
    {
      "code_content": "            return Err(ServiceError::ConfigurationError(\n                \"max_connections must be greater than 0\".to_string()\n            ))",
      "content_length": 140,
      "difficulty": "Some(Normal)",
      "end_line": 786,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 784
    },
    {
      "code_content": "            return Err(ServiceError::ConfigurationError(\n                \"max_connections must be greater than 0\".to_string()\n            ))",
      "content_length": 140,
      "difficulty": "Some(Wild)",
      "end_line": 786,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 784
    },
    {
      "code_content": "        let cache = Arc::new(LruCache::new(\n            config.cache_size,\n            Duration::from_secs(300), // 5 minute TTL\n        ))",
      "content_length": 139,
      "difficulty": "Some(Easy)",
      "end_line": 753,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 750
    },
    {
      "code_content": "        let cache = Arc::new(LruCache::new(\n            config.cache_size,\n            Duration::from_secs(300), // 5 minute TTL\n        ))",
      "content_length": 139,
      "difficulty": "Some(Wild)",
      "end_line": 753,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 750
    },
    {
      "code_content": "            return Err(ServiceError::ConfigurationError(\n                \"worker_threads must be greater than 0\".to_string()\n            ))",
      "content_length": 139,
      "difficulty": "Some(Easy)",
      "end_line": 792,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 790
    },
    {
      "code_content": "            return Err(ServiceError::ConfigurationError(\n                \"worker_threads must be greater than 0\".to_string()\n            ))",
      "content_length": 139,
      "difficulty": "Some(Normal)",
      "end_line": 792,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 790
    },
    {
      "code_content": "            return Err(ServiceError::ConfigurationError(\n                \"worker_threads must be greater than 0\".to_string()\n            ))",
      "content_length": 139,
      "difficulty": "Some(Wild)",
      "end_line": 792,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 790
    },
    {
      "code_content": "        if request.id.is_empty() {\n            return Err(ServiceError::InvalidInput(\"Request ID cannot be empty\".to_string()));",
      "content_length": 128,
      "difficulty": "Some(Easy)",
      "end_line": 560,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 559
    },
    {
      "code_content": "        if request.id.is_empty() {\n            return Err(ServiceError::InvalidInput(\"Request ID cannot be empty\".to_string()));\n        }",
      "content_length": 138,
      "difficulty": "Some(Normal)",
      "end_line": 561,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 559
    },
    {
      "code_content": "        if request.id.is_empty() {\n            return Err(ServiceError::InvalidInput(\"Request ID cannot be empty\".to_string()));\n        }",
      "content_length": 138,
      "difficulty": "Some(Wild)",
      "end_line": 561,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 559
    },
    {
      "code_content": "            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>() as f64 / 1000.0\n            }",
      "content_length": 136,
      "difficulty": "Some(Easy)",
      "end_line": 550,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 548
    },
    {
      "code_content": "            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>() as f64 / 1000.0\n            }",
      "content_length": 136,
      "difficulty": "Some(Normal)",
      "end_line": 550,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 548
    },
    {
      "code_content": "            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>() as f64 / 1000.0\n            }",
      "content_length": 136,
      "difficulty": "Some(Wild)",
      "end_line": 550,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 548
    },
    {
      "code_content": "pub struct CacheStats {\n    pub hits: u64,\n    pub misses: u64,\n    pub evictions: u64,\n    pub size: usize,\n    pub capacity: usize,\n}",
      "content_length": 135,
      "difficulty": "Some(Easy)",
      "end_line": 207,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 201
    },
    {
      "code_content": "pub struct CacheStats {\n    pub hits: u64,\n    pub misses: u64,\n    pub evictions: u64,\n    pub size: usize,\n    pub capacity: usize,\n}",
      "content_length": 135,
      "difficulty": "Some(Normal)",
      "end_line": 207,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 201
    },
    {
      "code_content": "pub struct CacheStats {\n    pub hits: u64,\n    pub misses: u64,\n    pub evictions: u64,\n    pub size: usize,\n    pub capacity: usize,\n}",
      "content_length": 135,
      "difficulty": "Some(Wild)",
      "end_line": 207,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 201
    },
    {
      "code_content": "            return Err(ServiceError::ConfigurationError(\n                \"cache_size must be greater than 0\".to_string()\n            ))",
      "content_length": 135,
      "difficulty": "Some(Easy)",
      "end_line": 798,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 796
    },
    {
      "code_content": "            return Err(ServiceError::ConfigurationError(\n                \"cache_size must be greater than 0\".to_string()\n            ))",
      "content_length": 135,
      "difficulty": "Some(Normal)",
      "end_line": 798,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 796
    },
    {
      "code_content": "            return Err(ServiceError::ConfigurationError(\n                \"cache_size must be greater than 0\".to_string()\n            ))",
      "content_length": 135,
      "difficulty": "Some(Wild)",
      "end_line": 798,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 796
    },
    {
      "code_content": "        for worker in &self.workers {\n            let handle = worker.start()?;\n            self.worker_handles.push(handle);\n        }",
      "content_length": 135,
      "difficulty": "Some(Easy)",
      "end_line": 820,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 817
    },
    {
      "code_content": "        for worker in &self.workers {\n            let handle = worker.start()?;\n            self.worker_handles.push(handle);\n        }",
      "content_length": 135,
      "difficulty": "Some(Normal)",
      "end_line": 820,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 817
    },
    {
      "code_content": "        for worker in &self.workers {\n            let handle = worker.start()?;\n            self.worker_handles.push(handle);\n        }",
      "content_length": 135,
      "difficulty": "Some(Wild)",
      "end_line": 820,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 817
    },
    {
      "code_content": "            return Err(ServiceError::InvalidInput(\n                \"Request data exceeds maximum size limit\".to_string()\n            ))",
      "content_length": 135,
      "difficulty": "Some(Easy)",
      "end_line": 899,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 897
    },
    {
      "code_content": "            return Err(ServiceError::InvalidInput(\n                \"Request data exceeds maximum size limit\".to_string()\n            ))",
      "content_length": 135,
      "difficulty": "Some(Normal)",
      "end_line": 899,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 897
    },
    {
      "code_content": "            return Err(ServiceError::InvalidInput(\n                \"Request data exceeds maximum size limit\".to_string()\n            ))",
      "content_length": 135,
      "difficulty": "Some(Wild)",
      "end_line": 899,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 897
    },
    {
      "code_content": "    fn access(&mut self) -> &T {\n        self.access_count += 1;\n        self.last_accessed = Instant::now();\n        &self.data\n    }",
      "content_length": 134,
      "difficulty": "Some(Easy)",
      "end_line": 172,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 168
    },
    {
      "code_content": "    fn access(&mut self) -> &T {\n        self.access_count += 1;\n        self.last_accessed = Instant::now();\n        &self.data\n    }",
      "content_length": 134,
      "difficulty": "Some(Normal)",
      "end_line": 172,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 168
    },
    {
      "code_content": "    fn access(&mut self) -> &T {\n        self.access_count += 1;\n        self.last_accessed = Instant::now();\n        &self.data\n    }",
      "content_length": 134,
      "difficulty": "Some(Wild)",
      "end_line": 172,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 168
    },
    {
      "code_content": "        if request.id.len() > 255 {\n            return Err(ServiceError::InvalidInput(\"Request ID too long\".to_string()));\n        }",
      "content_length": 132,
      "difficulty": "Some(Easy)",
      "end_line": 565,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 563
    },
    {
      "code_content": "        if request.id.len() > 255 {\n            return Err(ServiceError::InvalidInput(\"Request ID too long\".to_string()));\n        }",
      "content_length": 132,
      "difficulty": "Some(Normal)",
      "end_line": 565,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 563
    },
    {
      "code_content": "        if request.id.len() > 255 {\n            return Err(ServiceError::InvalidInput(\"Request ID too long\".to_string()));\n        }",
      "content_length": 132,
      "difficulty": "Some(Wild)",
      "end_line": 565,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 563
    },
    {
      "code_content": "            return Err(ServiceError::ConfigurationError(\n                \"timeout must be greater than 0\".to_string()\n            ))",
      "content_length": 132,
      "difficulty": "Some(Easy)",
      "end_line": 804,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 802
    },
    {
      "code_content": "            return Err(ServiceError::ConfigurationError(\n                \"timeout must be greater than 0\".to_string()\n            ))",
      "content_length": 132,
      "difficulty": "Some(Normal)",
      "end_line": 804,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 802
    },
    {
      "code_content": "            return Err(ServiceError::ConfigurationError(\n                \"timeout must be greater than 0\".to_string()\n            ))",
      "content_length": 132,
      "difficulty": "Some(Wild)",
      "end_line": 804,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 802
    },
    {
      "code_content": "struct CacheEntry<T> {\n    data: T,\n    created_at: Instant,\n    access_count: u64,\n    last_accessed: Instant,\n    size: usize,\n}",
      "content_length": 130,
      "difficulty": "Some(Easy)",
      "end_line": 154,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 148
    },
    {
      "code_content": "struct CacheEntry<T> {\n    data: T,\n    created_at: Instant,\n    access_count: u64,\n    last_accessed: Instant,\n    size: usize,\n}",
      "content_length": 130,
      "difficulty": "Some(Normal)",
      "end_line": 154,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 148
    },
    {
      "code_content": "struct CacheEntry<T> {\n    data: T,\n    created_at: Instant,\n    access_count: u64,\n    last_accessed: Instant,\n    size: usize,\n}",
      "content_length": 130,
      "difficulty": "Some(Wild)",
      "end_line": 154,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 148
    },
    {
      "code_content": "            return Err(ServiceError::ConfigurationError(\n                \"Service is already running\".to_string()\n            ))",
      "content_length": 128,
      "difficulty": "Some(Easy)",
      "end_line": 814,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 812
    },
    {
      "code_content": "            return Err(ServiceError::ConfigurationError(\n                \"Service is already running\".to_string()\n            ))",
      "content_length": 128,
      "difficulty": "Some(Normal)",
      "end_line": 814,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 812
    },
    {
      "code_content": "            return Err(ServiceError::ConfigurationError(\n                \"Service is already running\".to_string()\n            ))",
      "content_length": 128,
      "difficulty": "Some(Wild)",
      "end_line": 814,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 812
    },
    {
      "code_content": "            let insert_pos = queue.iter().position(|r| r.priority < request.priority)\n                .unwrap_or(queue.len())",
      "content_length": 125,
      "difficulty": "Some(Easy)",
      "end_line": 869,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 868
    },
    {
      "code_content": "            let insert_pos = queue.iter().position(|r| r.priority < request.priority)\n                .unwrap_or(queue.len())",
      "content_length": 125,
      "difficulty": "Some(Normal)",
      "end_line": 869,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 868
    },
    {
      "code_content": "            let insert_pos = queue.iter().position(|r| r.priority < request.priority)\n                .unwrap_or(queue.len())",
      "content_length": 125,
      "difficulty": "Some(Wild)",
      "end_line": 869,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 868
    },
    {
      "code_content": "        let headers_size = response.headers.iter()\n            .map(|(k, v)| k.len() + v.len())\n            .sum::<usize>()",
      "content_length": 123,
      "difficulty": "Some(Easy)",
      "end_line": 708,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 706
    },
    {
      "code_content": "        let headers_size = response.headers.iter()\n            .map(|(k, v)| k.len() + v.len())\n            .sum::<usize>()",
      "content_length": 123,
      "difficulty": "Some(Normal)",
      "end_line": 708,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 706
    },
    {
      "code_content": "        let headers_size = response.headers.iter()\n            .map(|(k, v)| k.len() + v.len())\n            .sum::<usize>()",
      "content_length": 123,
      "difficulty": "Some(Wild)",
      "end_line": 708,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 706
    },
    {
      "code_content": "    pub fn worker_metrics(&self) -> Vec<WorkerMetrics> {\n        self.workers.iter().map(|w| w.metrics()).collect()\n    }",
      "content_length": 121,
      "difficulty": "Some(Easy)",
      "end_line": 953,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 951
    },
    {
      "code_content": "    pub fn worker_metrics(&self) -> Vec<WorkerMetrics> {\n        self.workers.iter().map(|w| w.metrics()).collect()\n    }",
      "content_length": 121,
      "difficulty": "Some(Normal)",
      "end_line": 953,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 951
    },
    {
      "code_content": "    pub fn worker_metrics(&self) -> Vec<WorkerMetrics> {\n        self.workers.iter().map(|w| w.metrics()).collect()\n    }",
      "content_length": 121,
      "difficulty": "Some(Wild)",
      "end_line": 953,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 951
    },
    {
      "code_content": "            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>()\n            }",
      "content_length": 120,
      "difficulty": "Some(Easy)",
      "end_line": 574,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 572
    },
    {
      "code_content": "            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>()\n            }",
      "content_length": 120,
      "difficulty": "Some(Wild)",
      "end_line": 574,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 572
    },
    {
      "code_content": "            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>()\n            }",
      "content_length": 120,
      "difficulty": "Some(Easy)",
      "end_line": 891,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 889
    },
    {
      "code_content": "            RequestData::FormData(form) => {\n                form.values().map(|v| v.len()).sum::<usize>()\n            }",
      "content_length": 120,
      "difficulty": "Some(Wild)",
      "end_line": 891,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 889
    },
    {
      "code_content": "        if let Some(pos) = access_order.iter().position(|x| x == key) {\n            access_order.remove(pos);\n        }",
      "content_length": 119,
      "difficulty": "Some(Easy)",
      "end_line": 324,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 322
    },
    {
      "code_content": "        if let Some(pos) = access_order.iter().position(|x| x == key) {\n            access_order.remove(pos);\n        }",
      "content_length": 119,
      "difficulty": "Some(Normal)",
      "end_line": 324,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 322
    },
    {
      "code_content": "        if let Some(pos) = access_order.iter().position(|x| x == key) {\n            access_order.remove(pos);\n        }",
      "content_length": 119,
      "difficulty": "Some(Wild)",
      "end_line": 324,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 322
    },
    {
      "code_content": "    pub fn stop(&self) {\n        let mut running = self.is_running.lock().unwrap();\n        *running = false;\n    }",
      "content_length": 115,
      "difficulty": "Some(Easy)",
      "end_line": 489,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 486
    },
    {
      "code_content": "    pub fn stop(&self) {\n        let mut running = self.is_running.lock().unwrap();\n        *running = false;\n    }",
      "content_length": 115,
      "difficulty": "Some(Wild)",
      "end_line": 489,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 486
    },
    {
      "code_content": "            if let Err(_) = handle.join() {\n                return Err(ServiceError::WorkerPanic);\n            }",
      "content_length": 112,
      "difficulty": "Some(Easy)",
      "end_line": 839,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 837
    },
    {
      "code_content": "            if let Err(_) = handle.join() {\n                return Err(ServiceError::WorkerPanic);\n            }",
      "content_length": 112,
      "difficulty": "Some(Wild)",
      "end_line": 839,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 837
    },
    {
      "code_content": "        if *current_size + size > self.capacity {\n            return Err(ServiceError::CacheFull);\n        }",
      "content_length": 108,
      "difficulty": "Some(Easy)",
      "end_line": 271,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 269
    },
    {
      "code_content": "        if *current_size + size > self.capacity {\n            return Err(ServiceError::CacheFull);\n        }",
      "content_length": 108,
      "difficulty": "Some(Wild)",
      "end_line": 271,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 269
    },
    {
      "code_content": "        {\n            let mut running = is_running.lock().unwrap();\n            *running = true;\n        }",
      "content_length": 106,
      "difficulty": "Some(Easy)",
      "end_line": 396,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 393
    },
    {
      "code_content": "        {\n            let mut running = is_running.lock().unwrap();\n            *running = true;\n        }",
      "content_length": 106,
      "difficulty": "Some(Wild)",
      "end_line": 396,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 393
    },
    {
      "code_content": "pub enum RequestMethod {\n    Get,\n    Post,\n    Put,\n    Delete,\n    Patch,\n    Head,\n    Options,\n}",
      "content_length": 100,
      "difficulty": "Some(Easy)",
      "end_line": 93,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 85
    },
    {
      "code_content": "pub enum RequestMethod {\n    Get,\n    Post,\n    Put,\n    Delete,\n    Patch,\n    Head,\n    Options,\n}",
      "content_length": 100,
      "difficulty": "Some(Wild)",
      "end_line": 93,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 85
    },
    {
      "code_content": "        if self.config.enable_logging {\n            println!(\"ComplexService stopped\");\n        }",
      "content_length": 97,
      "difficulty": "Some(Easy)",
      "end_line": 844,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 842
    },
    {
      "code_content": "        if self.config.enable_logging {\n            println!(\"ComplexService stopped\");\n        }",
      "content_length": 97,
      "difficulty": "Some(Wild)",
      "end_line": 844,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 842
    },
    {
      "code_content": "    fn is_expired(&self, ttl: Duration) -> bool {\n        self.created_at.elapsed() > ttl\n    }",
      "content_length": 95,
      "difficulty": "Some(Easy)",
      "end_line": 176,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 174
    },
    {
      "code_content": "    fn is_expired(&self, ttl: Duration) -> bool {\n        self.created_at.elapsed() > ttl\n    }",
      "content_length": 95,
      "difficulty": "Some(Wild)",
      "end_line": 176,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 174
    },
    {
      "code_content": "    pub fn metrics(&self) -> WorkerMetrics {\n        self.metrics.lock().unwrap().clone()\n    }",
      "content_length": 95,
      "difficulty": "Some(Easy)",
      "end_line": 493,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 491
    },
    {
      "code_content": "    pub fn metrics(&self) -> WorkerMetrics {\n        self.metrics.lock().unwrap().clone()\n    }",
      "content_length": 95,
      "difficulty": "Some(Wild)",
      "end_line": 493,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 491
    },
    {
      "code_content": "        let headers_size = response.headers.iter()\n            .map(|(k, v)| k.len() + v.len())",
      "content_length": 95,
      "difficulty": "Some(Easy)",
      "end_line": 707,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 706
    },
    {
      "code_content": "        let headers_size = response.headers.iter()\n            .map(|(k, v)| k.len() + v.len())",
      "content_length": 95,
      "difficulty": "Some(Wild)",
      "end_line": 707,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 706
    },
    {
      "code_content": "        } else {\n            self.hits as f64 / (self.hits + self.misses) as f64\n        }",
      "content_length": 90,
      "difficulty": "Some(Easy)",
      "end_line": 215,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 213
    },
    {
      "code_content": "        } else {\n            self.hits as f64 / (self.hits + self.misses) as f64\n        }",
      "content_length": 90,
      "difficulty": "Some(Wild)",
      "end_line": 215,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 213
    },
    {
      "code_content": "    pub fn stats(&self) -> CacheStats {\n        self.stats.lock().unwrap().clone()\n    }",
      "content_length": 88,
      "difficulty": "Some(Easy)",
      "end_line": 329,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 327
    },
    {
      "code_content": "    pub fn stats(&self) -> CacheStats {\n        self.stats.lock().unwrap().clone()\n    }",
      "content_length": 88,
      "difficulty": "Some(Wild)",
      "end_line": 329,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 327
    },
    {
      "code_content": "pub enum Priority {\n    Low = 1,\n    Normal = 2,\n    High = 3,\n    Critical = 4,\n}",
      "content_length": 82,
      "difficulty": "Some(Easy)",
      "end_line": 112,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 107
    },
    {
      "code_content": "pub enum Priority {\n    Low = 1,\n    Normal = 2,\n    High = 3,\n    Critical = 4,\n}",
      "content_length": 82,
      "difficulty": "Some(Wild)",
      "end_line": 112,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 107
    },
    {
      "code_content": "                if !should_continue {\n                    break;\n                }",
      "content_length": 82,
      "difficulty": "Some(Easy)",
      "end_line": 409,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 407
    },
    {
      "code_content": "                if !should_continue {\n                    break;\n                }",
      "content_length": 82,
      "difficulty": "Some(Wild)",
      "end_line": 409,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 407
    },
    {
      "code_content": "            } else {\n                Err(ServiceError::CacheFull)\n            }",
      "content_length": 79,
      "difficulty": "Some(Easy)",
      "end_line": 301,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 299
    },
    {
      "code_content": "            } else {\n                Err(ServiceError::CacheFull)\n            }",
      "content_length": 79,
      "difficulty": "Some(Wild)",
      "end_line": 301,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 299
    },
    {
      "code_content": "    pub fn cache_stats(&self) -> CacheStats {\n        self.cache.stats()\n    }",
      "content_length": 78,
      "difficulty": "Some(Easy)",
      "end_line": 957,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 955
    },
    {
      "code_content": "    pub fn cache_stats(&self) -> CacheStats {\n        self.cache.stats()\n    }",
      "content_length": 78,
      "difficulty": "Some(Wild)",
      "end_line": 957,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 955
    },
    {
      "code_content": "        } else {\n            stats.misses += 1;\n            None\n        }",
      "content_length": 74,
      "difficulty": "Some(Easy)",
      "end_line": 254,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 251
    },
    {
      "code_content": "        } else {\n            stats.misses += 1;\n            None\n        }",
      "content_length": 74,
      "difficulty": "Some(Wild)",
      "end_line": 254,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 251
    },
    {
      "code_content": "        for worker in &self.workers {\n            worker.stop();\n        }",
      "content_length": 74,
      "difficulty": "Some(Easy)",
      "end_line": 833,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 831
    },
    {
      "code_content": "        for worker in &self.workers {\n            worker.stop();\n        }",
      "content_length": 74,
      "difficulty": "Some(Wild)",
      "end_line": 833,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 831
    },
    {
      "code_content": "        } else {\n            Err(ServiceError::CacheFull)\n        }",
      "content_length": 67,
      "difficulty": "Some(Easy)",
      "end_line": 304,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 302
    },
    {
      "code_content": "        } else {\n            Err(ServiceError::CacheFull)\n        }",
      "content_length": 67,
      "difficulty": "Some(Wild)",
      "end_line": 304,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 302
    },
    {
      "code_content": "    pub fn clear_cache(&self) {\n        self.cache.clear();\n    }",
      "content_length": 65,
      "difficulty": "Some(Easy)",
      "end_line": 961,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 959
    },
    {
      "code_content": "    pub fn clear_cache(&self) {\n        self.cache.clear();\n    }",
      "content_length": 65,
      "difficulty": "Some(Wild)",
      "end_line": 961,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 959
    },
    {
      "code_content": "impl std::error::Error for ServiceError {}",
      "content_length": 42,
      "difficulty": "Some(Easy)",
      "end_line": 70,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 70
    },
    {
      "code_content": "impl std::error::Error for ServiceError {}",
      "content_length": 42,
      "difficulty": "Some(Wild)",
      "end_line": 70,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 70
    },
    {
      "code_content": "impl std::fmt::Display for ServiceError",
      "content_length": 39,
      "difficulty": "Some(Easy)",
      "end_line": 51,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 51
    },
    {
      "code_content": "impl std::fmt::Display for ServiceError",
      "content_length": 39,
      "difficulty": "Some(Wild)",
      "end_line": 51,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 51
    },
    {
      "code_content": "    fn calculate_processing_delay",
      "content_length": 33,
      "difficulty": "Some(Easy)",
      "end_line": 535,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 535
    },
    {
      "code_content": "    fn calculate_processing_delay",
      "content_length": 33,
      "difficulty": "Some(Wild)",
      "end_line": 535,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 535
    },
    {
      "code_content": "    fn remove_from_access_order",
      "content_length": 31,
      "difficulty": "Some(Easy)",
      "end_line": 320,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 320
    },
    {
      "code_content": "    fn remove_from_access_order",
      "content_length": 31,
      "difficulty": "Some(Wild)",
      "end_line": 320,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 320
    },
    {
      "code_content": "impl Default for ServiceConfig",
      "content_length": 30,
      "difficulty": "Some(Easy)",
      "end_line": 25,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 25
    },
    {
      "code_content": "impl Default for ServiceConfig",
      "content_length": 30,
      "difficulty": "Some(Wild)",
      "end_line": 25,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 25
    },
    {
      "code_content": "    fn validate_request_limits",
      "content_length": 30,
      "difficulty": "Some(Easy)",
      "end_line": 883,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 883
    },
    {
      "code_content": "    fn validate_request_limits",
      "content_length": 30,
      "difficulty": "Some(Wild)",
      "end_line": 883,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 883
    },
    {
      "code_content": "    fn handle_options_request",
      "content_length": 29,
      "difficulty": "Some(Easy)",
      "end_line": 695,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 695
    },
    {
      "code_content": "    fn handle_options_request",
      "content_length": 29,
      "difficulty": "Some(Wild)",
      "end_line": 695,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 695
    },
    {
      "code_content": "    fn estimate_response_size",
      "content_length": 29,
      "difficulty": "Some(Easy)",
      "end_line": 704,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 704
    },
    {
      "code_content": "    fn estimate_response_size",
      "content_length": 29,
      "difficulty": "Some(Wild)",
      "end_line": 704,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 704
    },
    {
      "code_content": "    fn handle_delete_request",
      "content_length": 28,
      "difficulty": "Some(Easy)",
      "end_line": 666,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 666
    },
    {
      "code_content": "    fn handle_delete_request",
      "content_length": 28,
      "difficulty": "Some(Wild)",
      "end_line": 666,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 666
    },
    {
      "code_content": "    pub fn wait_for_response",
      "content_length": 28,
      "difficulty": "Some(Easy)",
      "end_line": 910,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 910
    },
    {
      "code_content": "    pub fn wait_for_response",
      "content_length": 28,
      "difficulty": "Some(Wild)",
      "end_line": 910,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 910
    },
    {
      "code_content": "    fn handle_patch_request",
      "content_length": 27,
      "difficulty": "Some(Easy)",
      "end_line": 680,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 680
    },
    {
      "code_content": "    fn handle_patch_request",
      "content_length": 27,
      "difficulty": "Some(Wild)",
      "end_line": 680,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 680
    },
    {
      "code_content": "pub struct ServiceResponse",
      "content_length": 26,
      "difficulty": "Some(Easy)",
      "end_line": 116,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 116
    },
    {
      "code_content": "pub struct ServiceResponse",
      "content_length": 26,
      "difficulty": "Some(Wild)",
      "end_line": 116,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 116
    },
    {
      "code_content": "    fn handle_post_request",
      "content_length": 26,
      "difficulty": "Some(Easy)",
      "end_line": 600,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 600
    },
    {
      "code_content": "    fn handle_post_request",
      "content_length": 26,
      "difficulty": "Some(Wild)",
      "end_line": 600,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 600
    },
    {
      "code_content": "pub struct ServiceRequest",
      "content_length": 25,
      "difficulty": "Some(Easy)",
      "end_line": 74,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 74
    },
    {
      "code_content": "pub struct ServiceRequest",
      "content_length": 25,
      "difficulty": "Some(Wild)",
      "end_line": 74,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 74
    },
    {
      "code_content": "    fn handle_get_request",
      "content_length": 25,
      "difficulty": "Some(Easy)",
      "end_line": 585,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 585
    },
    {
      "code_content": "    fn handle_get_request",
      "content_length": 25,
      "difficulty": "Some(Wild)",
      "end_line": 585,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 585
    },
    {
      "code_content": "    fn handle_put_request",
      "content_length": 25,
      "difficulty": "Some(Easy)",
      "end_line": 645,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 645
    },
    {
      "code_content": "    fn handle_put_request",
      "content_length": 25,
      "difficulty": "Some(Wild)",
      "end_line": 645,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 645
    },
    {
      "code_content": "pub struct ComplexService",
      "content_length": 25,
      "difficulty": "Some(Easy)",
      "end_line": 723,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 723
    },
    {
      "code_content": "pub struct ComplexService",
      "content_length": 25,
      "difficulty": "Some(Wild)",
      "end_line": 723,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 723
    },
    {
      "code_content": "pub struct ServiceMetrics",
      "content_length": 25,
      "difficulty": "Some(Easy)",
      "end_line": 735,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 735
    },
    {
      "code_content": "pub struct ServiceMetrics",
      "content_length": 25,
      "difficulty": "Some(Wild)",
      "end_line": 735,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 735
    },
    {
      "code_content": "    pub fn submit_request",
      "content_length": 25,
      "difficulty": "Some(Wild)",
      "end_line": 849,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 849
    },
    {
      "code_content": "    pub fn worker_metrics",
      "content_length": 25,
      "difficulty": "Some(Wild)",
      "end_line": 951,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 951
    },
    {
      "code_content": "pub struct ServiceConfig",
      "content_length": 24,
      "difficulty": "Some(Easy)",
      "end_line": 16,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 16
    },
    {
      "code_content": "pub struct ServiceConfig",
      "content_length": 24,
      "difficulty": "Some(Wild)",
      "end_line": 16,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 16
    },
    {
      "code_content": "pub struct WorkerMetrics",
      "content_length": 24,
      "difficulty": "Some(Easy)",
      "end_line": 356,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 356
    },
    {
      "code_content": "pub struct WorkerMetrics",
      "content_length": 24,
      "difficulty": "Some(Wild)",
      "end_line": 356,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 356
    },
    {
      "code_content": "pub enum ResponseStatus",
      "content_length": 23,
      "difficulty": "Some(Easy)",
      "end_line": 127,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 127
    },
    {
      "code_content": "pub enum ResponseStatus",
      "content_length": 23,
      "difficulty": "Some(Wild)",
      "end_line": 127,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 127
    },
    {
      "code_content": "    fn validate_request",
      "content_length": 23,
      "difficulty": "Some(Wild)",
      "end_line": 558,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 558
    },
    {
      "code_content": "    pub fn get_response",
      "content_length": 23,
      "difficulty": "Some(Wild)",
      "end_line": 905,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 905
    },
    {
      "code_content": "    pub fn health_check",
      "content_length": 23,
      "difficulty": "Some(Wild)",
      "end_line": 963,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 963
    },
    {
      "code_content": "pub enum RequestMethod",
      "content_length": 22,
      "difficulty": "Some(Easy)",
      "end_line": 85,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 85
    },
    {
      "code_content": "pub enum RequestMethod",
      "content_length": 22,
      "difficulty": "Some(Wild)",
      "end_line": 85,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 85
    },
    {
      "code_content": "    fn process_request",
      "content_length": 22,
      "difficulty": "Some(Wild)",
      "end_line": 495,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 495
    },
    {
      "code_content": "    fn validate_config",
      "content_length": 22,
      "difficulty": "Some(Wild)",
      "end_line": 782,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 782
    },
    {
      "code_content": "    pub fn cache_stats",
      "content_length": 22,
      "difficulty": "Some(Wild)",
      "end_line": 955,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 955
    },
    {
      "code_content": "    pub fn clear_cache",
      "content_length": 22,
      "difficulty": "Some(Wild)",
      "end_line": 959,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 959
    },
    {
      "code_content": "pub enum ServiceError",
      "content_length": 21,
      "difficulty": "Some(Wild)",
      "end_line": 40,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 40
    },
    {
      "code_content": "pub enum ResponseData",
      "content_length": 21,
      "difficulty": "Some(Wild)",
      "end_line": 139,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 139
    },
    {
      "code_content": "pub struct CacheStats",
      "content_length": 21,
      "difficulty": "Some(Wild)",
      "end_line": 201,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 201
    },
    {
      "code_content": "pub enum RequestData",
      "content_length": 20,
      "difficulty": "Some(Wild)",
      "end_line": 97,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 97
    },
    {
      "code_content": "    fn move_to_front",
      "content_length": 20,
      "difficulty": "Some(Wild)",
      "end_line": 307,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 307
    },
    {
      "code_content": "    fn add_to_front",
      "content_length": 19,
      "difficulty": "Some(Wild)",
      "end_line": 315,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 315
    },
    {
      "code_content": "impl ComplexService",
      "content_length": 19,
      "difficulty": "Some(Wild)",
      "end_line": 746,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 746
    },
    {
      "code_content": "struct CacheEntry",
      "content_length": 17,
      "difficulty": "Some(Wild)",
      "end_line": 148,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 148
    },
    {
      "code_content": "    fn is_expired",
      "content_length": 17,
      "difficulty": "Some(Wild)",
      "end_line": 174,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 174
    },
    {
      "code_content": "impl CacheStats",
      "content_length": 15,
      "difficulty": "Some(Wild)",
      "end_line": 209,
      "source_file": "tests/fixtures/complex_rust_service.rs",
      "start_line": 209
    }
  ],
  "chunk_types": [
    [
      "CodeBlock",
      96
    ],
    [
      "Conditional",
      41
    ],
    [
      "File",
      1
    ],
    [
      "Function",
      43
    ],
    [
      "FunctionCall",
      23
    ],
    [
      "Loop",
      6
    ]
  ],
  "difficulty_distribution": [
    [
      "Some(Easy)",
      176
    ],
    [
      "Some(Hard)",
      65
    ],
    [
      "Some(Normal)",
      121
    ],
    [
      "Some(Wild)",
      210
    ],
    [
      "Some(Zen)",
      1
    ]
  ],
  "total_challenges": 573,
  "total_chunks": 210
}
